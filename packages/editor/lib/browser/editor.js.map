{"version":3,"sources":["browser/editor.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAC,MAAM,6BAA6B,CAAC;AAEtE,OAAO,GAAG,MAAM,2BAA2B,CAAC;AAK5C,OAAO,EACL,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAC1B,CAAC;AAEF,MAAM,CAAC,MAAM,kBAAkB,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;AAqB/D;;;GAGG;AACH,MAAM,CAAN,IAAY,eAyDX;AAzDD,WAAY,eAAe;IACzB;;OAEG;IACH,2DAAW,CAAA;IACX;;OAEG;IACH,6DAAY,CAAA;IACZ;;OAEG;IACH,mFAAuB,CAAA;IACvB;;OAEG;IACH,mFAAuB,CAAA;IACvB;;OAEG;IACH,2FAA2B,CAAA;IAC3B;;OAEG;IACH,6EAAoB,CAAA;IACpB;;OAEG;IACH,qEAAgB,CAAA;IAChB;;OAEG;IACH,uEAAiB,CAAA;IACjB;;OAEG;IACH,+EAAqB,CAAA;IACrB;;OAEG;IACH,yEAAkB,CAAA;IAClB;;OAEG;IACH,0EAAmB,CAAA;IACnB;;OAEG;IACH,gEAAc,CAAA;IACd;;OAEG;IACH,0EAAmB,CAAA;IACnB;;OAEG;IACH,0EAAmB,CAAA;AACrB,CAAC,EAzDW,eAAe,KAAf,eAAe,QAyD1B;AAkOD,MAAM,KAAW,mBAAmB,CAKnC;AALD,WAAiB,mBAAmB;IAClC,8DAA8D;IAC9D,SAAgB,EAAE,CAAC,CAAM;QACvB,OAAO,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,YAAY,GAAG,CAAC;IACtC,CAAC;IAFe,sBAAE,KAEjB,CAAA;AACH,CAAC,EALgB,mBAAmB,KAAnB,mBAAmB,QAKnC;AAED,MAAM,KAAW,kBAAkB,CAIlC;AAJD,WAAiB,kBAAkB;IACjC,SAAgB,EAAE,CAAC,GAAuB;QACxC,OAAO,CAAC,CAAC,GAAG,IAAI,UAAU,IAAI,GAAG,CAAC;IACpC,CAAC;IAFe,qBAAE,KAEjB,CAAA;AACH,CAAC,EAJgB,kBAAkB,KAAlB,kBAAkB,QAIlC","file":"../../src/browser/editor.js","sourcesContent":["import {Location, Position, Range} from 'vscode-languageserver-types';\r\nimport * as lsp from '@tart/core/shared/vscode-languageserver-types';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {Navigatable, Saveable, Widget} from '@tart/core';\r\nimport {Disposable, Event, Reference, TextDocumentContentChangeDelta} from '@tart/core/lib/common';\r\nimport {EditorDecoration} from './decorations';\r\n\r\nexport {\r\n  Position, Range, Location\r\n};\r\n\r\nexport const TextEditorProvider = Symbol('TextEditorProvider');\r\nexport type TextEditorProvider = (uri: URI) => Promise<TextEditor>;\r\n\r\nexport interface TextEditorDocument extends lsp.TextDocument, Saveable, Disposable {\r\n  getLineContent(lineNumber: number): string;\r\n\r\n  getLineMaxColumn(lineNumber: number): number;\r\n\r\n  findMatches?(options: FindMatchesOptions): FindMatch[];\r\n}\r\n\r\nexport interface TextDocumentChangeEvent {\r\n  readonly document: TextEditorDocument;\r\n  readonly contentChanges: TextDocumentContentChangeDelta[];\r\n}\r\n\r\nexport interface EditorMouseEvent {\r\n  readonly event: MouseEvent;\r\n  readonly target: MouseTarget;\r\n}\r\n\r\n/**\r\n * Type of hit element with the mouse in the editor.\r\n * Copied from monaco editor.\r\n */\r\nexport enum MouseTargetType {\r\n  /**\r\n   * Mouse is on top of an unknown element.\r\n   */\r\n  UNKNOWN = 0,\r\n  /**\r\n   * Mouse is on top of the textarea used for input.\r\n   */\r\n  TEXTAREA = 1,\r\n  /**\r\n   * Mouse is on top of the glyph margin\r\n   */\r\n  GUTTER_GLYPH_MARGIN = 2,\r\n  /**\r\n   * Mouse is on top of the line numbers\r\n   */\r\n  GUTTER_LINE_NUMBERS = 3,\r\n  /**\r\n   * Mouse is on top of the line decorations\r\n   */\r\n  GUTTER_LINE_DECORATIONS = 4,\r\n  /**\r\n   * Mouse is on top of the whitespace left in the gutter by a view zone.\r\n   */\r\n  GUTTER_VIEW_ZONE = 5,\r\n  /**\r\n   * Mouse is on top of text in the content.\r\n   */\r\n  CONTENT_TEXT = 6,\r\n  /**\r\n   * Mouse is on top of empty space in the content (e.g. after line text or below last line)\r\n   */\r\n  CONTENT_EMPTY = 7,\r\n  /**\r\n   * Mouse is on top of a view zone in the content.\r\n   */\r\n  CONTENT_VIEW_ZONE = 8,\r\n  /**\r\n   * Mouse is on top of a content widget.\r\n   */\r\n  CONTENT_WIDGET = 9,\r\n  /**\r\n   * Mouse is on top of the decorations overview ruler.\r\n   */\r\n  OVERVIEW_RULER = 10,\r\n  /**\r\n   * Mouse is on top of a scrollbar.\r\n   */\r\n  SCROLLBAR = 11,\r\n  /**\r\n   * Mouse is on top of an overlay widget.\r\n   */\r\n  OVERLAY_WIDGET = 12,\r\n  /**\r\n   * Mouse is outside of the editor.\r\n   */\r\n  OUTSIDE_EDITOR = 13,\r\n}\r\n\r\nexport interface MouseTarget {\r\n  /**\r\n   * The target element\r\n   */\r\n  readonly element?: Element;\r\n  /**\r\n   * The target type\r\n   */\r\n  readonly type: MouseTargetType;\r\n  /**\r\n   * The 'approximate' editor position\r\n   */\r\n  readonly position?: Position;\r\n  /**\r\n   * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\r\n   */\r\n  readonly mouseColumn: number;\r\n  /**\r\n   * The 'approximate' editor range\r\n   */\r\n  readonly range?: Range;\r\n  /**\r\n   * Some extra detail.\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  readonly detail: any;\r\n}\r\n\r\nexport const enum EncodingMode {\r\n\r\n  /**\r\n   * Instructs the encoding support to encode the current input with the provided encoding\r\n   */\r\n  Encode,\r\n\r\n  /**\r\n   * Instructs the encoding support to decode the current input with the provided encoding\r\n   */\r\n  Decode\r\n}\r\n\r\n/**\r\n * Options for searching in an editor.\r\n */\r\nexport interface FindMatchesOptions {\r\n  /**\r\n   * The string used to search. If it is a regular expression, set `isRegex` to true.\r\n   */\r\n  searchString: string;\r\n  /**\r\n   * Used to indicate that `searchString` is a regular expression.\r\n   */\r\n  isRegex: boolean;\r\n  /**\r\n   * Force the matching to match lower/upper case exactly.\r\n   */\r\n  matchCase: boolean;\r\n  /**\r\n   * Force the matching to match entire words only.\r\n   */\r\n  matchWholeWord: boolean;\r\n  /**\r\n   * Limit the number of results.\r\n   */\r\n  limitResultCount?: number;\r\n}\r\n\r\n/**\r\n * Representation of a find match.\r\n */\r\nexport interface FindMatch {\r\n  /**\r\n   * The textual match.\r\n   */\r\n  readonly matches: string[];\r\n  /**\r\n   * The range for the given match.\r\n   */\r\n  readonly range: Range;\r\n}\r\n\r\nexport interface TextEditor extends Disposable, Navigatable {\r\n  readonly node: HTMLElement;\r\n\r\n  readonly uri: URI;\r\n  readonly document: TextEditorDocument;\r\n  readonly onDocumentContentChanged: Event<TextDocumentChangeEvent>;\r\n\r\n\r\n  cursor: Position;\r\n  readonly onCursorPositionChanged: Event<Position>;\r\n\r\n  selection: Range;\r\n  readonly onSelectionChanged: Event<Range>;\r\n  readonly onFocusChanged: Event<boolean>;\r\n  readonly onMouseDown: Event<EditorMouseEvent>;\r\n  readonly onScrollChanged: Event<void>;\r\n  readonly onLanguageChanged: Event<string>;\r\n  readonly onEncodingChanged: Event<string>;\r\n\r\n  /**\r\n   * The text editor should be revealed,\r\n   * otherwise it won't receive the focus.\r\n   */\r\n  focus(): void;\r\n\r\n  blur(): void;\r\n\r\n  isFocused(): boolean;\r\n\r\n  getVisibleRanges(): Range[];\r\n\r\n  revealPosition(position: Position, options?: RevealPositionOptions): void;\r\n\r\n  revealRange(range: Range, options?: RevealRangeOptions): void;\r\n\r\n  /**\r\n   * Rerender the editor.\r\n   */\r\n  refresh(): void;\r\n\r\n  /**\r\n   * Resize the editor to fit its node.\r\n   */\r\n  resizeToFit(): void;\r\n\r\n  setSize(size: Dimension): void;\r\n\r\n  /**\r\n   * Applies given new decorations, and removes old decorations identified by ids.\r\n   *\r\n   * @returns identifiers of applied decorations, which can be removed in next call.\r\n   */\r\n  deltaDecorations(params: DeltaDecorationParams): string[];\r\n\r\n  /**\r\n   * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\r\n   * @param startLineNumber The start line number.\r\n   * @param endLineNumber The end line number.\r\n   * @return An array with the decorations.\r\n   */\r\n  getLinesDecorations(startLineNumber: number, endLineNumber: number): EditorDecoration[];\r\n\r\n  getVisibleColumn(position: Position): number;\r\n\r\n  /**\r\n   * Replaces the text of source given in ReplaceTextParams.\r\n   * @param params: ReplaceTextParams\r\n   */\r\n  replaceText(params: ReplaceTextParams): Promise<boolean>;\r\n\r\n  /**\r\n   * Execute edits on the editor.\r\n   * @param edits: edits created with `lsp.TextEdit.replace`, `lsp.TextEdit.insert`, `lsp.TextEdit.del`\r\n   */\r\n  executeEdits(edits: lsp.TextEdit[]): boolean;\r\n\r\n  storeViewState(): object;\r\n\r\n  restoreViewState(state: object): void;\r\n\r\n  detectLanguage(): void;\r\n\r\n  setLanguage(languageId: string): void;\r\n\r\n  /**\r\n   * Gets the encoding of the input if known.\r\n   */\r\n  getEncoding(): string;\r\n\r\n  /**\r\n   * Sets the encoding for the input for saving.\r\n   */\r\n  setEncoding(encoding: string, mode: EncodingMode): void;\r\n}\r\n\r\nexport interface TextEditorSelection {\r\n  uri: URI\r\n  cursor?: Position\r\n  selection?: Range\r\n}\r\n\r\n\r\nexport interface Dimension {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface RevealPositionOptions {\r\n  vertical: 'auto' | 'center' | 'centerIfOutsideViewport';\r\n  horizontal?: boolean;\r\n}\r\n\r\nexport interface RevealRangeOptions {\r\n  at: 'auto' | 'center' | 'top' | 'centerIfOutsideViewport';\r\n}\r\n\r\nexport interface DeltaDecorationParams {\r\n  oldDecorations: string[];\r\n  newDecorations: EditorDecoration[];\r\n}\r\n\r\nexport interface ReplaceTextParams {\r\n  /**\r\n   * the source to edit\r\n   */\r\n  source: string;\r\n  /**\r\n   * the replace operations\r\n   */\r\n  replaceOperations: ReplaceOperation[];\r\n}\r\n\r\nexport interface ReplaceOperation {\r\n  /**\r\n   * the position that shall be replaced\r\n   */\r\n  range: Range;\r\n  /**\r\n   * the text to replace with\r\n   */\r\n  text: string;\r\n}\r\n\r\nexport namespace TextEditorSelection {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  export function is(e: any): e is TextEditorSelection {\r\n    return e && e['uri'] instanceof URI;\r\n  }\r\n}\r\n\r\nexport namespace CustomEditorWidget {\r\n  export function is(arg: Widget | undefined): arg is CustomEditorWidget {\r\n    return !!arg && 'modelRef' in arg;\r\n  }\r\n}\r\n\r\nexport interface CustomEditorWidget extends Widget {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  readonly modelRef: Reference<any>;\r\n}\r\n"]}