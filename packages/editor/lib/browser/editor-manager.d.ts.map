{"version":3,"sources":["browser/editor-manager.ts"],"names":[],"mappings":"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","file":"../../src/browser/editor-manager.d.ts","sourcesContent":["import {injectable, postConstruct} from 'inversify';\r\nimport {EditorWidget} from './editor-widget';\r\nimport {NavigatableWidgetOpenHandler, NavigatableWidgetOptions, Widget, WidgetOpenerOptions} from '@tart/core';\r\nimport {Emitter, Event, MaybePromise, RecursivePartial} from '@tart/core/lib/common';\r\nimport {EditorWidgetFactory} from './editor-widget-factory';\r\nimport {Position, Range} from './editor';\r\nimport URI from '@tart/core/lib/common/uri';\r\n\r\nexport interface WidgetId {\r\n  id: number;\r\n  uri: string;\r\n}\r\n\r\nexport interface EditorOpenerOptions extends WidgetOpenerOptions {\r\n  selection?: RecursivePartial<Range>;\r\n  preview?: boolean;\r\n  counter?: number\r\n}\r\n\r\n@injectable()\r\nexport class EditorManager extends NavigatableWidgetOpenHandler<EditorWidget> {\r\n\r\n  readonly id = EditorWidgetFactory.ID;\r\n\r\n  readonly label = 'Code Editor';\r\n\r\n  protected readonly editorCounters = new Map<string, number>();\r\n\r\n  protected readonly onActiveEditorChangedEmitter = new Emitter<EditorWidget | undefined>();\r\n  /**\r\n   * Emit when the active editor is changed.\r\n   */\r\n  readonly onActiveEditorChanged: Event<EditorWidget | undefined> = this.onActiveEditorChangedEmitter.event;\r\n\r\n  protected readonly onCurrentEditorChangedEmitter = new Emitter<EditorWidget | undefined>();\r\n  /**\r\n   * Emit when the current editor is changed.\r\n   */\r\n  readonly onCurrentEditorChanged: Event<EditorWidget | undefined> = this.onCurrentEditorChangedEmitter.event;\r\n  protected readonly recentlyVisibleIds: string[] = [];\r\n\r\n  protected _activeEditor: EditorWidget | undefined;\r\n\r\n  /**\r\n   * The active editor.\r\n   * If there is an active editor (one that has focus), active and current are the same.\r\n   */\r\n  get activeEditor(): EditorWidget | undefined {\r\n    return this._activeEditor;\r\n  }\r\n\r\n  protected _currentEditor: EditorWidget | undefined;\r\n\r\n  /**\r\n   * The most recently activated editor (which might not have the focus anymore, hence it is not active).\r\n   * If no editor has focus, e.g. when a context menu is shown, the active editor is `undefined`, but current might be the editor that was active before the menu popped up.\r\n   */\r\n  get currentEditor(): EditorWidget | undefined {\r\n    return this._currentEditor;\r\n  }\r\n\r\n  protected get recentlyVisible(): EditorWidget | undefined {\r\n    const id = this.recentlyVisibleIds[0];\r\n    return id && this.all.find(w => w.id === id) || undefined;\r\n  }\r\n\r\n  getByUri(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget | undefined> {\r\n    return this.getWidget(uri, options);\r\n  }\r\n\r\n  getOrCreateByUri(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget> {\r\n    return this.getOrCreateWidget(uri, options);\r\n  }\r\n\r\n  canHandle(uri: URI, options?: WidgetOpenerOptions): number {\r\n    return 100;\r\n  }\r\n\r\n  // This override only serves to inform external callers that they can use EditorOpenerOptions.\r\n  open(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget> {\r\n    return super.open(uri, options);\r\n  }\r\n\r\n  /**\r\n   * Opens an editor to the side of the current editor. Defaults to opening to the right.\r\n   * To modify direction, pass options with `{widgetOptions: {mode: ...}}`\r\n   */\r\n  openToSide(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget> {\r\n    const counter = this.createCounterForUri(uri);\r\n    const splitOptions: EditorOpenerOptions = {widgetOptions: {mode: 'split-right'}, ...options, counter};\r\n    return this.open(uri, splitOptions);\r\n  }\r\n\r\n  @postConstruct()\r\n  protected init(): void {\r\n    super.init();\r\n    this.shell.onDidChangeActiveWidget(() => this.updateActiveEditor());\r\n    this.shell.onDidChangeCurrentWidget(() => this.updateCurrentEditor());\r\n    this.onCreated(widget => {\r\n      widget.onDidChangeVisibility(() => {\r\n        if (widget.isVisible) {\r\n          this.addRecentlyVisible(widget);\r\n        }\r\n        this.updateCurrentEditor();\r\n      });\r\n      this.checkCounterForWidget(widget);\r\n      widget.disposed.connect(() => {\r\n        this.removeFromCounter(widget);\r\n        this.removeRecentlyVisible(widget);\r\n        this.updateCurrentEditor();\r\n      });\r\n    });\r\n    for (const widget of this.all) {\r\n      if (widget.isVisible) {\r\n        this.addRecentlyVisible(widget);\r\n      }\r\n    }\r\n    this.updateCurrentEditor();\r\n  }\r\n\r\n  protected tryGetPendingWidget(uri: URI, options?: EditorOpenerOptions): MaybePromise<EditorWidget> | undefined {\r\n    const editorPromise = super.tryGetPendingWidget(uri, options);\r\n    if (editorPromise) {\r\n      // Reveal selection before attachment to manage nav stack. (https://github.com/eclipse-wm/wm/issues/8955)\r\n      if (!(editorPromise instanceof Widget)) {\r\n        editorPromise.then(editor => this.revealSelection(editor, options, uri));\r\n      } else {\r\n        this.revealSelection(editorPromise, options);\r\n      }\r\n    }\r\n    return editorPromise;\r\n  }\r\n\r\n  protected async getWidget(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget | undefined> {\r\n    const editor = await super.getWidget(uri, options);\r\n    if (editor) {\r\n      // Reveal selection before attachment to manage nav stack. (https://github.com/eclipse-wm/wm/issues/8955)\r\n      this.revealSelection(editor, options, uri);\r\n    }\r\n    return editor;\r\n  }\r\n\r\n  protected async getOrCreateWidget(uri: URI, options?: EditorOpenerOptions): Promise<EditorWidget> {\r\n    const editor = await super.getOrCreateWidget(uri, options);\r\n    // Reveal selection before attachment to manage nav stack. (https://github.com/eclipse-wm/wm/issues/8955)\r\n    this.revealSelection(editor, options, uri);\r\n    return editor;\r\n  }\r\n\r\n  protected addRecentlyVisible(widget: EditorWidget): void {\r\n    this.removeRecentlyVisible(widget);\r\n    this.recentlyVisibleIds.unshift(widget.id);\r\n  }\r\n\r\n  protected removeRecentlyVisible(widget: EditorWidget): void {\r\n    const index = this.recentlyVisibleIds.indexOf(widget.id);\r\n    if (index !== -1) {\r\n      this.recentlyVisibleIds.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  protected setActiveEditor(active: EditorWidget | undefined): void {\r\n    if (this._activeEditor !== active) {\r\n      this._activeEditor = active;\r\n      this.onActiveEditorChangedEmitter.fire(this._activeEditor);\r\n    }\r\n  }\r\n\r\n  protected updateActiveEditor(): void {\r\n    const widget = this.shell.activeWidget;\r\n    if (widget instanceof EditorWidget) {\r\n      this.addRecentlyVisible(widget);\r\n      this.setActiveEditor(widget);\r\n    } else {\r\n      this.setActiveEditor(undefined);\r\n    }\r\n  }\r\n\r\n  protected setCurrentEditor(current: EditorWidget | undefined): void {\r\n    if (this._currentEditor !== current) {\r\n      this._currentEditor = current;\r\n      this.onCurrentEditorChangedEmitter.fire(this._currentEditor);\r\n    }\r\n  }\r\n\r\n  protected updateCurrentEditor(): void {\r\n    const widget = this.shell.currentWidget;\r\n    if (widget instanceof EditorWidget) {\r\n      this.setCurrentEditor(widget);\r\n    } else if (!this._currentEditor || !this._currentEditor.isVisible || this.currentEditor !== this.recentlyVisible) {\r\n      this.setCurrentEditor(this.recentlyVisible);\r\n    }\r\n  }\r\n\r\n  protected revealSelection(widget: EditorWidget, input?: EditorOpenerOptions, uri?: URI): void {\r\n    let inputSelection = input?.selection;\r\n    if (!inputSelection && uri) {\r\n      const match = /^L?(\\d+)(?:,(\\d+))?/.exec(uri.fragment);\r\n      if (match) {\r\n        // support file:///some/file.js#73,84\r\n        // support file:///some/file.js#L73\r\n        inputSelection = {\r\n          start: {\r\n            line: parseInt(match[1]) - 1,\r\n            character: match[2] ? parseInt(match[2]) - 1 : 0\r\n          }\r\n        };\r\n      }\r\n    }\r\n    if (inputSelection) {\r\n      const editor = widget.editor;\r\n      const selection = this.getSelection(widget, inputSelection);\r\n      if (Position.is(selection)) {\r\n        editor.cursor = selection;\r\n        editor.revealPosition(selection);\r\n      } else if (Range.is(selection)) {\r\n        editor.cursor = selection.end;\r\n        editor.selection = selection;\r\n        editor.revealRange(selection);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected getSelection(widget: EditorWidget, selection: RecursivePartial<Range>): Range | Position | undefined {\r\n    const {start, end} = selection;\r\n    const line = start && start.line !== undefined && start.line >= 0 ? start.line : undefined;\r\n    if (line === undefined) {\r\n      return undefined;\r\n    }\r\n    const character = start && start.character !== undefined && start.character >= 0 ? start.character : widget.editor.document.getLineMaxColumn(line);\r\n    const endLine = end && end.line !== undefined && end.line >= 0 ? end.line : undefined;\r\n    if (endLine === undefined) {\r\n      return {line, character};\r\n    }\r\n    const endCharacter = end && end.character !== undefined && end.character >= 0 ? end.character : widget.editor.document.getLineMaxColumn(endLine);\r\n    return {\r\n      start: {line, character},\r\n      end: {line: endLine, character: endCharacter}\r\n    };\r\n  }\r\n\r\n  protected removeFromCounter(widget: EditorWidget): void {\r\n    const {id, uri} = this.extractIdFromWidget(widget);\r\n    if (uri && !Number.isNaN(id)) {\r\n      let max = -Infinity;\r\n      this.all.forEach(editor => {\r\n        const candidateID = this.extractIdFromWidget(editor);\r\n        if ((candidateID.uri === uri) && (candidateID.id > max)) {\r\n          max = candidateID.id!;\r\n        }\r\n      });\r\n\r\n      if (max > -Infinity) {\r\n        this.editorCounters.set(uri, max);\r\n      } else {\r\n        this.editorCounters.delete(uri);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected extractIdFromWidget(widget: EditorWidget): WidgetId {\r\n    const uri = widget.editor.uri.toString();\r\n    const id = Number(widget.id.slice(widget.id.lastIndexOf(':') + 1));\r\n    return {id, uri};\r\n  }\r\n\r\n  protected checkCounterForWidget(widget: EditorWidget): void {\r\n    const {id, uri} = this.extractIdFromWidget(widget);\r\n    const numericalId = Number(id);\r\n    if (uri && !Number.isNaN(numericalId)) {\r\n      const highestKnownId = this.editorCounters.get(uri) ?? -Infinity;\r\n      if (numericalId > highestKnownId) {\r\n        this.editorCounters.set(uri, numericalId);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected createCounterForUri(uri: URI): number {\r\n    const identifier = uri.toString();\r\n    const next = (this.editorCounters.get(identifier) ?? 0) + 1;\r\n    return next;\r\n  }\r\n\r\n  protected getCounterForUri(uri: URI): number | undefined {\r\n    const idWithoutCounter = EditorWidgetFactory.createID(uri);\r\n    const counterOfMostRecentlyVisibleEditor = this.recentlyVisibleIds.find(id => id.startsWith(idWithoutCounter))?.slice(idWithoutCounter.length + 1);\r\n    return counterOfMostRecentlyVisibleEditor === undefined ? undefined : parseInt(counterOfMostRecentlyVisibleEditor);\r\n  }\r\n\r\n  protected getOrCreateCounterForUri(uri: URI): number {\r\n    return this.getCounterForUri(uri) ?? this.createCounterForUri(uri);\r\n  }\r\n\r\n  protected createWidgetOptions(uri: URI, options?: EditorOpenerOptions): NavigatableWidgetOptions {\r\n    const navigatableOptions = super.createWidgetOptions(uri, options);\r\n    navigatableOptions.counter = options?.counter ?? this.getOrCreateCounterForUri(uri);\r\n    return navigatableOptions;\r\n  }\r\n}\r\n"]}