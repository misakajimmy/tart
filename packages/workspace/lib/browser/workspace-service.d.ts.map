{"version":3,"sources":["browser/workspace-service.ts"],"names":[],"mappings":"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","file":"../../src/browser/workspace-service.d.ts","sourcesContent":["import {inject, injectable, postConstruct} from 'inversify';\r\nimport {PreferenceSchemaProvider, PreferenceScope, PreferenceServiceImpl, WindowService} from '@tart/core';\r\nimport {BaseStat, FileStat} from '@tart/filesystem/lib/common/files';\r\nimport {Deferred} from '@tart/core/lib/common/promise-util';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport * as jsoncparser from 'jsonc-parser';\r\nimport Ajv from 'ajv';\r\nimport {FileService} from '@tart/filesystem/lib/browser/file-service';\r\nimport {VSCODE_EXT, WM_EXT} from '../common';\r\nimport {WorkspacePreferences} from './workspace-preference';\r\nimport {Disposable, DisposableCollection, Emitter, Event, MaybePromise} from '@tart/core/lib/common';\r\nimport {workspaceSchema} from './workspace-schema-updater';\r\nimport {FileSystemPreferences} from '@tart/filesystem/lib/browser/filesystem-preferences';\r\nimport {DEFAULT_WINDOW_HASH} from '@tart/core/lib/common/window';\r\nimport {FrontendApplicationConfigProvider} from '@tart/core/lib/browser/frontend-application-config-provider';\r\n\r\n/**\r\n *  The workspace service\r\n */\r\n@injectable()\r\nexport class WorkspaceService {\r\n\r\n  protected deferredRoots = new Deferred<FileStat[]>();\r\n  @inject(FileService)\r\n  protected readonly fileService: FileService;\r\n  @inject(WorkspacePreferences)\r\n  protected preferences: WorkspacePreferences;\r\n  @inject(WindowService)\r\n  protected readonly windowService: WindowService;\r\n  @inject(PreferenceServiceImpl)\r\n  protected readonly preferenceImpl: PreferenceServiceImpl;\r\n  @inject(PreferenceSchemaProvider)\r\n  protected readonly schemaProvider: PreferenceSchemaProvider;\r\n  @inject(FileSystemPreferences)\r\n  protected readonly fsPreferences: FileSystemPreferences;\r\n  protected applicationName: string;\r\n  protected readonly onWorkspaceLocationChangedEmitter = new Emitter<FileStat | undefined>();\r\n  protected readonly toDisposeOnWorkspace = new DisposableCollection();\r\n  protected readonly onWorkspaceChangeEmitter = new Emitter<FileStat[]>();\r\n  protected readonly rootWatchers = new Map<string, Disposable>();\r\n\r\n  protected _workspace: FileStat | undefined;\r\n\r\n  get workspace(): FileStat | undefined {\r\n    return this._workspace;\r\n  }\r\n\r\n  protected _roots: FileStat[] = [];\r\n\r\n  get roots(): Promise<FileStat[]> {\r\n    return this.deferredRoots.promise;\r\n  }\r\n\r\n  protected _ready = new Deferred<void>();\r\n\r\n  get ready(): Promise<void> {\r\n    return this._ready.promise;\r\n  }\r\n\r\n  get onWorkspaceLocationChanged(): Event<FileStat | undefined> {\r\n    return this.onWorkspaceLocationChangedEmitter.event;\r\n  }\r\n\r\n  get onWorkspaceChanged(): Event<FileStat[]> {\r\n    return this.onWorkspaceChangeEmitter.event;\r\n  }\r\n\r\n  get saved(): boolean {\r\n    return !!this._workspace && !this._workspace.isDirectory;\r\n  }\r\n\r\n  /**\r\n   * Returns `true` if theia has an opened workspace or folder\r\n   * @returns {boolean}\r\n   */\r\n  get opened(): boolean {\r\n    return !!this._workspace;\r\n  }\r\n\r\n  tryGetRoots(): FileStat[] {\r\n    return this._roots;\r\n  }\r\n\r\n  /**\r\n   * Returns the workspace root uri that the given file belongs to.\r\n   * In case that the file is found in more than one workspace roots, returns the root that is closest to the file.\r\n   * If the file is not from the current workspace, returns `undefined`.\r\n   * @param uri URI of the file\r\n   */\r\n  getWorkspaceRootUri(uri: URI | undefined): URI | undefined {\r\n    if (!uri) {\r\n      const root = this.tryGetRoots()[0];\r\n      if (root) {\r\n        return root.resource;\r\n      }\r\n      return undefined;\r\n    }\r\n    const rootUris: URI[] = [];\r\n    for (const root of this.tryGetRoots()) {\r\n      const rootUri = root.resource;\r\n      if (rootUri && rootUri.isEqualOrParent(uri)) {\r\n        rootUris.push(rootUri);\r\n      }\r\n    }\r\n    return rootUris.sort((r1, r2) => r2.toString().length - r1.toString().length)[0];\r\n  }\r\n\r\n  /**\r\n   * Adds root folder(s) to the workspace\r\n   * @param uris URI or URIs of the root folder(s) to add\r\n   */\r\n  async addRoot(uris: URI[] | URI): Promise<void> {\r\n    const toAdd = Array.isArray(uris) ? uris : [uris];\r\n    await this.spliceRoots(this._roots.length, 0, ...toAdd);\r\n  }\r\n\r\n  async spliceRoots(start: number, deleteCount?: number, ...rootsToAdd: URI[]): Promise<URI[]> {\r\n    if (!this._workspace) {\r\n      throw new Error('There is not active workspace');\r\n    }\r\n    const dedup = new Set<string>();\r\n    const roots = this._roots.map(root => (dedup.add(root.resource.toString()), root.resource.toString()));\r\n    const toAdd: string[] = [];\r\n    for (const root of rootsToAdd) {\r\n      const uri = root.toString();\r\n      if (!dedup.has(uri)) {\r\n        dedup.add(uri);\r\n        toAdd.push(uri);\r\n      }\r\n    }\r\n    const toRemove = roots.splice(start, deleteCount || 0, ...toAdd);\r\n    if (!toRemove.length && !toAdd.length) {\r\n      return [];\r\n    }\r\n    if (this._workspace.isDirectory) {\r\n      // const untitledWorkspace = await this.getUntitledWorkspace();\r\n      const untitledWorkspace = new URI();\r\n      await this.save(untitledWorkspace);\r\n    }\r\n    const currentData = await this.getWorkspaceDataFromFile();\r\n    const newData = WorkspaceData.buildWorkspaceData(roots, currentData);\r\n    await this.writeWorkspaceFile(this._workspace, newData);\r\n    await this.updateWorkspace();\r\n    return toRemove.map(root => new URI(root));\r\n  }\r\n\r\n  /**\r\n   * Save workspace data into a file\r\n   * @param uri URI or FileStat of the workspace file\r\n   */\r\n  async save(uri: URI | FileStat): Promise<void> {\r\n    const resource = uri instanceof URI ? uri : uri.resource;\r\n    if (!await this.fileService.exists(resource)) {\r\n      await this.fileService.create(resource);\r\n    }\r\n    const workspaceData: WorkspaceData = {folders: [], settings: {}};\r\n    if (!this.saved) {\r\n      for (const p of Object.keys(this.schemaProvider.getCombinedSchema().properties)) {\r\n        if (this.schemaProvider.isValidInScope(p, PreferenceScope.Default)) {\r\n          continue;\r\n        }\r\n        const preferences = this.preferenceImpl.inspect(p);\r\n        // if (preferences && preferences.workspaceValue) {\r\n        //     workspaceData.settings![p] = preferences.workspaceValue;\r\n        // }\r\n      }\r\n    }\r\n    let stat = await this.toFileStat(resource);\r\n    Object.assign(workspaceData, await this.getWorkspaceDataFromFile());\r\n    console.log(stat);\r\n    stat = await this.writeWorkspaceFile(stat, WorkspaceData.buildWorkspaceData(this._roots, workspaceData));\r\n    console.log(stat);\r\n    await this.setWorkspace(stat);\r\n    this.onWorkspaceLocationChangedEmitter.fire(stat);\r\n  }\r\n\r\n  /**\r\n   * Opens directory, or recreates a workspace from the file that `uri` points to.\r\n   */\r\n  open(uri: URI, options?: WorkspaceInput): void {\r\n    this.doOpen(uri, options);\r\n  }\r\n\r\n  @postConstruct()\r\n  protected async init(): Promise<void> {\r\n    this.applicationName = FrontendApplicationConfigProvider.get().applicationName;\r\n    const wsUri = await this.getDefaultWorkspaceUri();\r\n    const wsStat = await this.toFileStat(wsUri);\r\n    await this.setWorkspace(wsStat);\r\n    this._ready.resolve();\r\n  }\r\n\r\n  protected async setWorkspace(workspaceStat: FileStat | undefined): Promise<void> {\r\n    if (this._workspace && workspaceStat &&\r\n        this._workspace.resource === workspaceStat.resource &&\r\n        this._workspace.mtime === workspaceStat.mtime &&\r\n        this._workspace.etag === workspaceStat.etag &&\r\n        this._workspace.size === workspaceStat.size) {\r\n      return;\r\n    }\r\n    this.toDisposeOnWorkspace.dispose();\r\n    this._workspace = workspaceStat;\r\n    if (this._workspace) {\r\n      const uri = this._workspace.resource;\r\n      if (this._workspace.isFile) {\r\n        this.toDisposeOnWorkspace.push(this.fileService.watch(uri));\r\n        this.onWorkspaceLocationChangedEmitter.fire(this._workspace);\r\n      }\r\n      this.setURLFragment(uri.path.toString());\r\n    } else {\r\n      this.setURLFragment('');\r\n    }\r\n    this.updateTitle();\r\n    await this.updateWorkspace();\r\n  }\r\n\r\n  protected updateTitle(): void {\r\n    let title: string | undefined;\r\n    if (this._workspace) {\r\n      const displayName = this._workspace.name;\r\n      if (!this._workspace.isDirectory &&\r\n          (displayName.endsWith(`.${WM_EXT}`) || displayName.endsWith(`.${VSCODE_EXT}`))) {\r\n        title = displayName.slice(0, displayName.lastIndexOf('.'));\r\n      } else {\r\n        title = displayName;\r\n      }\r\n    }\r\n    document.title = this.formatTitle(title);\r\n  }\r\n\r\n  /**\r\n   * Resolves to the default workspace URI as string.\r\n   *\r\n   * The default implementation tries to extract the default workspace location\r\n   * from the `window.location.hash`, then falls-back to the most recently\r\n   * used workspace root from the server.\r\n   *\r\n   * It is not ensured that the resolved workspace URI is valid, it can point\r\n   * to a non-existing location.\r\n   */\r\n  protected getDefaultWorkspaceUri(): MaybePromise<string | undefined> {\r\n    return this.doGetDefaultWorkspaceUri();\r\n  }\r\n\r\n  protected formatTitle(title?: string): string {\r\n    const name = this.applicationName;\r\n    return title ? `${title} â€” ${name}` : name;\r\n  }\r\n\r\n  // async getUntitledWorkspace(): Promise<URI> {\r\n  //     return getTemporaryWorkspaceFileUri(this.envVariableServer);\r\n  // }\r\n\r\n  protected async doGetDefaultWorkspaceUri(): Promise<string | undefined> {\r\n\r\n    // If an empty window is explicitly requested do not restore a previous workspace.\r\n    // Note: `window.location.hash` includes leading \"#\" if non-empty.\r\n    if (window.location.hash === `#${DEFAULT_WINDOW_HASH}`) {\r\n      window.location.hash = '';\r\n      return undefined;\r\n    }\r\n\r\n    // Prefer the workspace path specified as the URL fragment, if present.\r\n    if (window.location.hash.length > 1) {\r\n      // Remove the leading # and decode the URI.\r\n      const wpPath = decodeURI(window.location.hash.substring(1));\r\n      const workspaceUri = new URI().withPath(wpPath).withScheme('file');\r\n      let workspaceStat: FileStat | undefined;\r\n      try {\r\n        workspaceStat = await this.fileService.resolve(workspaceUri);\r\n      } catch {\r\n      }\r\n      if (workspaceStat && !workspaceStat.isDirectory && !this.isWorkspaceFile(workspaceStat)) {\r\n        console.error(`Not a valid workspace file: ${workspaceUri}`);\r\n        return undefined;\r\n      }\r\n      return workspaceUri.toString();\r\n    } else {\r\n      // Else, ask the server for its suggested workspace (usually the one\r\n      // specified on the CLI, or the most recent).\r\n      // return this.server.getMostRecentlyUsedWorkspace();\r\n    }\r\n  }\r\n\r\n  protected async writeWorkspaceFile(workspaceFile: FileStat | undefined, workspaceData: WorkspaceData): Promise<FileStat | undefined> {\r\n    if (workspaceFile) {\r\n      const data = JSON.stringify(WorkspaceData.transformToRelative(workspaceData, workspaceFile));\r\n      const edits = jsoncparser.format(data, undefined, {tabSize: 3, insertSpaces: true, eol: ''});\r\n      const result = jsoncparser.applyEdits(data, edits);\r\n      await this.fileService.write(workspaceFile.resource, result);\r\n      return this.fileService.resolve(workspaceFile.resource);\r\n    }\r\n  }\r\n\r\n  protected async watchRoot(root: FileStat): Promise<void> {\r\n    const uriStr = root.resource.toString();\r\n    if (this.rootWatchers.has(uriStr)) {\r\n      return;\r\n    }\r\n    // const excludes = this.getExcludes(uriStr);\r\n    const excludes = [];\r\n    const watcher = this.fileService.watch(new URI(uriStr), {\r\n      recursive: true,\r\n      excludes\r\n    });\r\n    this.rootWatchers.set(uriStr, new DisposableCollection(\r\n        watcher,\r\n        Disposable.create(() => this.rootWatchers.delete(uriStr))\r\n    ));\r\n  }\r\n\r\n  protected getExcludes(uri: string): string[] {\r\n    const patterns = this.fsPreferences.get('files.watcherExclude', undefined, uri);\r\n    return Object.keys(patterns).filter(pattern => patterns[pattern]);\r\n  }\r\n\r\n  protected async watchRoots(): Promise<void> {\r\n    const rootUris = new Set(this._roots.map(r => r.resource.toString()));\r\n    for (const [uri, watcher] of this.rootWatchers.entries()) {\r\n      if (!rootUris.has(uri)) {\r\n        watcher.dispose();\r\n      }\r\n    }\r\n    for (const root of this._roots) {\r\n      this.watchRoot(root);\r\n    }\r\n  }\r\n\r\n  protected async updateWorkspace(): Promise<void> {\r\n    await this.updateRoots();\r\n    this.watchRoots();\r\n  }\r\n\r\n  protected async updateRoots(): Promise<void> {\r\n    const newRoots = await this.computeRoots();\r\n    let rootsChanged = false;\r\n    if (newRoots.length !== this._roots.length || newRoots.length === 0) {\r\n      rootsChanged = true;\r\n    } else {\r\n      for (const newRoot of newRoots) {\r\n        if (!this._roots.some(r => r.resource.toString() === newRoot.resource.toString())) {\r\n          rootsChanged = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (rootsChanged) {\r\n      this._roots = newRoots;\r\n      this.deferredRoots.resolve(this._roots); // in order to resolve first\r\n      this.deferredRoots = new Deferred<FileStat[]>();\r\n      this.deferredRoots.resolve(this._roots);\r\n      this.onWorkspaceChangeEmitter.fire(this._roots);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * returns a FileStat if the argument URI points to an existing directory. Otherwise, `undefined`.\r\n   */\r\n  protected async toValidRoot(uri: URI | string | undefined): Promise<FileStat | undefined> {\r\n    const fileStat = await this.toFileStat(uri);\r\n    if (fileStat && fileStat.isDirectory) {\r\n      return fileStat;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  protected async computeRoots(): Promise<FileStat[]> {\r\n    const roots: FileStat[] = [];\r\n    if (this._workspace) {\r\n      if (this._workspace.isDirectory) {\r\n        return [this._workspace];\r\n      }\r\n\r\n      const workspaceData = await this.getWorkspaceDataFromFile();\r\n      if (workspaceData) {\r\n        for (const {path} of workspaceData.folders) {\r\n          const valid = await this.toValidRoot(path);\r\n          if (valid) {\r\n            roots.push(valid);\r\n          } else {\r\n            roots.push(FileStat.dir(path));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return roots;\r\n  }\r\n\r\n  protected async getWorkspaceDataFromFile(): Promise<WorkspaceData | undefined> {\r\n    if (this._workspace && await this.fileService.exists(this._workspace.resource)) {\r\n      if (this._workspace.isDirectory) {\r\n        return {\r\n          folders: [{path: this._workspace.resource.toString()}]\r\n        };\r\n      } else if (this.isWorkspaceFile(this._workspace)) {\r\n        const stat = await this.fileService.read(this._workspace.resource);\r\n        const strippedContent = jsoncparser.stripComments(stat.value);\r\n        const data = jsoncparser.parse(strippedContent);\r\n        if (data && WorkspaceData.is(data)) {\r\n          return WorkspaceData.transformToAbsolute(data, stat);\r\n        }\r\n        // this.logger.error(`Unable to retrieve workspace data from the file: '${this.labelProvider.getLongName(this._workspace)}'. Please check if the file is corrupted.`);\r\n      } else {\r\n        // this.logger.warn(`Not a valid workspace file: ${this.labelProvider.getLongName(this._workspace)}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the URL fragment to the given workspace path.\r\n   */\r\n  protected setURLFragment(workspacePath: string): void {\r\n    window.location.hash = encodeURI(workspacePath);\r\n  }\r\n\r\n  protected async doOpen(uri: URI, options?: WorkspaceInput): Promise<void> {\r\n    const rootUri = uri.toString();\r\n    const stat = await this.toFileStat(rootUri);\r\n    if (stat) {\r\n      if (!stat.isDirectory && !this.isWorkspaceFile(stat)) {\r\n        const message = `Not a valid workspace file: ${uri}`;\r\n        throw new Error(message);\r\n      }\r\n      // The same window has to be preserved too (instead of opening a new one), if the workspace root is not yet available and we are setting it for the first time.\r\n      // Option passed as parameter has the highest priority (for api developers), then the preference, then the default.\r\n      await this.roots;\r\n      const {preserveWindow} = {\r\n        preserveWindow: this.preferences['workspace.preserveWindow'] || !this.opened,\r\n        ...options\r\n      };\r\n      // await this.server.setMostRecentlyUsedWorkspace(rootUri);\r\n      if (preserveWindow) {\r\n        this._workspace = stat;\r\n      }\r\n      console.log(stat);\r\n      console.log(preserveWindow);\r\n      this.openWindow(stat, {preserveWindow});\r\n      return;\r\n    }\r\n    throw new Error('Invalid workspace root URI. Expected an existing directory location.');\r\n  }\r\n\r\n  protected shouldPreserveWindow(options?: WorkspaceInput): boolean {\r\n    return options !== undefined && !!options.preserveWindow;\r\n  }\r\n\r\n  protected reloadWindow(): void {\r\n    // Set the new workspace path as the URL fragment.\r\n    if (this._workspace !== undefined) {\r\n      this.setURLFragment(this._workspace.resource.path.toString());\r\n    } else {\r\n      this.setURLFragment('');\r\n    }\r\n\r\n    window.location.reload();\r\n  }\r\n\r\n  protected openNewWindow(workspacePath: string): void {\r\n    const url = new URL(window.location.href);\r\n    url.hash = encodeURI(workspacePath);\r\n    this.windowService.openNewWindow(url.toString());\r\n  }\r\n\r\n  protected openWindow(uri: FileStat, options?: WorkspaceInput): void {\r\n    const workspacePath = uri.resource.path.toString();\r\n\r\n    if (this.shouldPreserveWindow(options)) {\r\n      this.reloadWindow();\r\n    } else {\r\n      try {\r\n        this.openNewWindow(workspacePath);\r\n      } catch (error) {\r\n        // Fall back to reloading the current window in case the browser has blocked the new window\r\n        this._workspace = uri;\r\n        // this.logger.error(error.toString()).then(() => this.reloadWindow());\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * returns a FileStat if the argument URI points to a file or directory. Otherwise, `undefined`.\r\n   */\r\n  protected async toFileStat(uri: URI | string | undefined): Promise<FileStat | undefined> {\r\n    if (!uri) {\r\n      return undefined;\r\n    }\r\n    let uriStr = uri.toString();\r\n    try {\r\n      if (uriStr.endsWith('/')) {\r\n        uriStr = uriStr.slice(0, -1);\r\n      }\r\n      const normalizedUri = new URI(uriStr).normalizePath();\r\n      return await this.fileService.resolve(normalizedUri);\r\n    } catch (error) {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if the file should be considered as a workspace file.\r\n   *\r\n   * Example: We should not try to read the contents of an .exe file.\r\n   */\r\n  protected isWorkspaceFile(fileStat: FileStat): boolean {\r\n    return fileStat.resource.path.ext === `.${WM_EXT}` || fileStat.resource.path.ext === `.${VSCODE_EXT}`;\r\n  }\r\n}\r\n\r\nexport interface WorkspaceInput {\r\n\r\n  /**\r\n   * Tests whether the same window should be used or a new one has to be opened after setting the workspace root. By default it is `false`.\r\n   */\r\n  preserveWindow?: boolean;\r\n}\r\n\r\nexport interface WorkspaceData {\r\n  folders: Array<{ path: string, name?: string }>;\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  [key: string]: { [id: string]: any };\r\n}\r\n\r\nexport namespace WorkspaceData {\r\n  const validateSchema = new Ajv().compile(workspaceSchema);\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  export function is(data: any): data is WorkspaceData {\r\n    return !!validateSchema(data);\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  export function buildWorkspaceData(folders: string[] | FileStat[], additionalFields?: Partial<WorkspaceData>): WorkspaceData {\r\n    let roots: string[] = [];\r\n    if (folders.length > 0) {\r\n      if (typeof folders[0] !== 'string') {\r\n        roots = (<FileStat[]>folders).map(folder => folder.resource.toString());\r\n      } else {\r\n        roots = <string[]>folders;\r\n      }\r\n    }\r\n    const data: WorkspaceData = {\r\n      folders: roots.map(folder => ({path: folder}))\r\n    };\r\n    if (additionalFields) {\r\n      delete additionalFields.folders;\r\n      Object.assign(data, additionalFields);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  export function transformToRelative(data: WorkspaceData, workspaceFile?: FileStat): WorkspaceData {\r\n    const folderUris: string[] = [];\r\n    const workspaceFileUri = new URI(workspaceFile ? workspaceFile.resource.toString() : '').withScheme('file');\r\n    for (const {path} of data.folders) {\r\n      const folderUri = new URI(path).withScheme('file');\r\n      const rel = workspaceFileUri.parent.relative(folderUri);\r\n      if (rel) {\r\n        folderUris.push(rel.toString());\r\n      } else {\r\n        folderUris.push(folderUri.toString());\r\n      }\r\n    }\r\n    return buildWorkspaceData(folderUris, data);\r\n  }\r\n\r\n  export function transformToAbsolute(data: WorkspaceData, workspaceFile?: BaseStat): WorkspaceData {\r\n    if (workspaceFile) {\r\n      const folders: string[] = [];\r\n      for (const folder of data.folders) {\r\n        const path = folder.path;\r\n        if (path.startsWith('file:///')) {\r\n          folders.push(path);\r\n        } else {\r\n          folders.push(workspaceFile.resource.withScheme('file').parent.resolve(path).toString());\r\n        }\r\n\r\n      }\r\n      return Object.assign(data, buildWorkspaceData(folders, data));\r\n    }\r\n    return data;\r\n  }\r\n}\r\n"]}