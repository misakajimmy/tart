{"version":3,"sources":["browser/label-parser.ts"],"names":[],"mappings":"AAiBA,MAAM,WAAW,SAAS;IACxB,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED,yBAAiB,SAAS,CAAC;IACzB,SAAgB,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,IAAI,SAAS,CAEhD;CACF;AAED,oBAAY,SAAS,GAAG,MAAM,GAAG,SAAS,CAAC;AAE3C,qBACa,WAAW;IAEtB;;;;;;;;;;;;;;OAcG;IACH,KAAK,CAAC,IAAI,EAAE,MAAM,GAAG,SAAS,EAAE;CA2CjC","file":"../../src/browser/label-parser.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\nimport {injectable} from 'inversify';\n\nexport interface LabelIcon {\n  name: string;\n  animation?: string;\n}\n\nexport namespace LabelIcon {\n  export function is(val: object): val is LabelIcon {\n    return 'name' in val;\n  }\n}\n\nexport type LabelPart = string | LabelIcon;\n\n@injectable()\nexport class LabelParser {\n\n  /**\n   * Returns an array with parts of the given text.\n   * These parts are of type LabelPart which can be either a string or a LabelIcon.\n   * For splitting up the giving text the parser follows this rule:\n   * The text gets parsed for the following pattern: $(iconName~iconAnimation).\n   * If the parser finds such pattern a new LabelIcon object\n   * { name: 'iconName', animation: 'iconAnimation'} is added to the returned array.\n   * iconName can be for instance the name of an icon of e.g. FontAwesome and the (optional) iconAnimation\n   * the name of an animation class which must be supported by the particular icon toolkit.\n   *\n   * Every string before, between or after such icon patterns gets also added to the array\n   * before, between or after the related LabelIcon.\n   *\n   * @param text - the label text to parse\n   */\n  parse(text: string): LabelPart[] {\n    const parserArray: LabelPart[] = [];\n    let arrPointer = 0;\n    let potentialIcon = '';\n\n    for (let idx = 0; idx < text.length; idx++) {\n      const char = text.charAt(idx);\n      parserArray[arrPointer] = parserArray[arrPointer] || '';\n      if (potentialIcon === '') {\n        if (char === '$') {\n          potentialIcon += char;\n        } else {\n          parserArray[arrPointer] += char;\n        }\n      } else if (potentialIcon === '$') {\n        if (char === '(') {\n          potentialIcon += char;\n        } else {\n          parserArray[arrPointer] += potentialIcon + char;\n          potentialIcon = '';\n        }\n      } else {\n        if (char === ')') {\n          const iconClassArr = potentialIcon.substring(2, potentialIcon.length).split('~');\n          if (parserArray[arrPointer] !== '') {\n            arrPointer++;\n          }\n          parserArray[arrPointer] = {name: iconClassArr[0], animation: iconClassArr[1]};\n          arrPointer++;\n          potentialIcon = '';\n        } else {\n          potentialIcon += char;\n        }\n      }\n    }\n\n    if (potentialIcon !== '') {\n      parserArray[arrPointer] += potentialIcon;\n    }\n\n    return parserArray;\n  }\n\n}\n"]}