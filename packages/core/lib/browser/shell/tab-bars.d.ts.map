{"version":3,"sources":["browser/shell/tab-bars.ts"],"names":[],"mappings":"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","file":"../../../src/browser/shell/tab-bars.d.ts","sourcesContent":["/**\n * A specialized tab bar for the main and bottom areas.\n */\nimport {TabBar, Title, Widget} from '@lumino/widgets';\nimport PerfectScrollbar from 'perfect-scrollbar';\nimport {Disposable, DisposableCollection} from '../../common';\nimport {Message} from '@lumino/messaging';\nimport {Signal, Slot} from '@lumino/signaling';\nimport {MenuPath} from '../../common/menu';\nimport {ContextMenuRenderer} from '../context-menu-renderer';\nimport {TabBarDecoratorService} from './tab-bar-decorator';\nimport {IconThemeService} from '../icon-theme-service';\nimport {ElementInlineStyle, h, VirtualDOM, VirtualElement} from '@lumino/virtualdom';\nimport {WidgetDecoration} from '../widget-decoration';\nimport {notEmpty} from '../../common/objects';\nimport {BOTTOM_AREA_ID, MAIN_AREA_ID, TartDockPanel} from './tart-dock-panel';\nimport {ArrayExt} from '@lumino/algorithm';\nimport {IDragEvent} from '@lumino/dragdrop';\nimport {ElementExt} from '@lumino/domutils';\n\n/** The class name added to hidden content nodes, which are required to render vertical side bars. */\nconst HIDDEN_CONTENT_CLASS = 'tart-TabBar-hidden-content';\n\nexport const TabBarRendererFactory = Symbol('TabBarRendererFactory');\n\n/**\n * Size information of DOM elements used for rendering tabs in side bars.\n */\nexport interface SizeData {\n  width: number;\n  height: number;\n}\n\n/**\n * Extension of the rendering data used for tabs in side bars of the application shell.\n */\nexport interface SideBarRenderData extends TabBar.IRenderData<Widget> {\n  labelSize?: SizeData;\n  iconSize?: SizeData;\n  paddingTop?: number;\n  paddingBottom?: number;\n}\n\n/**\n * A tab bar renderer that offers a context menu. In addition, this renderer is able to\n * set an explicit position and size on the icon and label of each tab in a side bar.\n * This is necessary because the elements of side bar tabs are rotated using the CSS\n * `transform` property, disrupting the browser's ability to arrange those elements\n * automatically.\n */\nexport class TabBarRenderer extends TabBar.Renderer {\n\n  /**\n   * The menu path used to render the context menu.\n   */\n  contextMenuPath?: MenuPath;\n\n  protected readonly toDispose = new DisposableCollection();\n\n  // TODO refactor shell, rendered should only receive props with event handlers\n  // events should be handled by clients, like ApplicationShell\n  protected readonly toDisposeOnTabBar = new DisposableCollection();\n  protected readonly decorations = new Map<Title<Widget>, WidgetDecoration.Data[]>();\n\n  // right now it is mess: (1) client logic belong to renderer, (2) cyclic dependencies between renderers and clients\n  constructor(\n      protected readonly contextMenuRenderer?: ContextMenuRenderer,\n      protected readonly decoratorService?: TabBarDecoratorService,\n      protected readonly iconThemeService?: IconThemeService\n  ) {\n    super();\n    if (this.decoratorService) {\n      this.toDispose.push(Disposable.create(() => this.resetDecorations()));\n      this.toDispose.push(this.decoratorService.onDidChangeDecorations(() => this.resetDecorations()));\n    }\n    if (this.iconThemeService) {\n      this.toDispose.push(this.iconThemeService.onDidChangeCurrent(() => {\n        if (this._tabBar) {\n          this._tabBar.update();\n        }\n      }));\n    }\n  }\n\n  protected _tabBar?: TabBar<Widget>;\n\n  get tabBar(): TabBar<Widget> | undefined {\n    return this._tabBar;\n  }\n\n  /**\n   * A reference to the tab bar is required in order to activate it when a context menu\n   * is requested.\n   */\n  set tabBar(tabBar: TabBar<Widget> | undefined) {\n    if (this.toDispose.disposed) {\n      throw new Error('disposed');\n    }\n    if (this._tabBar === tabBar) {\n      return;\n    }\n    this.toDisposeOnTabBar.dispose();\n    this.toDispose.push(this.toDisposeOnTabBar);\n    this._tabBar = tabBar;\n    if (tabBar) {\n      const listener: Slot<Widget, TabBar.ITabCloseRequestedArgs<Widget>> = (_, {title}) => this.resetDecorations(title);\n      tabBar.tabCloseRequested.connect(listener);\n      this.toDisposeOnTabBar.push(Disposable.create(() => tabBar.tabCloseRequested.disconnect(listener)));\n    }\n    this.resetDecorations();\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  /**\n   * Render tabs with the default DOM structure, but additionally register a context menu listener.\n   * @param {SideBarRenderData} data Data used to render the tab.\n   * @param {boolean} isInSidePanel An optional check which determines if the tab is in the side-panel.\n   * @returns {VirtualElement} The virtual element of the rendered tab.\n   */\n  renderTab(data: SideBarRenderData, isInSidePanel?: boolean): VirtualElement {\n    const title = data.title;\n    const id = this.createTabId(data.title);\n    const key = this.createTabKey(data);\n    const style = this.createTabStyle(data);\n    const className = this.createTabClass(data);\n    const dataset = this.createTabDataset(data);\n    return h.li(\n        {\n          key, className, id, title: title.caption, style, dataset,\n          oncontextmenu: this.handleContextMenuEvent,\n          ondblclick: this.handleDblClickEvent,\n          onauxclick: (e: MouseEvent) => {\n            // If user closes the tab using mouse wheel, nothing should be pasted to an active editor\n            e.preventDefault();\n          }\n        },\n        h.div(\n            {className: 'tart-tab-icon-label'},\n            this.renderIcon(data, isInSidePanel),\n            this.renderLabel(data, isInSidePanel),\n            this.renderBadge(data, isInSidePanel)\n        ),\n        this.renderCloseIcon(data)\n    );\n  }\n\n  createTabId(title: Title<Widget>): string {\n    return 'shell-tab-' + title.owner.id;\n  }\n\n  /**\n   * If size information is available for the label and icon, set an explicit height on the tab.\n   * The height value also considers padding, which should be derived from CSS settings.\n   */\n  createTabStyle(data: SideBarRenderData): ElementInlineStyle {\n    const zIndex = `${data.zIndex}`;\n    const labelSize = data.labelSize;\n    const iconSize = data.iconSize;\n    let height: string | undefined;\n    if (labelSize || iconSize) {\n      const labelHeight = labelSize ? (this.tabBar && this.tabBar.orientation === 'horizontal' ? labelSize.height : labelSize.width) : 0;\n      const iconHeight = iconSize ? iconSize.height : 0;\n      let paddingTop = data.paddingTop || 0;\n      if (labelHeight > 0 && iconHeight > 0) {\n        // Leave some extra space between icon and label\n        paddingTop = paddingTop * 1.5;\n      }\n      const paddingBottom = data.paddingBottom || 0;\n      height = `${labelHeight + iconHeight + paddingTop + paddingBottom}px`;\n    }\n    return {zIndex, height};\n  }\n\n  /**\n   * If size information is available for the label, set it as inline style.\n   * Tab padding and icon size are also considered in the `top` position.\n   * @param {SideBarRenderData} data Data used to render the tab.\n   * @param {boolean} isInSidePanel An optional check which determines if the tab is in the side-panel.\n   * @returns {VirtualElement} The virtual element of the rendered label.\n   */\n  renderLabel(data: SideBarRenderData, isInSidePanel?: boolean): VirtualElement {\n    const labelSize = data.labelSize;\n    const iconSize = data.iconSize;\n    let width: string | undefined;\n    let height: string | undefined;\n    let top: string | undefined;\n    if (labelSize) {\n      width = `${labelSize.width}px`;\n      height = `${labelSize.height}px`;\n    }\n    if (data.paddingTop || iconSize) {\n      const iconHeight = iconSize ? iconSize.height : 0;\n      let paddingTop = data.paddingTop || 0;\n      if (iconHeight > 0) {\n        // Leave some extra space between icon and label\n        paddingTop = paddingTop * 1.5;\n      }\n      top = `${paddingTop + iconHeight}px`;\n    }\n    const style: ElementInlineStyle = {width, height, top};\n    // No need to check for duplicate labels if the tab is rendered in the side panel (title is not displayed),\n    // or if there are less than two files in the tab bar.\n    if (isInSidePanel || (this.tabBar && this.tabBar.titles.length < 2)) {\n      return h.div({className: 'p-TabBar-tabLabel', style}, data.title.label);\n    }\n    const originalToDisplayedMap = this.findDuplicateLabels([...this.tabBar!.titles]);\n    const labelDetails: string | undefined = originalToDisplayedMap.get(data.title.caption);\n    if (labelDetails) {\n      return h.div({className: 'p-TabBar-tabLabelWrapper'},\n          h.div({className: 'p-TabBar-tabLabel', style}, data.title.label),\n          h.div({className: 'p-TabBar-tabLabelDetails', style}, labelDetails));\n    }\n    return h.div({className: 'p-TabBar-tabLabel', style}, data.title.label);\n  }\n\n  renderBadge(data: SideBarRenderData, isInSidePanel?: boolean): VirtualElement {\n    const totalBadge = this.getDecorationData(data.title, 'badge').reduce((sum, badge) => sum! + badge!, 0);\n    if (!totalBadge) {\n      return h.div({});\n    }\n    const limitedBadge = totalBadge >= 100 ? '99+' : totalBadge;\n    return isInSidePanel\n        ? h.div({className: 'tart-badge-decorator-sidebar'}, `${limitedBadge}`)\n        : h.div({className: 'tart-badge-decorator-horizontal'}, `${limitedBadge}`);\n  }\n\n  /**\n   * Find duplicate labels from the currently opened tabs in the tab bar.\n   * Return the appropriate partial paths that can distinguish the identical labels.\n   *\n   * E.g., a/p/index.ts => a/..., b/p/index.ts => b/...\n   *\n   * To prevent excessively long path displayed, show at maximum three levels from the end by default.\n   * @param {Title<Widget>[]} titles Array of titles in the current tab bar.\n   * @returns {Map<string, string>} A map from each tab's original path to its displayed partial path.\n   */\n  findDuplicateLabels(titles: Title<Widget>[]): Map<string, string> {\n    // Filter from all tabs to group them by the distinct label (file name).\n    // E.g., 'foo.js' => {0 (index) => 'a/b/foo.js', '2 => a/c/foo.js' },\n    //       'bar.js' => {1 => 'a/d/bar.js', ...}\n    const labelGroups = new Map<string, Map<number, string>>();\n    titles.forEach((title, index) => {\n      if (!labelGroups.has(title.label)) {\n        labelGroups.set(title.label, new Map<number, string>());\n      }\n      labelGroups.get(title.label)!.set(index, title.caption);\n    });\n\n    const originalToDisplayedMap = new Map<string, string>();\n    // Parse each group of editors with the same label.\n    labelGroups.forEach(labelGroup => {\n      // Filter to get groups that have duplicates.\n      if (labelGroup.size > 1) {\n        const paths: string[][] = [];\n        let maxPathLength = 0;\n        labelGroup.forEach((pathStr, index) => {\n          const steps = pathStr.split('/');\n          maxPathLength = Math.max(maxPathLength, steps.length);\n          paths[index] = (steps.slice(0, steps.length - 1));\n          // By default, show at maximum three levels from the end.\n          let defaultDisplayedPath = steps.slice(-4, -1).join('/');\n          if (steps.length > 4) {\n            defaultDisplayedPath = '.../' + defaultDisplayedPath;\n          }\n          originalToDisplayedMap.set(pathStr, defaultDisplayedPath);\n        });\n\n        // Iterate through the steps of the path from the left to find the step that can distinguish it.\n        // E.g., ['root', 'foo', 'c'], ['root', 'bar', 'd'] => 'foo', 'bar'\n        let i = 0;\n        while (i < maxPathLength - 1) {\n          // Store indexes of all paths that have the identical element in each step.\n          const stepOccurrences = new Map<string, number[]>();\n          // Compare the current step of all paths\n          paths.forEach((path, index) => {\n            const step = path[i];\n            if (path.length > 0) {\n              if (i > path.length - 1) {\n                paths[index] = [];\n              } else if (!stepOccurrences.has(step)) {\n                stepOccurrences.set(step, [index]);\n              } else {\n                stepOccurrences.get(step)!.push(index);\n              }\n            }\n          });\n          // Set the displayed path for each tab.\n          stepOccurrences.forEach((indexArr, displayedPath) => {\n            if (indexArr.length === 1) {\n              const originalPath = labelGroup.get(indexArr[0]);\n              if (originalPath) {\n                const originalElements = originalPath.split('/');\n                const displayedElements = displayedPath.split('/');\n                if (originalElements.slice(-2)[0] !== displayedElements.slice(-1)[0]) {\n                  displayedPath += '/...';\n                }\n                if (originalElements[0] !== displayedElements[0]) {\n                  displayedPath = '.../' + displayedPath;\n                }\n                originalToDisplayedMap.set(originalPath, displayedPath);\n                paths[indexArr[0]] = [];\n              }\n            }\n          });\n          i++;\n        }\n      }\n    });\n    return originalToDisplayedMap;\n  }\n\n  /**\n   * If size information is available for the icon, set it as inline style. Tab padding\n   * is also considered in the `top` position.\n   * @param {SideBarRenderData} data Data used to render the tab icon.\n   * @param {boolean} isInSidePanel An optional check which determines if the tab is in the side-panel.\n   */\n  renderIcon(data: SideBarRenderData, isInSidePanel?: boolean): VirtualElement {\n    if (!isInSidePanel && this.iconThemeService && this.iconThemeService.current === 'none') {\n      return h.div();\n    }\n    let top: string | undefined;\n    if (data.paddingTop) {\n      top = `${data.paddingTop || 0}px`;\n    }\n    const style: ElementInlineStyle = {top};\n    const baseClassName = this.createIconClass(data);\n\n    const overlayIcons: VirtualElement[] = [];\n    const decorationData = this.getDecorationData(data.title, 'iconOverlay');\n\n    // Check if the tab has decoration markers to be rendered on top.\n    if (decorationData.length > 0) {\n      const baseIcon: VirtualElement = h.div({className: baseClassName, style}, data.title.iconLabel);\n      const wrapperClassName: string = WidgetDecoration.Styles.ICON_WRAPPER_CLASS;\n      const decoratorSizeClassName: string = isInSidePanel ? WidgetDecoration.Styles.DECORATOR_SIDEBAR_SIZE_CLASS : WidgetDecoration.Styles.DECORATOR_SIZE_CLASS;\n\n      decorationData\n          .filter(notEmpty)\n          .map(overlay => [overlay.position, overlay] as [WidgetDecoration.IconOverlayPosition, WidgetDecoration.IconOverlay | WidgetDecoration.IconClassOverlay])\n          .forEach(([position, overlay]) => {\n            const iconAdditionalClasses: string[] = [decoratorSizeClassName, WidgetDecoration.IconOverlayPosition.getStyle(position, isInSidePanel)];\n            const overlayIconStyle = (color?: string) => {\n              if (color === undefined) {\n                return {};\n              }\n              return {color};\n            };\n            // Parse the optional background (if it exists) of the overlay icon.\n            if (overlay.background) {\n              const backgroundIconClassName = this.getIconClass(overlay.background.shape, iconAdditionalClasses);\n              overlayIcons.push(\n                  h.div({\n                    key: data.title.label + '-background',\n                    className: backgroundIconClassName,\n                    style: overlayIconStyle(overlay.background.color)\n                  })\n              );\n            }\n            // Parse the overlay icon.\n            const overlayIcon = (overlay as WidgetDecoration.IconOverlay).icon || (overlay as WidgetDecoration.IconClassOverlay).iconClass;\n            const overlayIconClassName = this.getIconClass(overlayIcon, iconAdditionalClasses);\n            overlayIcons.push(\n                h.span({\n                  key: data.title.label,\n                  className: overlayIconClassName,\n                  style: overlayIconStyle(overlay.color)\n                })\n            );\n          });\n      return h.div({className: wrapperClassName, style}, [baseIcon, ...overlayIcons]);\n    }\n    return h.div({className: baseClassName, style}, data.title.iconLabel);\n  }\n\n  protected resetDecorations(title?: Title<Widget>): void {\n    if (title) {\n      this.decorations.delete(title);\n    } else {\n      this.decorations.clear();\n    }\n    if (this.tabBar) {\n      this.tabBar.update();\n    }\n  }\n\n  /**\n   * Get all available decorations of a given tab.\n   * @param {string} title The widget title.\n   */\n  protected getDecorations(title: Title<Widget>): WidgetDecoration.Data[] {\n    if (this.tabBar && this.decoratorService) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const owner: { resetTabBarDecorations?: () => void; } & Widget = title.owner;\n      if (!owner.resetTabBarDecorations) {\n        owner.resetTabBarDecorations = () => this.decorations.delete(title);\n        title.owner.disposed.connect(owner.resetTabBarDecorations);\n      }\n\n      const decorations = this.decorations.get(title) || this.decoratorService.getDecorations(title);\n      this.decorations.set(title, decorations);\n      return decorations;\n    }\n    return [];\n  }\n\n  /**\n   * Get the decoration data given the tab URI and the decoration data type.\n   * @param {string} title The title.\n   * @param {K} key The type of the decoration data.\n   */\n  protected getDecorationData<K extends keyof WidgetDecoration.Data>(title: Title<Widget>, key: K): WidgetDecoration.Data[K][] {\n    return this.getDecorations(title).filter(data => data[key] !== undefined).map(data => data[key]);\n  }\n\n  protected handleContextMenuEvent = (event: MouseEvent) => {\n    if (this.contextMenuRenderer && this.contextMenuPath && event.currentTarget instanceof HTMLElement) {\n      event.stopPropagation();\n      event.preventDefault();\n      this.contextMenuRenderer.render(this.contextMenuPath, event);\n    }\n  };\n\n  protected handleDblClickEvent = (event: MouseEvent) => {\n    if (this.tabBar && event.currentTarget instanceof HTMLElement) {\n      const id = event.currentTarget.id;\n      // eslint-disable-next-line no-null/no-null\n      const title = this.tabBar.titles.find(t => this.createTabId(t) === id) || null;\n      const area = title && title.owner.parent;\n      if (area instanceof TartDockPanel && (area.id === BOTTOM_AREA_ID || area.id === MAIN_AREA_ID)) {\n        area.toggleMaximized();\n      }\n    }\n  };\n\n  /**\n   * Get the class of an icon.\n   * @param {string | string[]} iconName The name of the icon.\n   * @param {string[]} additionalClasses Additional classes of the icon.\n   */\n  private getIconClass(iconName: string | string[], additionalClasses: string[] = []): string {\n    const iconClass = (typeof iconName === 'string') ? ['a', 'fa', `fa-${iconName}`] : ['a'].concat(iconName);\n    return iconClass.concat(additionalClasses).join(' ');\n  }\n\n}\n\nexport class ScrollableTabBar extends TabBar<Widget> {\n\n  protected scrollBar?: PerfectScrollbar;\n  protected readonly toDispose = new DisposableCollection();\n  private scrollBarFactory: () => PerfectScrollbar;\n  private pendingReveal?: Promise<void>;\n\n  constructor(options?: TabBar.IOptions<Widget> & PerfectScrollbar.Options) {\n    super(options);\n    this.scrollBarFactory = () => new PerfectScrollbar(this.scrollbarHost, options);\n  }\n\n  protected get scrollbarHost(): HTMLElement {\n    return this.node;\n  }\n\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    super.dispose();\n    this.toDispose.dispose();\n  }\n\n  /**\n   * Reveal the tab with the given index by moving the scroll bar if necessary.\n   */\n  revealTab(index: number): Promise<void> {\n    if (this.pendingReveal) {\n      // A reveal has already been scheduled\n      return this.pendingReveal;\n    }\n    const result = new Promise<void>((resolve, reject) => {\n      // The tab might not have been created yet, so wait until the next frame\n      window.requestAnimationFrame(() => {\n        const tab = this.contentNode.children[index] as HTMLElement;\n        if (tab && this.isVisible) {\n          const parent = this.scrollbarHost;\n          if (this.orientation === 'horizontal') {\n            const scroll = parent.scrollLeft;\n            const left = tab.offsetLeft;\n            if (scroll > left) {\n              parent.scrollLeft = left;\n            } else {\n              const right = left + tab.clientWidth - parent.clientWidth;\n              if (scroll < right && tab.clientWidth < parent.clientWidth) {\n                parent.scrollLeft = right;\n              }\n            }\n          } else {\n            const scroll = parent.scrollTop;\n            const top = tab.offsetTop;\n            if (scroll > top) {\n              parent.scrollTop = top;\n            } else {\n              const bottom = top + tab.clientHeight - parent.clientHeight;\n              if (scroll < bottom && tab.clientHeight < parent.clientHeight) {\n                parent.scrollTop = bottom;\n              }\n            }\n          }\n        }\n        if (this.pendingReveal === result) {\n          this.pendingReveal = undefined;\n        }\n        resolve();\n      });\n    });\n    this.pendingReveal = result;\n    return result;\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    if (!this.scrollBar) {\n      this.scrollBar = this.scrollBarFactory();\n    }\n    super.onAfterAttach(msg);\n  }\n\n  protected onBeforeDetach(msg: Message): void {\n    super.onBeforeDetach(msg);\n    if (this.scrollBar) {\n      this.scrollBar.destroy();\n      this.scrollBar = undefined;\n    }\n  }\n\n  protected onUpdateRequest(msg: Message): void {\n    super.onUpdateRequest(msg);\n    if (this.scrollBar) {\n      this.scrollBar.update();\n    }\n  }\n\n  protected onResize(msg: Widget.ResizeMessage): void {\n    super.onResize(msg);\n    if (this.scrollBar) {\n      if (this.currentIndex >= 0) {\n        this.revealTab(this.currentIndex);\n      }\n      this.scrollBar.update();\n    }\n  }\n\n}\n\n/**\n * A specialized tab bar for side areas.\n */\nexport class SideTabBar extends ScrollableTabBar {\n\n  private static readonly DRAG_THRESHOLD = 5;\n\n  /**\n   * Emitted when a tab is added to the tab bar.\n   */\n  readonly tabAdded = new Signal<this, { title: Title<Widget> }>(this);\n  /**\n   * Side panels can be collapsed by clicking on the currently selected tab. This signal is\n   * emitted when the mouse is released on the selected tab without initiating a drag.\n   */\n  readonly collapseRequested = new Signal<this, Title<Widget>>(this);\n  toCancelViewContainerDND = new DisposableCollection();\n  private mouseData?: {\n    pressX: number,\n    pressY: number,\n    mouseDownTabIndex: number\n  };\n\n  constructor(options?: TabBar.IOptions<Widget> & PerfectScrollbar.Options) {\n    super(options);\n\n    // Create the hidden content node (see `hiddenContentNode` for explanation)\n    const hiddenContent = document.createElement('ul');\n    hiddenContent.className = HIDDEN_CONTENT_CLASS;\n    this.node.appendChild(hiddenContent);\n  }\n\n  /**\n   * Tab bars of the left and right side panel are arranged vertically by rotating their labels.\n   * Rotation is realized with the CSS `transform` property, which disrupts the browser's ability\n   * to arrange the involved elements automatically. Therefore the elements are arranged explicitly\n   * by the TabBarRenderer using inline `height` and `top` styles. However, the size of labels\n   * must still be computed by the browser, so the rendering is performed in two steps: first the\n   * tab bar is rendered horizontally inside a _hidden content node_, then it is rendered again\n   * vertically inside the proper content node. After the first step, size information is gathered\n   * from all labels so it can be applied during the second step.\n   */\n  get hiddenContentNode(): HTMLUListElement {\n    return this.node.getElementsByClassName(HIDDEN_CONTENT_CLASS)[0] as HTMLUListElement;\n  }\n\n  insertTab(index: number, value: Title<Widget> | Title.IOptions<Widget>): Title<Widget> {\n    const result = super.insertTab(index, value);\n    this.tabAdded.emit({title: result});\n    return result;\n  }\n\n  /**\n   * The following event processing is used to generate `collapseRequested` signals\n   * when the mouse goes up on the currently selected tab without too much movement\n   * between `mousedown` and `mouseup`. The movement threshold is the same that\n   * is used by the superclass to detect a drag event. The `allowDeselect` option\n   * of the TabBar constructor cannot be used here because it is triggered when the\n   * mouse goes down, and thus collides with dragging.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'pointerdown':\n        this.onMouseDown(event as MouseEvent);\n        super.handleEvent(event);\n        break;\n      case 'pointerup':\n        super.handleEvent(event);\n        this.onMouseUp(event as MouseEvent);\n        break;\n      case 'pointermove':\n        this.onMouseMove(event as MouseEvent);\n        super.handleEvent(event);\n        break;\n      case 'p-dragenter':\n        this.onDragEnter(event as IDragEvent);\n        break;\n      case 'p-dragover':\n        this.onDragOver(event as IDragEvent);\n        break;\n      case 'p-dragleave':\n      case 'p-drop':\n        this.cancelViewContainerDND();\n        break;\n      default:\n        super.handleEvent(event);\n    }\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    super.onAfterAttach(msg);\n    this.renderTabBar();\n    this.node.addEventListener('p-dragenter', this);\n    this.node.addEventListener('p-dragover', this);\n    this.node.addEventListener('p-dragleave', this);\n    document.addEventListener('p-drop', this);\n  }\n\n  protected onAfterDetach(msg: Message): void {\n    super.onAfterDetach(msg);\n    this.node.removeEventListener('p-dragenter', this);\n    this.node.removeEventListener('p-dragover', this);\n    this.node.removeEventListener('p-dragleave', this);\n    document.removeEventListener('p-drop', this);\n  }\n\n  protected onUpdateRequest(msg: Message): void {\n    this.renderTabBar();\n    if (this.scrollBar) {\n      this.scrollBar.update();\n    }\n  }\n\n  /**\n   * Render the tab bar in the _hidden content node_ (see `hiddenContentNode` for explanation),\n   * then gather size information for labels and render it again in the proper content node.\n   */\n  protected renderTabBar(): void {\n    if (this.isAttached) {\n      // Render into the invisible node\n      this.renderTabs(this.hiddenContentNode);\n      // Await a rendering frame\n      window.requestAnimationFrame(() => {\n        const hiddenContent = this.hiddenContentNode;\n        const n = hiddenContent.children.length;\n        const renderData = new Array<Partial<SideBarRenderData>>(n);\n        for (let i = 0; i < n; i++) {\n          const hiddenTab = hiddenContent.children[i];\n          // Extract tab padding from the computed style\n          const tabStyle = window.getComputedStyle(hiddenTab);\n          const rd: Partial<SideBarRenderData> = {\n            paddingTop: parseFloat(tabStyle.paddingTop!),\n            paddingBottom: parseFloat(tabStyle.paddingBottom!)\n          };\n          // Extract label size from the DOM\n          const labelElements = hiddenTab.getElementsByClassName('p-TabBar-tabLabel');\n          if (labelElements.length === 1) {\n            const label = labelElements[0];\n            rd.labelSize = {width: label.clientWidth, height: label.clientHeight};\n          }\n          // Extract icon size from the DOM\n          const iconElements = hiddenTab.getElementsByClassName('p-TabBar-tabIcon');\n          if (iconElements.length === 1) {\n            const icon = iconElements[0];\n            rd.iconSize = {width: icon.clientWidth, height: icon.clientHeight};\n          }\n          renderData[i] = rd;\n        }\n        // Render into the visible node\n        this.renderTabs(this.contentNode, renderData);\n      });\n    }\n  }\n\n  /**\n   * Render the tab bar using the given DOM element as host. The optional `renderData` is forwarded\n   * to the TabBarRenderer.\n   */\n  protected renderTabs(host: HTMLElement, renderData?: Partial<SideBarRenderData>[]): void {\n    const titles = this.titles;\n    const n = titles.length;\n    const renderer = this.renderer as TabBarRenderer;\n    const currentTitle = this.currentTitle;\n    const content = new Array<VirtualElement>(n);\n    for (let i = 0; i < n; i++) {\n      const title = titles[i];\n      const current = title === currentTitle;\n      const zIndex = current ? n : n - i - 1;\n      let rd: SideBarRenderData;\n      if (renderData && i < renderData.length) {\n        rd = {title, current, zIndex, ...renderData[i]};\n      } else {\n        rd = {title, current, zIndex};\n      }\n      content[i] = renderer.renderTab(rd, true);\n    }\n    VirtualDOM.render(content, host);\n  }\n\n  protected cancelViewContainerDND = () => {\n    this.toCancelViewContainerDND.dispose();\n  };\n\n  /**\n   * Handles `viewContainerPart` drag enter.\n   */\n  protected onDragEnter = (event: IDragEvent) => {\n    this.cancelViewContainerDND();\n    if (event.mimeData.getData('application/vnd.phosphor.view-container-factory')) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  /**\n   * Handle `viewContainerPart` drag over,\n   * Defines the appropriate `drpAction` and opens the tab on which the mouse stands on for more than 800 ms.\n   */\n  protected onDragOver = (event: IDragEvent) => {\n    const factory = event.mimeData.getData('application/vnd.phosphor.view-container-factory');\n    const widget = factory && factory();\n    if (!widget) {\n      event.dropAction = 'none';\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    if (!this.toCancelViewContainerDND.disposed) {\n      event.dropAction = event.proposedAction;\n      return;\n    }\n\n    const {target, clientX, clientY} = event;\n    if (target instanceof HTMLElement) {\n      if (widget.options.disableDraggingToOtherContainers || widget.viewContainer.disableDNDBetweenContainers) {\n        event.dropAction = 'none';\n        target.classList.add('tart-cursor-no-drop');\n        this.toCancelViewContainerDND.push(Disposable.create(() => {\n          target.classList.remove('tart-cursor-no-drop');\n        }));\n      } else {\n        event.dropAction = event.proposedAction;\n      }\n      const {top, bottom, left, right, height} = target.getBoundingClientRect();\n      const mouseOnTop = (clientY - top) < (height / 2);\n      const dropTargetClass = `drop-target-${mouseOnTop ? 'top' : 'bottom'}`;\n      const tabs = this.contentNode.children;\n      const targetTab = ArrayExt.findFirstValue(tabs, t => ElementExt.hitTest(t, clientX, clientY));\n      if (!targetTab) {\n        return;\n      }\n      targetTab.classList.add(dropTargetClass);\n      this.toCancelViewContainerDND.push(Disposable.create(() => {\n        if (targetTab) {\n          targetTab.classList.remove(dropTargetClass);\n        }\n      }));\n      const openTabTimer = setTimeout(() => {\n        const title = this.titles.find(t => (this.renderer as TabBarRenderer).createTabId(t) === targetTab.id);\n        if (title) {\n          const mouseStillOnTab = clientX >= left && clientX <= right && clientY >= top && clientY <= bottom;\n          if (mouseStillOnTab) {\n            this.currentTitle = title;\n          }\n        }\n      }, 800);\n      this.toCancelViewContainerDND.push(Disposable.create(() => {\n        clearTimeout(openTabTimer);\n      }));\n    }\n  };\n\n  private onMouseDown(event: MouseEvent): void {\n    // Check for left mouse button and current mouse status\n    if (event.button !== 0 || this.mouseData) {\n      return;\n    }\n\n    // Check whether the mouse went down on the current tab\n    const tabs = this.contentNode.children;\n    const index = ArrayExt.findFirstIndex(tabs, tab => ElementExt.hitTest(tab, event.clientX, event.clientY));\n    if (index < 0 || index !== this.currentIndex) {\n      return;\n    }\n\n    // Check whether the close button was clicked\n    const icon = tabs[index].querySelector(this.renderer.closeIconSelector);\n    if (icon && icon.contains(event.target as HTMLElement)) {\n      return;\n    }\n\n    this.mouseData = {\n      pressX: event.clientX,\n      pressY: event.clientY,\n      mouseDownTabIndex: index\n    };\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    // Check for left mouse button and current mouse status\n    if (event.button !== 0 || !this.mouseData) {\n      return;\n    }\n\n    // Check whether the mouse went up on the current tab\n    const mouseDownTabIndex = this.mouseData.mouseDownTabIndex;\n    this.mouseData = undefined;\n    const tabs = this.contentNode.children;\n    const index = ArrayExt.findFirstIndex(tabs, tab => ElementExt.hitTest(tab, event.clientX, event.clientY));\n    if (index < 0 || index !== mouseDownTabIndex) {\n      return;\n    }\n\n    // Collapse the side bar\n    this.collapseRequested.emit(this.titles[index]);\n  }\n\n  private onMouseMove(event: MouseEvent): void {\n    // Check for left mouse button and current mouse status\n    if (event.button !== 0 || !this.mouseData) {\n      return;\n    }\n\n    const data = this.mouseData;\n    const dx = Math.abs(event.clientX - data.pressX);\n    const dy = Math.abs(event.clientY - data.pressY);\n    const threshold = SideTabBar.DRAG_THRESHOLD;\n    if (dx >= threshold || dy >= threshold) {\n      this.mouseData = undefined;\n    }\n  }\n\n}\n\n\n/**\n * Specialized scrollable tab-bar which comes with toolbar support.\n * Instead of the following DOM structure.\n *\n * +-------------------------+\n * |[TAB_0][TAB_1][TAB_2][TAB|\n * +-------------Scrollable--+\n *\n * There is a dedicated HTML element for toolbar which does **not** contained in the scrollable element.\n *\n * +-------------------------+-----------------+\n * |[TAB_0][TAB_1][TAB_2][TAB|         Toolbar |\n * +-------------Scrollable--+-Non-Scrollable-+\n *\n */\n// export class ToolbarAwareTabBar extends ScrollableTabBar {\n//\n//     protected contentContainer: HTMLElement;\n//     protected toolbar: TabBarToolbar | undefined;\n//     protected breadcrumbsContainer: HTMLElement;\n//     // protected readonly breadcrumbsRenderer: BreadcrumbsRenderer;\n//     protected topRow: HTMLElement;\n//\n//     constructor(\n//         protected readonly tabBarToolbarRegistry: TabBarToolbarRegistry,\n//         protected readonly tabBarToolbarFactory: () => TabBarToolbar,\n//         protected readonly breadcrumbsRendererFactory: BreadcrumbsRendererFactory,\n//         protected readonly options?: TabBar.IOptions<Widget> & PerfectScrollbar.Options,\n//     ) {\n//         super(options);\n//         this.breadcrumbsRenderer = this.breadcrumbsRendererFactory();\n//         this.rewireDOM();\n//         this.toDispose.push(this.tabBarToolbarRegistry.onDidChange(() => this.update()));\n//         this.toDispose.push(this.breadcrumbsRenderer);\n//         this.toDispose.push(this.breadcrumbsRenderer.onDidChangeActiveState(active => {\n//             this.node.classList.toggle('tart-tabBar-multirow', active);\n//             if (this.parent) {\n//                 MessageLoop.sendMessage(this.parent, new Message('fit-request'));\n//             }\n//         }));\n//         this.node.classList.toggle('tart-tabBar-multirow', this.breadcrumbsRenderer.active);\n//         const handler = () => this.updateBreadcrumbs();\n//         this.currentChanged.connect(handler);\n//         this.toDispose.push(Disposable.create(() => this.currentChanged.disconnect(handler)));\n//     }\n//\n//     /**\n//      * Overrides the `contentNode` property getter in PhosphorJS' TabBar.\n//      */\n//     get contentNode(): HTMLUListElement {\n//         return this.tabBarContainer.getElementsByClassName(ToolbarAwareTabBar.Styles.TAB_BAR_CONTENT)[0] as HTMLUListElement;\n//     }\n//\n//     /**\n//      * Overrides the scrollable host from the parent class.\n//      */\n//     protected get scrollbarHost(): HTMLElement {\n//         return this.tabBarContainer;\n//     }\n//\n//     protected get tabBarContainer(): HTMLElement {\n//         return this.node.getElementsByClassName(ToolbarAwareTabBar.Styles.TAB_BAR_CONTENT_CONTAINER)[0] as HTMLElement;\n//     }\n//\n//     protected async updateBreadcrumbs(): Promise<void> {\n//         const current = this.currentTitle?.owner;\n//         const uri = NavigatableWidget.is(current) ? current.getResourceUri() : undefined;\n//         await this.breadcrumbsRenderer.refresh(uri);\n//     }\n//\n//     protected onAfterAttach(msg: Message): void {\n//         if (this.toolbar) {\n//             if (this.toolbar.isAttached) {\n//                 Widget.detach(this.toolbar);\n//             }\n//             Widget.attach(this.toolbar, this.topRow);\n//             if (this.breadcrumbsContainer) {\n//                 this.node.appendChild(this.breadcrumbsContainer);\n//             }\n//             this.breadcrumbsRenderer?.refresh();\n//         }\n//         super.onAfterAttach(msg);\n//     }\n//\n//     protected onBeforeDetach(msg: Message): void {\n//         if (this.toolbar && this.toolbar.isAttached) {\n//             Widget.detach(this.toolbar);\n//         }\n//         super.onBeforeDetach(msg);\n//     }\n//\n//     protected onUpdateRequest(msg: Message): void {\n//         super.onUpdateRequest(msg);\n//         this.updateToolbar();\n//     }\n//\n//     protected updateToolbar(): void {\n//         if (!this.toolbar) {\n//             return;\n//         }\n//         const widget = this.currentTitle?.owner ?? undefined;\n//         this.toolbar.updateTarget(widget);\n//     }\n//\n//     handleEvent(event: Event): void {\n//         if (this.toolbar && event instanceof MouseEvent && this.toolbar.shouldHandleMouseEvent(event)) {\n//             // if the mouse event is over the toolbar part don't handle it.\n//             return;\n//         }\n//         super.handleEvent(event);\n//     }\n//\n//     /**\n//      * Restructures the DOM defined in PhosphorJS.\n//      *\n//      * By default the tabs (`li`) are contained in the `this.contentNode` (`ul`) which is wrapped in a `div` (`this.node`).\n//      * Instead of this structure, we add a container for the `this.contentNode` and for the toolbar.\n//      * The scrollbar will only work for the `ul` part but it does not affect the toolbar, so it can be on the right hand-side.\n//      */\n//     protected rewireDOM(): void {\n//         const contentNode = this.node.getElementsByClassName(ToolbarAwareTabBar.Styles.TAB_BAR_CONTENT)[0];\n//         if (!contentNode) {\n//             throw new Error(\"'this.node' does not have the content as a direct child with class name 'p-TabBar-content'.\");\n//         }\n//         this.node.removeChild(contentNode);\n//         this.topRow = document.createElement('div');\n//         this.topRow.classList.add('tart-tabBar-tab-row');\n//         this.contentContainer = document.createElement('div');\n//         this.contentContainer.classList.add(ToolbarAwareTabBar.Styles.TAB_BAR_CONTENT_CONTAINER);\n//         this.contentContainer.appendChild(contentNode);\n//         this.topRow.appendChild(this.contentContainer);\n//         this.node.appendChild(this.topRow);\n//         this.toolbar = this.tabBarToolbarFactory();\n//         this.breadcrumbsContainer = document.createElement('div');\n//         this.breadcrumbsContainer.classList.add('tart-tabBar-breadcrumb-row');\n//         this.breadcrumbsContainer.appendChild(this.breadcrumbsRenderer.host);\n//         this.node.appendChild(this.breadcrumbsContainer);\n//     }\n// }\n\nexport namespace ToolbarAwareTabBar {\n\n  export namespace Styles {\n\n    export const TAB_BAR_CONTENT = 'p-TabBar-content';\n    export const TAB_BAR_CONTENT_CONTAINER = 'p-TabBar-content-container';\n\n  }\n\n}\n"]}