{"version":3,"sources":["browser/shell/tart-dock-panel.ts"],"names":[],"mappings":"AAAA;;;GAGG;AACH,OAAO,EAAa,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAC,MAAM,iBAAiB,CAAC;AAC7E,OAAO,EAAa,oBAAoB,EAAE,OAAO,EAAC,MAAM,cAAc,CAAC;AAEvE,OAAO,EAAC,MAAM,EAAC,MAAM,mBAAmB,CAAC;AAGzC,eAAO,MAAM,eAAe,mBAAmB,CAAC;AAEhD,eAAO,MAAM,YAAY,4BAA4B,CAAC;AACtD,eAAO,MAAM,cAAc,8BAA8B,CAAC;AAE1D,qBAAa,aAAc,SAAQ,SAAS;IAC1C;;OAEG;IACH,QAAQ,CAAC,WAAW,uBAAkC;IACtD;;OAEG;IACH,QAAQ,CAAC,eAAe,uBAAkC;IAC1D;;OAEG;IACH,QAAQ,CAAC,aAAa,uBAAkC;IAExD,SAAS,CAAC,QAAQ,CAAC,2BAA2B,kBAAyB;IACvE,QAAQ,CAAC,oBAAoB,uCAA0C;IACvE,SAAS,CAAC,QAAQ,CAAC,wBAAwB,uBAA8B;IACzE,SAAS,CAAC,QAAQ,CAAC,0BAA0B,uBAA8B;IAC3E,SAAS,CAAC,gBAAgB,EAAE,WAAW,GAAG,SAAS,CAAC;gBAGhD,OAAO,CAAC,EAAE,SAAS,CAAC,QAAQ;IAahC,IAAI,aAAa,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS,CAE9C;IAED,SAAS,CAAC,aAAa,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC;IAEnD,IAAI,YAAY,IAAI,KAAK,CAAC,MAAM,CAAC,GAAG,SAAS,CAE5C;IAED,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS;IAI5D,oBAAoB,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS;IAMxD,qBAAqB,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS;IASzE,gBAAgB,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS;IAMpD,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS;IASrE,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,SAAS,CAAC,WAAW,GAAG,IAAI;IAQhE,aAAa,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,SAAS,GAAG,IAAI;IAYrD,eAAe,IAAI,IAAI;IA6CvB,SAAS,CAAC,cAAc,CAAC,GAAG,EAAE,MAAM,CAAC,YAAY,GAAG,IAAI;IAKxD,SAAS,CAAC,mBAAmB,IAAI,WAAW;CAQ7C","file":"../../../src/browser/shell/tart-dock-panel.d.ts","sourcesContent":["/**\n * This specialization of DockPanel adds various events that are used for implementing the\n * side panels of the application shell.\n */\nimport {DockLayout, DockPanel, TabBar, Title, Widget} from '@lumino/widgets';\nimport {Disposable, DisposableCollection, Emitter} from '../../common';\nimport {UnsafeWidgetUtilities} from '../widgets';\nimport {Signal} from '@lumino/signaling';\nimport {ArrayExt, find, toArray} from '@lumino/algorithm';\n\nexport const MAXIMIZED_CLASS = 'tart-maximized';\n\nexport const MAIN_AREA_ID = 'tart-main-content-panel';\nexport const BOTTOM_AREA_ID = 'tart-bottom-content-panel';\n\nexport class TartDockPanel extends DockPanel {\n  /**\n   * Emitted when a widget is added to the panel.\n   */\n  readonly widgetAdded = new Signal<this, Widget>(this);\n  /**\n   * Emitted when a widget is activated by calling `activateWidget`.\n   */\n  readonly widgetActivated = new Signal<this, Widget>(this);\n  /**\n   * Emitted when a widget is removed from the panel.\n   */\n  readonly widgetRemoved = new Signal<this, Widget>(this);\n\n  protected readonly onDidToggleMaximizedEmitter = new Emitter<Widget>();\n  readonly onDidToggleMaximized = this.onDidToggleMaximizedEmitter.event;\n  protected readonly toDisposeOnMarkAsCurrent = new DisposableCollection();\n  protected readonly toDisposeOnToggleMaximized = new DisposableCollection();\n  protected maximizedElement: HTMLElement | undefined;\n\n  constructor(\n      options?: DockPanel.IOptions,\n  ) {\n    super(options);\n    this['_onCurrentChanged'] = (sender: TabBar<Widget>, args: TabBar.ICurrentChangedArgs<Widget>) => {\n      this.markAsCurrent(args.currentTitle || undefined);\n      super['_onCurrentChanged'](sender, args);\n    };\n    this['_onTabActivateRequested'] = (sender: TabBar<Widget>, args: TabBar.ITabActivateRequestedArgs<Widget>) => {\n      this.markAsCurrent(args.title);\n      super['_onTabActivateRequested'](sender, args);\n    };\n  }\n\n  get currentTabBar(): TabBar<Widget> | undefined {\n    return this._currentTitle && this.findTabBar(this._currentTitle);\n  }\n\n  protected _currentTitle: Title<Widget> | undefined;\n\n  get currentTitle(): Title<Widget> | undefined {\n    return this._currentTitle;\n  }\n\n  findTabBar(title: Title<Widget>): TabBar<Widget> | undefined {\n    return find(this.tabBars(), bar => ArrayExt.firstIndexOf(bar.titles, title) > -1);\n  }\n\n  previousTabBarWidget(widget: Widget): Widget | undefined {\n    const current = this.findTabBar(widget.title);\n    const previous = current && this.previousTabBarInPanel(current);\n    return previous && previous.currentTitle && previous.currentTitle.owner || undefined;\n  }\n\n  previousTabBarInPanel(tabBar: TabBar<Widget>): TabBar<Widget> | undefined {\n    const tabBars = toArray(this.tabBars());\n    const index = tabBars.indexOf(tabBar);\n    if (index !== -1) {\n      return tabBars[index - 1];\n    }\n    return undefined;\n  }\n\n  nextTabBarWidget(widget: Widget): Widget | undefined {\n    const current = this.findTabBar(widget.title);\n    const next = current && this.nextTabBarInPanel(current);\n    return next && next.currentTitle && next.currentTitle.owner || undefined;\n  }\n\n  nextTabBarInPanel(tabBar: TabBar<Widget>): TabBar<Widget> | undefined {\n    const tabBars = toArray(this.tabBars());\n    const index = tabBars.indexOf(tabBar);\n    if (index !== -1) {\n      return tabBars[index + 1];\n    }\n    return undefined;\n  }\n\n  addWidget(widget: Widget, options?: DockPanel.IAddOptions): void {\n    if (this.mode === 'single-document' && widget.parent === this) {\n      return;\n    }\n    super.addWidget(widget, options);\n    this.widgetAdded.emit(widget);\n  }\n\n  markAsCurrent(title: Title<Widget> | undefined): void {\n    this.toDisposeOnMarkAsCurrent.dispose();\n    this._currentTitle = title;\n    if (title) {\n      const resetCurrent = () => this.markAsCurrent(undefined);\n      title.owner.disposed.connect(resetCurrent);\n      this.toDisposeOnMarkAsCurrent.push(Disposable.create(() =>\n          title.owner.disposed.disconnect(resetCurrent)\n      ));\n    }\n  }\n\n  toggleMaximized(): void {\n    const areaContainer = this.node.parentElement;\n    if (!areaContainer) {\n      return;\n    }\n    const maximizedElement = this.getMaximizedElement();\n    if (areaContainer === maximizedElement) {\n      this.toDisposeOnToggleMaximized.dispose();\n      return;\n    }\n    if (this.isAttached) {\n      UnsafeWidgetUtilities.detach(this);\n    }\n    maximizedElement.style.display = 'block';\n    this.addClass(MAXIMIZED_CLASS);\n    UnsafeWidgetUtilities.attach(this, maximizedElement);\n    this.fit();\n    this.onDidToggleMaximizedEmitter.fire(this);\n    this.toDisposeOnToggleMaximized.push(Disposable.create(() => {\n      maximizedElement.style.display = 'none';\n      this.removeClass(MAXIMIZED_CLASS);\n      this.onDidToggleMaximizedEmitter.fire(this);\n      if (this.isAttached) {\n        UnsafeWidgetUtilities.detach(this);\n      }\n      UnsafeWidgetUtilities.attach(this, areaContainer);\n      this.fit();\n    }));\n\n    const layout = this.layout;\n    if (layout instanceof DockLayout) {\n      const onResize = layout['onResize'];\n      layout['onResize'] = () => onResize.bind(layout)(Widget.ResizeMessage.UnknownSize);\n      this.toDisposeOnToggleMaximized.push(Disposable.create(() => layout['onResize'] = onResize));\n    }\n\n    const removedListener = () => {\n      if (!this.widgets().next()) {\n        this.toDisposeOnToggleMaximized.dispose();\n      }\n    };\n    this.widgetRemoved.connect(removedListener);\n    this.toDisposeOnToggleMaximized.push(Disposable.create(() => this.widgetRemoved.disconnect(removedListener)));\n  }\n\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    super.onChildRemoved(msg);\n    this.widgetRemoved.emit(msg.child);\n  }\n\n  protected getMaximizedElement(): HTMLElement {\n    if (!this.maximizedElement) {\n      this.maximizedElement = document.createElement('div');\n      this.maximizedElement.style.display = 'none';\n      document.body.appendChild(this.maximizedElement);\n    }\n    return this.maximizedElement;\n  }\n}\n"]}