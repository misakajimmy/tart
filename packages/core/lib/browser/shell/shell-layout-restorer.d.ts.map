{"version":3,"sources":["browser/shell/shell-layout-restorer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAGlF,OAAO,EAAC,MAAM,EAAC,MAAM,iBAAiB,CAAC;AACvC,OAAO,EAAC,mBAAmB,EAAC,MAAM,yBAAyB,CAAC;AAC5D,OAAO,EAAC,yBAAyB,EAAE,aAAa,EAAC,MAAM,mBAAmB,CAAC;AAC3E,OAAO,EAAC,cAAc,EAAC,MAAM,oBAAoB,CAAC;AAClD,OAAO,EAAC,OAAO,EAAE,mBAAmB,EAAE,eAAe,EAAC,MAAM,sBAAsB,CAAC;AAEnF,OAAO,EAAC,oBAAoB,EAAC,MAAM,oCAAoC,CAAC;AACxE,OAAO,EAAC,YAAY,EAAC,MAAM,oBAAoB,CAAC;AAChD,OAAO,EAAC,gBAAgB,EAAiC,6BAA6B,EAAC,MAAM,qBAAqB,CAAC;AAGnH;;GAEG;AACH,MAAM,WAAW,cAAc;IAE7B;;OAEG;IACH,UAAU,IAAI,MAAM,GAAG,SAAS,CAAC;IAEjC;;OAEG;IACH,YAAY,CAAC,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;CACtC;AAED,yBAAiB,cAAc,CAAC;IAE9B,SAAgB,EAAE,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,cAAc,CAElD;CACF;AAED,MAAM,WAAW,iBAAiB;IAChC,mBAAmB,EAAE,yBAAyB,CAAC;IAC/C,gBAAgB,CAAC,EAAE,MAAM,GAAG,MAAM,CAAA;CACnC;AAED,MAAM,WAAW,sCAAsC;IACrD;;OAEG;IACH,aAAa,EAAE,MAAM,CAAA;IACrB;;OAEG;IACH,MAAM,EAAE,gBAAgB,CAAC,UAAU,CAAA;IACnC;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAA;CAChB;AAED,MAAM,WAAW,oCAAqC,SAAQ,KAAK;IACjE,IAAI,EAAE,sCAAsC,CAAA;CAC7C;AAED,yBAAiB,oCAAoC,CAAC;IAGpD,SAAgB,MAAM,CAAC,OAAO,CAAC,EAAE,MAAM,GAAG,oCAAoC,CAI7E;IAED,SAAgB,EAAE,CAAC,KAAK,EAAE,KAAK,GAAG,SAAS,GAAG,KAAK,IAAI,oCAAoC,CAE1F;CACF;AAED,eAAO,MAAM,+BAA+B,eAA4C,CAAC;AAEzF,MAAM,WAAW,+BAA+B;IAC9C;;OAEG;IACH,QAAQ,CAAC,aAAa,EAAE,6BAA6B,CAAC;IAEtD;;;;;OAKG;IACH,mBAAmB,CAAC,CAAC,OAAO,EAAE,sCAAsC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IAE1F;;;;;;OAMG;IACH,mBAAmB,CAAC,CAAC,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,sCAAsC,GAAG,YAAY,CAAC,iBAAiB,GAAG,SAAS,CAAC,CAAC;CAC7I;AAED,eAAO,MAAM,YAAY,SAI6C,CAAC;AAEvE,qBACa,mBAAoB,YAAW,mBAAmB;IASlC,SAAS,CAAC,aAAa,EAAE,aAAa;IAErC,SAAS,CAAC,cAAc,EAAE,cAAc;IATpE,SAAS,CAAC,UAAU,SAAY;IAChC,SAAS,CAAC,iBAAiB,EAAE,OAAO,CAAQ;IAG5C,SAAS,CAAC,QAAQ,CAAC,UAAU,EAAE,oBAAoB,CAAC,+BAA+B,CAAC,CAAC;gBAGhD,aAAa,EAAE,aAAa,EAE3B,cAAc,EAAE,cAAc;IAGpE,gBAAgB,CAAC,QAAQ,EAAE,eAAe,GAAG,IAAI;IAMjD,WAAW,CAAC,GAAG,EAAE,mBAAmB,GAAG,IAAI;IAerC,aAAa,CAAC,GAAG,EAAE,mBAAmB,GAAG,OAAO,CAAC,OAAO,CAAC;cAa/C,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC;IAS5C,SAAS,CAAC,gBAAgB,CAAC,YAAY,EAAE,MAAM,GAAG,OAAO;IAIzD,SAAS,CAAC,iBAAiB,CAAC,YAAY,EAAE,MAAM,GAAG,OAAO;IAI1D;;OAEG;IACH,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM;IAmBvC;;OAEG;cACa,OAAO,CAAC,UAAU,EAAE,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC;cAmCjE,qBAAqB,CAAC,OAAO,EAAE,mBAAmB,CAAC,cAAc,GAAG,OAAO,CAAC,IAAI,CAAC;IASjG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,YAAY,EAAE,mBAAmB,CAAC,YAAY,GAAG,CAAC;cA6BzE,qBAAqB,CAAC,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,mBAAmB,CAAC,cAAc,GAAG,OAAO,CAAC,iBAAiB,CAAC;cAiBvH,eAAe,CAAC,IAAI,EAAE,iBAAiB,EAAE,OAAO,EAAE,mBAAmB,CAAC,cAAc,GAAG,OAAO,CAAC,MAAM,GAAG,SAAS,CAAC;IAsClI,OAAO,CAAC,oBAAoB;CAkB7B;AAED,yBAAiB,mBAAmB,CAAC;IAEnC,MAAa,YAAY;QACvB,SAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,EAAE,CAAM;QAC7C,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAM;QAE5C;;;WAGG;QACH,aAAa,IAAI,OAAO;QAMxB,IAAI,CAAC,SAAS,EAAE,OAAO,GAAG,IAAI;QAIxB,OAAO,CAAC,OAAO,EAAE,cAAc,GAAG,OAAO,CAAC,IAAI,CAAC;KAiBtD;IAED,KAAY,OAAO,GAAG,CAAC,MAAM,GAAG,SAAS,CAAC,EAAE,CAAC;IAC7C,KAAY,OAAO,GAAG,CAAC,OAAO,EAAE,cAAc,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;IAEjE,UAAiB,cAAe,SAAQ,sCAAsC;QAC5E,QAAQ,CAAC,UAAU,EAAE,+BAA+B,EAAE,CAAC;KACxD;CACF","file":"../../../src/browser/shell/shell-layout-restorer.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {Widget} from '@lumino/widgets';\nimport {FrontendApplication} from '../frontend-application';\nimport {WidgetConstructionOptions, WidgetManager} from '../widget-manager';\nimport {StorageService} from '../storage-service';\nimport {Command, CommandContribution, CommandRegistry} from '../../common/command';\n// import { ThemeService } from '../theming';\nimport {ContributionProvider} from '../../common/contribution-provider';\nimport {MaybePromise} from '../../common/types';\nimport {ApplicationShell, applicationShellLayoutVersion, ApplicationShellLayoutVersion} from './application-shell';\nimport {CommonCommands} from '../common-frontend-contribution';\n\n/**\n * A contract for widgets that want to store and restore their inner state, between sessions.\n */\nexport interface StatefulWidget {\n\n  /**\n   * Called on unload to store the inner state. Returns 'undefined' if the widget cannot be stored.\n   */\n  storeState(): object | undefined;\n\n  /**\n   * Called when the widget got created by the storage service\n   */\n  restoreState(oldState: object): void;\n}\n\nexport namespace StatefulWidget {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is(arg: any): arg is StatefulWidget {\n    return arg !== undefined && typeof arg['storeState'] === 'function' && typeof arg['restoreState'] === 'function';\n  }\n}\n\nexport interface WidgetDescription {\n  constructionOptions: WidgetConstructionOptions,\n  innerWidgetState?: string | object\n}\n\nexport interface ApplicationShellLayoutMigrationContext {\n  /**\n   * A resolved version of a current layout.\n   */\n  layoutVersion: number\n  /**\n   * A layout to be inflated.\n   */\n  layout: ApplicationShell.LayoutData\n  /**\n   * A parent widget is to be inflated. `undefined` if the application shell\n   */\n  parent?: Widget\n}\n\nexport interface ApplicationShellLayoutMigrationError extends Error {\n  code: 'ApplicationShellLayoutMigrationError'\n}\n\nexport namespace ApplicationShellLayoutMigrationError {\n  const code: ApplicationShellLayoutMigrationError['code'] = 'ApplicationShellLayoutMigrationError';\n\n  export function create(message?: string): ApplicationShellLayoutMigrationError {\n    return Object.assign(new Error(\n        `Could not migrate layout to version ${applicationShellLayoutVersion}.` + (message ? '\\n' + message : '')\n    ), {code});\n  }\n\n  export function is(error: Error | undefined): error is ApplicationShellLayoutMigrationError {\n    return !!error && 'code' in error && error['code'] === code;\n  }\n}\n\nexport const ApplicationShellLayoutMigration = Symbol('ApplicationShellLayoutMigration');\n\nexport interface ApplicationShellLayoutMigration {\n  /**\n   * A target migration version.\n   */\n  readonly layoutVersion: ApplicationShellLayoutVersion;\n\n  /**\n   * A migration can transform layout before it will be inflated.\n   *\n   * @throws `ApplicationShellLayoutMigrationError` if a layout cannot be migrated,\n   * in this case the default layout will be initialized.\n   */\n  onWillInflateLayout?(context: ApplicationShellLayoutMigrationContext): MaybePromise<void>;\n\n  /**\n   * A migration can transform the given description before it will be inflated.\n   *\n   * @returns a migrated widget description, or `undefined`\n   * @throws `ApplicationShellLayoutMigrationError` if a widget description cannot be migrated,\n   * in this case the default layout will be initialized.\n   */\n  onWillInflateWidget?(desc: WidgetDescription, context: ApplicationShellLayoutMigrationContext): MaybePromise<WidgetDescription | undefined>;\n}\n\nexport const RESET_LAYOUT = Command.toLocalizedCommand({\n  id: 'reset.layout',\n  category: CommonCommands.VIEW_CATEGORY,\n  label: 'Reset Workbench Layout'\n}, 'tart/core/resetWorkbenchLayout', CommonCommands.VIEW_CATEGORY_KEY);\n\n@injectable()\nexport class ShellLayoutRestorer implements CommandContribution {\n\n  protected storageKey = 'layout';\n  protected shouldStoreLayout: boolean = true;\n\n  @inject(ContributionProvider) @named(ApplicationShellLayoutMigration)\n  protected readonly migrations: ContributionProvider<ApplicationShellLayoutMigration>;\n\n  constructor(\n      @inject(WidgetManager) protected widgetManager: WidgetManager,\n      // @inject(ILogger) protected logger: ILogger,\n      @inject(StorageService) protected storageService: StorageService) {\n  }\n\n  registerCommands(commands: CommandRegistry): void {\n    commands.registerCommand(RESET_LAYOUT, {\n      execute: async () => this.resetLayout()\n    });\n  }\n\n  storeLayout(app: FrontendApplication): void {\n    if (this.shouldStoreLayout) {\n      try {\n        console.info('>>> Storing the layout...');\n        const layoutData = app.shell.getLayoutData();\n        const serializedLayoutData = this.deflate(layoutData);\n        this.storageService.setData(this.storageKey, serializedLayoutData);\n        console.info('<<< The layout has been successfully stored.');\n      } catch (error) {\n        this.storageService.setData(this.storageKey, undefined);\n        console.error('Error during serialization of layout data', error);\n      }\n    }\n  }\n\n  async restoreLayout(app: FrontendApplication): Promise<boolean> {\n    console.info('>>> Restoring the layout state...');\n    const serializedLayoutData = await this.storageService.getData<string>(this.storageKey);\n    if (serializedLayoutData === undefined) {\n      console.info('<<< Nothing to restore.');\n      return false;\n    }\n    const layoutData = await this.inflate(serializedLayoutData);\n    await app.shell.setLayoutData(layoutData);\n    console.info('<<< The layout has been successfully restored.');\n    return true;\n  }\n\n  protected async resetLayout(): Promise<void> {\n    console.info('>>> Resetting layout...');\n    this.shouldStoreLayout = false;\n    this.storageService.setData(this.storageKey, undefined);\n    // ThemeService.get().reset(); // Theme service cannot use DI, so the current theme ID is stored elsewhere. Hence the explicit reset.\n    console.info('<<< The layout has been successfully reset.');\n    window.location.reload();\n  }\n\n  protected isWidgetProperty(propertyName: string): boolean {\n    return propertyName === 'widget';\n  }\n\n  protected isWidgetsProperty(propertyName: string): boolean {\n    return propertyName === 'widgets';\n  }\n\n  /**\n   * Turns the layout data to a string representation.\n   */\n  protected deflate(data: object): string {\n    return JSON.stringify(data, (property: string, value) => {\n      if (this.isWidgetProperty(property)) {\n        const description = this.convertToDescription(value as Widget);\n        return description;\n      } else if (this.isWidgetsProperty(property)) {\n        const descriptions: WidgetDescription[] = [];\n        for (const widget of (value as Widget[])) {\n          const description = this.convertToDescription(widget);\n          if (description) {\n            descriptions.push(description);\n          }\n        }\n        return descriptions;\n      }\n      return value;\n    });\n  }\n\n  /**\n   * Creates the layout data from its string representation.\n   */\n  protected async inflate(layoutData: string): Promise<ApplicationShell.LayoutData> {\n    const parseContext = new ShellLayoutRestorer.ParseContext();\n    const layout = this.parse<ApplicationShell.LayoutData>(layoutData, parseContext);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let layoutVersion: number | any;\n    try {\n      layoutVersion = 'version' in layout && Number(layout.version);\n    } catch { /* no-op */\n    }\n    if (typeof layoutVersion !== 'number' || Number.isNaN(layoutVersion)) {\n      throw new Error('could not resolve a layout version');\n    }\n    if (layoutVersion !== applicationShellLayoutVersion) {\n      if (layoutVersion < applicationShellLayoutVersion) {\n        console.warn(`Layout version ${layoutVersion} is behind current layout version ${applicationShellLayoutVersion}, trying to migrate...`);\n      } else {\n        console.warn(`Layout version ${layoutVersion} is ahead current layout version ${applicationShellLayoutVersion}, trying to load anyway...`);\n      }\n      console.info(`Please use '${RESET_LAYOUT.label}' command if the layout looks bogus.`);\n    }\n\n    const migrations = this.migrations.getContributions()\n        .filter(m => m.layoutVersion > layoutVersion && m.layoutVersion <= applicationShellLayoutVersion)\n        .sort((m, m2) => m.layoutVersion - m2.layoutVersion);\n    if (migrations.length) {\n      console.info(`Found ${migrations.length} migrations from layout version ${layoutVersion} to version ${applicationShellLayoutVersion}, migrating...`);\n    }\n\n    const context = {layout, layoutVersion, migrations};\n    await this.fireWillInflateLayout(context);\n    await parseContext.inflate(context);\n    return layout;\n  }\n\n  protected async fireWillInflateLayout(context: ShellLayoutRestorer.InflateContext): Promise<void> {\n    for (const migration of context.migrations) {\n      if (migration.onWillInflateLayout) {\n        // don't catch exceptions, if one migration fails all should fail.\n        await migration.onWillInflateLayout(context);\n      }\n    }\n  }\n\n  protected parse<T>(layoutData: string, parseContext: ShellLayoutRestorer.ParseContext): T {\n    return JSON.parse(layoutData, (property: string, value) => {\n      if (this.isWidgetsProperty(property)) {\n        const widgets = parseContext.filteredArray();\n        const descs = (value as WidgetDescription[]);\n        for (let i = 0; i < descs.length; i++) {\n          parseContext.push(async context => {\n            widgets[i] = await this.convertToWidget(descs[i], context);\n          });\n        }\n        return widgets;\n      } else if (value && typeof value === 'object' && !Array.isArray(value)) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const copy: any = {};\n        for (const p in value) {\n          if (this.isWidgetProperty(p)) {\n            parseContext.push(async context => {\n              copy[p] = await this.convertToWidget(value[p], context);\n            });\n          } else {\n            copy[p] = value[p];\n          }\n        }\n        return copy;\n      }\n      return value;\n    });\n  }\n\n  protected async fireWillInflateWidget(desc: WidgetDescription, context: ShellLayoutRestorer.InflateContext): Promise<WidgetDescription> {\n    for (const migration of context.migrations) {\n      if (migration.onWillInflateWidget) {\n        // don't catch exceptions, if one migration fails all should fail.\n        const migrated = await migration.onWillInflateWidget(desc, context);\n        if (migrated) {\n          if (migrated.innerWidgetState && typeof migrated.innerWidgetState !== 'string') {\n            // in order to inflate nested widgets\n            migrated.innerWidgetState = JSON.stringify(migrated.innerWidgetState);\n          }\n          desc = migrated;\n        }\n      }\n    }\n    return desc;\n  }\n\n  protected async convertToWidget(desc: WidgetDescription, context: ShellLayoutRestorer.InflateContext): Promise<Widget | undefined> {\n    if (!desc.constructionOptions) {\n      return undefined;\n    }\n    try {\n      desc = await this.fireWillInflateWidget(desc, context);\n      const widget = await this.widgetManager.getOrCreateWidget(desc.constructionOptions.factoryId, desc.constructionOptions.options);\n      if (StatefulWidget.is(widget) && desc.innerWidgetState !== undefined) {\n        try {\n          let oldState: object;\n          if (typeof desc.innerWidgetState === 'string') {\n            const parseContext = new ShellLayoutRestorer.ParseContext();\n            oldState = this.parse(desc.innerWidgetState, parseContext);\n            await parseContext.inflate({...context, parent: widget});\n          } else {\n            oldState = desc.innerWidgetState;\n          }\n          widget.restoreState(oldState);\n        } catch (e) {\n          if (ApplicationShellLayoutMigrationError.is(e)) {\n            throw e;\n          }\n          console.warn(`Couldn't restore widget state for ${widget.id}. Error: ${e} `);\n        }\n      }\n      if (widget.isDisposed) {\n        return undefined;\n      }\n      return widget;\n    } catch (e) {\n      if (ApplicationShellLayoutMigrationError.is(e)) {\n        throw e;\n      }\n      console.warn(`Couldn't restore widget for ${desc.constructionOptions.factoryId}. Error: ${e} `);\n      return undefined;\n    }\n  }\n\n  private convertToDescription(widget: Widget): WidgetDescription | undefined {\n    const desc = this.widgetManager.getDescription(widget);\n    if (desc) {\n      if (StatefulWidget.is(widget)) {\n        const innerState = widget.storeState();\n        return innerState ? {\n          constructionOptions: desc,\n          innerWidgetState: this.deflate(innerState)\n        } : undefined;\n      } else {\n        return {\n          constructionOptions: desc,\n          innerWidgetState: undefined\n        };\n      }\n    }\n  }\n\n}\n\nexport namespace ShellLayoutRestorer {\n\n  export class ParseContext {\n    protected readonly toInflate: Inflate[] = [];\n    protected readonly toFilter: Widgets[] = [];\n\n    /**\n     * Returns an array, which will be filtered from undefined elements\n     * after resolving promises, that create widgets.\n     */\n    filteredArray(): Widgets {\n      const array: Widgets = [];\n      this.toFilter.push(array);\n      return array;\n    }\n\n    push(toInflate: Inflate): void {\n      this.toInflate.push(toInflate);\n    }\n\n    async inflate(context: InflateContext): Promise<void> {\n      const pending: Promise<void>[] = [];\n      while (this.toInflate.length) {\n        pending.push(this.toInflate.pop()!(context));\n      }\n      await Promise.all(pending);\n\n      if (this.toFilter.length) {\n        this.toFilter.forEach(array => {\n          for (let i = 0; i < array.length; i++) {\n            if (array[i] === undefined) {\n              array.splice(i--, 1);\n            }\n          }\n        });\n      }\n    }\n  }\n\n  export type Widgets = (Widget | undefined)[];\n  export type Inflate = (context: InflateContext) => Promise<void>;\n\n  export interface InflateContext extends ApplicationShellLayoutMigrationContext {\n    readonly migrations: ApplicationShellLayoutMigration[];\n  }\n}\n"]}