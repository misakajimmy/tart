{"version":3,"sources":["browser/shell/tab-bar-toolbar.tsx"],"names":[],"mappings":"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","file":"../../../src/browser/shell/tab-bar-toolbar.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {debounce} from 'lodash';\nimport * as React from 'react';\nimport {inject, injectable, named} from 'inversify';\nimport {ACTION_ITEM, codicon, ReactWidget, Widget} from '../widgets';\nimport {LabelIcon, LabelParser} from '../label-parser';\nimport {ContributionProvider} from '../../common/contribution-provider';\nimport {FrontendApplicationContribution} from '../frontend-application';\nimport {CommandRegistry} from '../../common/command';\nimport {Disposable, DisposableCollection} from '../../common/disposable';\nimport {ContextKeyService} from '../context-key-service';\nimport {Emitter, Event} from '../../common';\nimport {Anchor, ContextMenuRenderer} from '../context-menu-renderer';\nimport {MenuModelRegistry} from '../../common/menu';\n\n/**\n * Clients should implement this interface if they want to contribute to the tab-bar toolbar.\n */\nexport const TabBarToolbarContribution = Symbol('TabBarToolbarContribution');\n\n/**\n * Representation of a tabbar toolbar contribution.\n */\nexport interface TabBarToolbarContribution {\n  /**\n   * Registers toolbar items.\n   * @param registry the tabbar toolbar registry.\n   */\n  registerToolbarItems(registry: TabBarToolbarRegistry): void;\n}\n\nexport interface TabBarDelegator extends Widget {\n  getTabBarDelegate(): Widget | undefined;\n}\n\nexport namespace TabBarDelegator {\n  export const is = (candidate?: Widget): candidate is TabBarDelegator => {\n    if (candidate) {\n      const asDelegator = candidate as TabBarDelegator;\n      return typeof asDelegator.getTabBarDelegate === 'function';\n    }\n    return false;\n  };\n}\n\n/**\n * Representation of an item in the tab\n */\nexport interface TabBarToolbarItem {\n\n  /**\n   * The unique ID of the toolbar item.\n   */\n  readonly id: string;\n\n  /**\n   * The command to execute.\n   */\n  readonly command: string;\n\n  /**\n   * Optional text of the item.\n   *\n   * Shamelessly copied and reused from `status-bar`:\n   *\n   * More details about the available `fontawesome` icons and CSS class names can be hound [here](http://fontawesome.io/icons/).\n   * To set a text with icon use the following pattern in text string:\n   * ```typescript\n   * $(fontawesomeClassName)\n   * ```\n   *\n   * To use animated icons use the following pattern:\n   * ```typescript\n   * $(fontawesomeClassName~typeOfAnimation)\n   * ````\n   * The type of animation can be either `spin` or `pulse`.\n   * Look [here](http://fontawesome.io/examples/#animated) for more information to animated icons.\n   */\n  readonly text?: string;\n\n  /**\n   * Priority among the items. Can be negative. The smaller the number the left-most the item will be placed in the toolbar. It is `0` by default.\n   */\n  readonly priority?: number;\n\n  /**\n   * Optional group for the item. Default `navigation`.\n   * `navigation` group will be inlined, while all the others will be within the `...` dropdown.\n   * A group in format `submenu_group_1/submenu 1/.../submenu_group_n/ submenu n/item_group` means that the item will be located in a submenu(s) of the `...` dropdown.\n   * The submenu's title is named by the submenu section name, e.g. `group/<submenu name>/subgroup`.\n   */\n  readonly group?: string;\n\n  /**\n   * Optional tooltip for the item.\n   */\n  readonly tooltip?: string;\n\n  /**\n   * Optional icon for the item.\n   */\n  readonly icon?: string | (() => string);\n\n  /**\n   * https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts\n   */\n  readonly when?: string;\n\n  /**\n   * When defined, the container tool-bar will be updated if this event is fired.\n   *\n   * Note: currently, each item of the container toolbar will be re-rendered if any of the items have changed.\n   */\n  readonly onDidChange?: Event<void>;\n\n}\n\n/**\n * Tab-bar toolbar item backed by a `React.ReactNode`.\n * Unlike the `TabBarToolbarItem`, this item is not connected to the command service.\n */\nexport interface ReactTabBarToolbarItem {\n  readonly id: string;\n  readonly onDidChange?: Event<void>;\n  readonly when?: string;\n\n  // For the rest, see `TabBarToolbarItem`.\n  // Ordering and grouping.\n  readonly priority?: number;\n  /**\n   * Optional group for the item. Default `navigation`. Always inlined.\n   */\n  readonly group?: string;\n\n  render(widget?: Widget): React.ReactNode;\n\n  // For conditional visibility.\n  isVisible?(widget: Widget): boolean;\n}\n\nexport namespace TabBarToolbarItem {\n\n  /**\n   * Compares the items by `priority` in ascending. Undefined priorities will be treated as `0`.\n   */\n  export const PRIORITY_COMPARATOR = (left: TabBarToolbarItem, right: TabBarToolbarItem) => {\n    // The navigation group is special as it will always be sorted to the top/beginning of a menu.\n    const compareGroup = (leftGroup: string | undefined = 'navigation', rightGroup: string | undefined = 'navigation') => {\n      if (leftGroup === 'navigation') {\n        return rightGroup === 'navigation' ? 0 : -1;\n      }\n      if (rightGroup === 'navigation') {\n        return leftGroup === 'navigation' ? 0 : 1;\n      }\n      return leftGroup.localeCompare(rightGroup);\n    };\n    const result = compareGroup(left.group, right.group);\n    if (result !== 0) {\n      return result;\n    }\n    return (left.priority || 0) - (right.priority || 0);\n  };\n\n  export function is(arg: Object | undefined): arg is TabBarToolbarItem {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return !!arg && 'command' in arg && typeof (arg as any).command === 'string';\n  }\n\n}\n\n/**\n * Main, shared registry for tab-bar toolbar items.\n */\n@injectable()\nexport class TabBarToolbarRegistry implements FrontendApplicationContribution {\n\n  protected items: Map<string, TabBarToolbarItem | ReactTabBarToolbarItem> = new Map();\n\n  @inject(CommandRegistry)\n  protected readonly commandRegistry: CommandRegistry;\n\n  @inject(ContextKeyService)\n  protected readonly contextKeyService: ContextKeyService;\n\n  @inject(ContributionProvider)\n  @named(TabBarToolbarContribution)\n  protected readonly contributionProvider: ContributionProvider<TabBarToolbarContribution>;\n\n  protected readonly onDidChangeEmitter = new Emitter<void>();\n  readonly onDidChange: Event<void> = this.onDidChangeEmitter.event;\n  // debounce in order to avoid to fire more than once in the same tick\n  protected fireOnDidChange = debounce(() => this.onDidChangeEmitter.fire(undefined), 0);\n\n  onStart(): void {\n    console.log('TabBarToolbarRegistry Start');\n    const contributions = this.contributionProvider.getContributions();\n    for (const contribution of contributions) {\n      contribution.registerToolbarItems(this);\n    }\n  }\n\n  /**\n   * Registers the given item. Throws an error, if the corresponding command cannot be found or an item has been already registered for the desired command.\n   *\n   * @param item the item to register.\n   */\n  registerItem(item: TabBarToolbarItem | ReactTabBarToolbarItem): Disposable {\n    const {id} = item;\n    if (this.items.has(id)) {\n      throw new Error(`A toolbar item is already registered with the '${id}' ID.`);\n    }\n    this.items.set(id, item);\n    this.fireOnDidChange();\n    const toDispose = new DisposableCollection(\n        Disposable.create(() => {\n          this.fireOnDidChange();\n        }),\n        Disposable.create(() => this.items.delete(id))\n    );\n    if (item.onDidChange) {\n      toDispose.push(item.onDidChange(() => this.fireOnDidChange()));\n    }\n    return toDispose;\n  }\n\n  /**\n   * Returns an array of tab-bar toolbar items which are visible when the `widget` argument is the current one.\n   *\n   * By default returns with all items where the command is enabled and `item.isVisible` is `true`.\n   */\n  visibleItems(widget: Widget): Array<TabBarToolbarItem | ReactTabBarToolbarItem> {\n    if (widget.isDisposed) {\n      return [];\n    }\n    const result = [];\n    for (const item of this.items.values()) {\n      const visible = TabBarToolbarItem.is(item)\n          ? this.commandRegistry.isVisible(item.command, widget)\n          : (!item.isVisible || item.isVisible(widget));\n      if (visible && (!item.when || this.contextKeyService.match(item.when, widget.node))) {\n        result.push(item);\n      }\n    }\n    return result;\n  }\n\n  unregisterItem(itemOrId: TabBarToolbarItem | ReactTabBarToolbarItem | string): void {\n    const id = typeof itemOrId === 'string' ? itemOrId : itemOrId.id;\n    if (this.items.delete(id)) {\n      this.fireOnDidChange();\n    }\n  }\n\n}\n\n/**\n * Factory for instantiating tab-bar toolbars.\n */\nexport const TabBarToolbarFactory = Symbol('TabBarToolbarFactory');\n\nexport interface TabBarToolbarFactory {\n  (): TabBarToolbar;\n}\n\n/**\n * Tab-bar toolbar widget representing the active [tab-bar toolbar items](TabBarToolbarItem).\n */\n@injectable()\nexport class TabBarToolbar extends ReactWidget {\n\n  protected current: Widget | undefined;\n  protected inline = new Map<string, TabBarToolbarItem | ReactTabBarToolbarItem>();\n  protected more = new Map<string, TabBarToolbarItem>();\n\n  protected readonly onExecuteCommandEmitter = new Emitter<void>();\n  readonly onExecuteCommand = this.onExecuteCommandEmitter.event;\n\n  @inject(CommandRegistry)\n  protected readonly commands: CommandRegistry;\n\n  @inject(LabelParser)\n  protected readonly labelParser: LabelParser;\n\n  @inject(MenuModelRegistry)\n  protected readonly menus: MenuModelRegistry;\n\n  @inject(ContextMenuRenderer)\n  protected readonly contextMenuRenderer: ContextMenuRenderer;\n\n  @inject(TabBarToolbarRegistry)\n  protected readonly toolbarRegistry: TabBarToolbarRegistry;\n  protected readonly toDisposeOnSetCurrent = new DisposableCollection();\n\n  constructor() {\n    super();\n    this.addClass(TabBarToolbar.Styles.TAB_BAR_TOOLBAR);\n    this.hide();\n  }\n\n  updateItems(items: Array<TabBarToolbarItem | ReactTabBarToolbarItem>, current: Widget | undefined): void {\n    this.inline.clear();\n    this.more.clear();\n    for (const item of items.sort(TabBarToolbarItem.PRIORITY_COMPARATOR).reverse()) {\n      if ('render' in item || item.group === undefined || item.group === 'navigation') {\n        this.inline.set(item.id, item);\n      } else {\n        this.more.set(item.id, item);\n      }\n    }\n    this.setCurrent(current);\n    if (!items.length) {\n      this.hide();\n    }\n    this.onRender.push(Disposable.create(() => {\n      if (items.length) {\n        this.show();\n      }\n    }));\n    this.update();\n  }\n\n  updateTarget(current?: Widget): void {\n    const operativeWidget = TabBarDelegator.is(current) ? current.getTabBarDelegate() : current;\n    const items = operativeWidget ? this.toolbarRegistry.visibleItems(operativeWidget) : [];\n    this.updateItems(items, operativeWidget);\n  }\n\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  renderMoreContextMenu(anchor: Anchor): any {\n    const menuPath = ['TAB_BAR_TOOLBAR_CONTEXT_MENU'];\n    const toDisposeOnHide = new DisposableCollection();\n    this.addClass('menu-open');\n    toDisposeOnHide.push(Disposable.create(() => this.removeClass('menu-open')));\n    for (const item of this.more.values()) {\n      // Register a submenu for the item, if the group is in format `<submenu group>/<submenu name>/.../<item group>`\n      if (item.group?.includes('/')) {\n        const split = item.group.split('/');\n        const paths: string[] = [];\n        for (let i = 0; i < split.length - 1; i += 2) {\n          paths.push(split[i], split[i + 1]);\n          // TODO order is missing, items sorting will be alphabetic\n          toDisposeOnHide.push(this.menus.registerSubmenu([...menuPath, ...paths], split[i + 1]));\n        }\n      }\n      // TODO order is missing, items sorting will be alphabetic\n      toDisposeOnHide.push(this.menus.registerMenuAction([...menuPath, ...item.group!.split('/')], {\n        label: item.tooltip,\n        commandId: item.command,\n        when: item.when\n      }));\n    }\n    return this.contextMenuRenderer.render({\n      menuPath,\n      args: [this.current],\n      anchor,\n      onHide: () => toDisposeOnHide.dispose()\n    });\n  }\n\n  shouldHandleMouseEvent(event: MouseEvent): boolean {\n    return event.target instanceof Element && this.node.contains(event.target);\n  }\n\n  protected setCurrent(current: Widget | undefined): void {\n    this.toDisposeOnSetCurrent.dispose();\n    this.toDispose.push(this.toDisposeOnSetCurrent);\n    this.current = current;\n    if (current) {\n      const resetCurrent = () => {\n        this.setCurrent(undefined);\n        this.update();\n      };\n      current.disposed.connect(resetCurrent);\n      this.toDisposeOnSetCurrent.push(Disposable.create(() =>\n          current.disposed.disconnect(resetCurrent)\n      ));\n    }\n  }\n\n  protected render(): React.ReactNode {\n    return <React.Fragment>\n      {this.renderMore()}\n      {[...this.inline.values()].map(item => TabBarToolbarItem.is(item) ? this.renderItem(item) : item.render(this.current))}\n    </React.Fragment>;\n  }\n\n  protected renderItem(item: TabBarToolbarItem): React.ReactNode {\n    let innerText = '';\n    const classNames = [];\n    if (item.text) {\n      for (const labelPart of this.labelParser.parse(item.text)) {\n        if (typeof labelPart !== 'string' && LabelIcon.is(labelPart)) {\n          const className = `fa fa-${labelPart.name}${labelPart.animation ? ' fa-' + labelPart.animation : ''}`;\n          classNames.push(...className.split(' '));\n        } else {\n          innerText = labelPart;\n        }\n      }\n    }\n    const command = this.commands.getCommand(item.command);\n    let iconClass = (typeof item.icon === 'function' && item.icon()) || item.icon as string || (command && command.iconClass);\n    if (iconClass) {\n      iconClass += ` ${ACTION_ITEM}`;\n      classNames.push(iconClass);\n    }\n    const tooltip = item.tooltip || (command && command.label);\n    const toolbarItemClassNames = this.getToolbarItemClassNames(command?.id);\n    return <div key={item.id}\n                className={toolbarItemClassNames}\n                onMouseDown={this.onMouseDownEvent}\n                onMouseUp={this.onMouseUpEvent}\n                onMouseOut={this.onMouseUpEvent}>\n      <div id={item.id} className={classNames.join(' ')}\n           onClick={this.executeCommand}\n           title={tooltip}>{innerText}\n      </div>\n    </div>;\n  }\n\n  protected getToolbarItemClassNames(commandId: string | undefined): string {\n    const classNames = [TabBarToolbar.Styles.TAB_BAR_TOOLBAR_ITEM];\n    if (commandId) {\n      if (this.commandIsEnabled(commandId)) {\n        classNames.push('enabled');\n      }\n      if (this.commandIsToggled(commandId)) {\n        classNames.push('toggled');\n      }\n    }\n    return classNames.join(' ');\n  }\n\n  protected renderMore(): React.ReactNode {\n    return !!this.more.size &&\n        <div key='__more__' className={TabBarToolbar.Styles.TAB_BAR_TOOLBAR_ITEM + ' enabled'}>\n            <div id='__more__' className={codicon('ellipsis', true)} onClick={this.showMoreContextMenu}\n                 title={'More Actions...'}/>\n        </div>;\n  }\n\n  protected showMoreContextMenu = (event: React.MouseEvent) => {\n    event.stopPropagation();\n    event.preventDefault();\n\n    this.renderMoreContextMenu(event.nativeEvent);\n  };\n\n  protected commandIsEnabled(command: string): boolean {\n    return this.commands.isEnabled(command, this.current);\n  }\n\n  protected commandIsToggled(command: string): boolean {\n    return this.commands.isToggled(command, this.current);\n  }\n\n  protected executeCommand = (e: React.MouseEvent<HTMLElement>) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const item = this.inline.get(e.currentTarget.id);\n    if (TabBarToolbarItem.is(item)) {\n      this.commands.executeCommand(item.command, this.current).then(() => {\n        this.onExecuteCommandEmitter.fire()\n      });\n    }\n    this.update();\n  };\n\n  protected onMouseDownEvent = (e: React.MouseEvent<HTMLElement>) => {\n    if (e.button === 0) {\n      e.currentTarget.classList.add('active');\n    }\n  };\n\n  protected onMouseUpEvent = (e: React.MouseEvent<HTMLElement>) => {\n    e.currentTarget.classList.remove('active');\n  };\n\n}\n\nexport namespace TabBarToolbar {\n\n  export namespace Styles {\n\n    export const TAB_BAR_TOOLBAR = 'p-TabBar-toolbar';\n    export const TAB_BAR_TOOLBAR_ITEM = 'item';\n\n  }\n\n}\n"]}