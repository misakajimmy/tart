{"version":3,"sources":["browser/shell/application-shell.ts"],"names":[],"mappings":"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","file":"../../../src/browser/shell/application-shell.d.ts","sourcesContent":["import {inject, injectable, optional, postConstruct} from 'inversify';\nimport {\n  BoxLayout,\n  BoxPanel,\n  DockLayout,\n  DockPanel,\n  FocusTracker,\n  Layout,\n  Panel,\n  SplitLayout,\n  SplitPanel,\n  TabBar,\n  Title,\n  Widget\n} from '@lumino/widgets';\nimport {BOTTOM_AREA_ID, MAIN_AREA_ID, TartDockPanel} from './tart-dock-panel';\nimport {Disposable, DisposableCollection, Emitter, Event as CommonEvent, RecursivePartial} from '../../common';\nimport {SidePanel, SidePanelHandler, SidePanelHandlerFactory} from './side-panel-handler';\nimport {StatusBarAlignment, StatusBarEntry, StatusBarImpl} from '../status-bar';\nimport {ArrayExt, each, find, toArray} from '@lumino/algorithm';\nimport {Saveable, SaveableWidget, SaveOptions} from '../saveable';\nimport {Message} from '@lumino/messaging';\nimport {waitForClosed, waitForRevealed} from '../widgets';\nimport {FrontendApplicationStateService} from '../frontend-application-state';\nimport {SplitPositionHandler, SplitPositionOptions} from './split-panels';\nimport {animationFrame} from '../browser';\nimport {Signal} from '@lumino/signaling';\nimport {ContextKeyService} from '../context-key-service';\nimport {ScrollableTabBar} from './tab-bars';\n// import {TabBarRenderer, TabBarRendererFactory} from './tab-bars';\n// import {TabBarToolbar, TabBarToolbarFactory, TabBarToolbarRegistry} from './tab-bar-toolbar';\n\nexport type ApplicationShellLayoutVersion =\n/** layout versioning is introduced, unversioned layout are not compatible */\n    2.0 |\n    /** view containers are introduced, backward compatible to 2.0 */\n    3.0 |\n    /** git history view is replaced by a more generic scm history view, backward compatible to 3.0 */\n    4.0 |\n    /** Replace custom/font-awesome icons with codicons */\n    5.0 |\n    /** added the ability to drag and drop view parts between view containers */\n    6.0;\n\n/**\n * When a version is increased, make sure to introduce a migration (ApplicationShellLayoutMigration) to this version.\n */\nexport const applicationShellLayoutVersion: ApplicationShellLayoutVersion = 5.0;\n\n/** The class name added to ApplicationShell instances. */\nconst APPLICATION_SHELL_CLASS = 'tart-ApplicationShell';\n/** The class name added to the main and bottom area panels. */\nconst MAIN_BOTTOM_AREA_CLASS = 'tart-app-centers';\n/** Status bar entry identifier for the bottom panel toggle button. */\nconst BOTTOM_PANEL_TOGGLE_ID = 'bottom-panel-toggle';\n/** The class name added to the main area panel. */\nconst MAIN_AREA_CLASS = 'tart-app-main';\n/** The class name added to the bottom area panel. */\nconst BOTTOM_AREA_CLASS = 'tart-app-bottom';\n\nexport const ApplicationShellOptions = Symbol('ApplicationShellOptions');\nexport const DockPanelRendererFactory = Symbol('DockPanelRendererFactory');\n\n\n/**\n * A renderer for dock panels that supports context menus on tabs.\n */\n// @injectable()\n// export class DockPanelRenderer implements DockLayout.IRenderer {\n//\n//     readonly tabBarClasses: string[] = [];\n//\n//     constructor(\n//         @inject(TabBarRendererFactory) protected readonly tabBarRendererFactory: () => TabBarRenderer,\n//         @inject(TabBarToolbarRegistry) protected readonly tabBarToolbarRegistry: TabBarToolbarRegistry,\n//         @inject(TabBarToolbarFactory) protected readonly tabBarToolbarFactory: () => TabBarToolbar,\n//         @inject(BreadcrumbsRendererFactory) protected readonly breadcrumbsRendererFactory: BreadcrumbsRendererFactory,\n//     ) { }\n//\n//     createTabBar(): TabBar<Widget> {\n//         const renderer = this.tabBarRendererFactory();\n//         const tabBar = new ToolbarAwareTabBar(\n//             this.tabBarToolbarRegistry,\n//             this.tabBarToolbarFactory,\n//             this.breadcrumbsRendererFactory,\n//             {\n//                 renderer,\n//                 // Scroll bar options\n//                 handlers: ['drag-thumb', 'keyboard', 'wheel', 'touch'],\n//                 useBothWheelAxes: true,\n//                 scrollXMarginOffset: 4,\n//                 suppressScrollY: true\n//             });\n//         this.tabBarClasses.forEach(c => tabBar.addClass(c));\n//         renderer.tabBar = tabBar;\n//         tabBar.disposed.connect(() => renderer.dispose());\n//         renderer.contextMenuPath = SHELL_TABBAR_CONTEXT_MENU;\n//         tabBar.currentChanged.connect(this.onCurrentTabChanged, this);\n//         return tabBar;\n//     }\n//\n//     createHandle(): HTMLDivElement {\n//         return DockPanel.defaultRenderer.createHandle();\n//     }\n//\n//     protected onCurrentTabChanged(sender: ToolbarAwareTabBar, { currentIndex }: TabBar.ICurrentChangedArgs<Widget>): void {\n//         if (currentIndex >= 0) {\n//             sender.revealTab(currentIndex);\n//         }\n//     }\n// }\n\n@injectable()\nexport class ApplicationShell extends Widget {\n  /**\n   * The dock panel in the main shell area. This is where editors usually go to.\n   */\n  mainPanel: TartDockPanel;\n\n  /**\n   * The dock panel in the bottom shell area. In contrast to the main panel, the bottom panel\n   * can be collapsed and expanded.\n   */\n  bottomPanel: TartDockPanel;\n\n  /**\n   * Handler for the left side panel. The primary application views go here, such as the\n   * file explorer and the git view.\n   */\n  leftPanelHandler: SidePanelHandler;\n\n  /**\n   * Handler for the right side panel. The secondary application views go here, such as the\n   * outline view.\n   */\n  rightPanelHandler: SidePanelHandler;\n  /**\n   * The fixed-size panel shown on top. This one usually holds the main menu.\n   */\n  readonly topPanel: Panel;\n  /**\n   * A signal emitted whenever the `currentWidget` property is changed.\n   *\n   * @deprecated since 0.11.0, use `onDidChangeCurrentWidget` instead\n   */\n  readonly currentChanged = new Signal<this, FocusTracker.IChangedArgs<Widget>>(this);\n  /**\n   * A signal emitted whenever the `activeWidget` property is changed.\n   *\n   * @deprecated since 0.11.0, use `onDidChangeActiveWidget` instead\n   */\n  readonly activeChanged = new Signal<this, FocusTracker.IChangedArgs<Widget>>(this);\n  /**\n   * General options for the application shell.\n   */\n  protected options: ApplicationShell.Options;\n  /**\n   * The current state of the bottom panel.\n   */\n  protected readonly bottomPanelState: SidePanel.State = {\n    empty: true,\n    expansion: SidePanel.ExpansionState.collapsed,\n    pendingUpdate: Promise.resolve()\n  };\n  @inject(ContextKeyService)\n  protected readonly contextKeyService: ContextKeyService;\n  protected readonly onDidAddWidgetEmitter = new Emitter<Widget>();\n  readonly onDidAddWidget = this.onDidAddWidgetEmitter.event;\n  protected readonly onDidChangeActiveWidgetEmitter = new Emitter<FocusTracker.IChangedArgs<Widget>>();\n  readonly onDidChangeActiveWidget = this.onDidChangeActiveWidgetEmitter.event;\n\n  protected readonly onDidChangeCurrentWidgetEmitter = new Emitter<FocusTracker.IChangedArgs<Widget>>();\n  readonly onDidChangeCurrentWidget = this.onDidChangeCurrentWidgetEmitter.event;\n\n  protected readonly onDidRemoveWidgetEmitter = new Emitter<Widget>();\n  readonly onDidRemoveWidget = this.onDidRemoveWidgetEmitter.event;\n  protected readonly toDisposeOnActiveChanged = new DisposableCollection();\n  private readonly tracker = new FocusTracker<Widget>();\n  private readonly activationTimeout = 2000;\n  private readonly toDisposeOnActivationCheck = new DisposableCollection();\n\n  /**\n   * Construct a new application shell.\n   */\n  constructor(\n      // @inject(DockPanelRendererFactory) protected dockPanelRendererFactory: () => DockPanelRenderer,\n      @inject(StatusBarImpl) protected readonly statusBar: StatusBarImpl,\n      @inject(SidePanelHandlerFactory) sidePanelHandlerFactory: () => SidePanelHandler,\n      @inject(FrontendApplicationStateService) protected readonly applicationStateService: FrontendApplicationStateService,\n      @inject(SplitPositionHandler) protected splitPositionHandler: SplitPositionHandler,\n      @inject(ApplicationShellOptions) @optional() options: RecursivePartial<ApplicationShell.Options> = {},\n  ) {\n    super();\n    this.addClass(APPLICATION_SHELL_CLASS);\n    this.id = 'tart-app-shell';\n\n    // Merge the user-defined application options with the default options\n    this.options = {\n      bottomPanel: {\n        ...ApplicationShell.DEFAULT_OPTIONS.bottomPanel,\n        ...options?.bottomPanel || {}\n      },\n      leftPanel: {\n        ...ApplicationShell.DEFAULT_OPTIONS.leftPanel,\n        ...options?.leftPanel\n      },\n      rightPanel: {\n        ...ApplicationShell.DEFAULT_OPTIONS.rightPanel,\n        ...options?.rightPanel || {}\n      }\n    };\n\n    this.mainPanel = this.createMainPanel();\n    this.topPanel = this.createTopPanel();\n    this.bottomPanel = this.createBottomPanel();\n\n    this.leftPanelHandler = sidePanelHandlerFactory();\n    this.leftPanelHandler.create('left', this.options.leftPanel);\n    this.leftPanelHandler.dockPanel.widgetAdded.connect((_, widget) => this.fireDidAddWidget(widget));\n    this.leftPanelHandler.dockPanel.widgetRemoved.connect((_, widget) => this.fireDidRemoveWidget(widget));\n\n    this.rightPanelHandler = sidePanelHandlerFactory();\n    this.rightPanelHandler.create('right', this.options.rightPanel);\n    this.rightPanelHandler.dockPanel.widgetAdded.connect((_, widget) => this.fireDidAddWidget(widget));\n    this.rightPanelHandler.dockPanel.widgetRemoved.connect((_, widget) => this.fireDidRemoveWidget(widget));\n\n    this.layout = this.createLayout();\n    this.tracker.currentChanged.connect(this.onCurrentChanged, this);\n    this.tracker.activeChanged.connect(this.onActiveChanged, this);\n  }\n\n  /**\n   * The tab bars contained in the main shell area. If there is no widget in the main area, the\n   * returned array is empty.\n   */\n  get mainAreaTabBars(): TabBar<Widget>[] {\n    return toArray(this.mainPanel.tabBars());\n  }\n\n  /**\n   * The tab bars contained in the bottom shell area. If there is no widget in the bottom area,\n   * the returned array is empty.\n   */\n  get bottomAreaTabBars(): TabBar<Widget>[] {\n    return toArray(this.bottomPanel.tabBars());\n  }\n\n  /**\n   * The tab bars contained in all shell areas.\n   */\n  get allTabBars(): TabBar<Widget>[] {\n    return [...this.mainAreaTabBars, ...this.bottomAreaTabBars, this.leftPanelHandler.tabBar, this.rightPanelHandler.tabBar];\n  }\n\n  /**\n   * The shell area name of the currently active tab, or undefined.\n   */\n  get currentTabArea(): ApplicationShell.Area | undefined {\n    const currentWidget = this.currentWidget;\n    if (currentWidget) {\n      return this.getAreaFor(currentWidget);\n    }\n  }\n\n  /**\n   * Returns a snapshot of all tracked widgets to allow async modifications.\n   */\n  get widgets(): ReadonlyArray<Widget> {\n    return [...this.tracker.widgets];\n  }\n\n  /**\n   * A promise that is resolved when all currently pending updates are done.\n   */\n  get pendingUpdates(): Promise<void> {\n    return Promise.all([\n      this.bottomPanelState.pendingUpdate,\n      this.leftPanelHandler.state.pendingUpdate,\n      this.rightPanelHandler.state.pendingUpdate\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ]) as Promise<any>;\n  }\n\n  /**\n   * The current widget in the application shell. The current widget is the last widget that\n   * was active and not yet closed. See the remarks to `activeWidget` on what _active_ means.\n   */\n  get currentWidget(): Widget | undefined {\n    return this.tracker.currentWidget || undefined;\n  }\n\n  /**\n   * Return the tab bar that has the currently active widget, or undefined.\n   */\n  get currentTabBar(): TabBar<Widget> | undefined {\n    const currentWidget = this.currentWidget;\n    if (currentWidget) {\n      return this.getTabBarFor(currentWidget);\n    }\n  }\n\n  /**\n   * The active widget in the application shell. The active widget is the one that has focus\n   * (either the widget itself or any of its contents).\n   *\n   * _Note:_ Focus is taken by a widget through the `onActivateRequest` method. It is up to the\n   * widget implementation which DOM element will get the focus. The default implementation\n   * does not take any focus; in that case the widget is never returned by this property.\n   */\n  get activeWidget(): Widget | undefined {\n    return this.tracker.activeWidget || undefined;\n  }\n\n  /**\n   * Save the current widget if it is dirty.\n   */\n  async save(options?: SaveOptions): Promise<void> {\n    await Saveable.save(this.currentWidget, options);\n  }\n\n  /**\n   * The widgets contained in the given shell area.\n   */\n  getWidgets(area: ApplicationShell.Area): Widget[] {\n    switch (area) {\n      case 'main':\n        return toArray(this.mainPanel.widgets());\n      case 'top':\n        return toArray(this.topPanel.widgets);\n      case 'bottom':\n        return toArray(this.bottomPanel.widgets());\n      case 'left':\n        return toArray(this.leftPanelHandler.dockPanel.widgets());\n      case 'right':\n        return toArray(this.rightPanelHandler.dockPanel.widgets());\n      default:\n        throw new Error('Illegal argument: ' + area);\n    }\n  }\n\n  /**\n   * Find the widget that contains the given HTML element. The returned widget may be one\n   * that is managed by the application shell, or one that is embedded in another widget and\n   * not directly managed by the shell, or a tab bar.\n   */\n  findWidgetForElement(element: HTMLElement): Widget | undefined {\n    let widgetNode: HTMLElement | null = element;\n    while (widgetNode && !widgetNode.classList.contains('p-Widget')) {\n      widgetNode = widgetNode.parentElement;\n    }\n    if (widgetNode) {\n      return this.findWidgetForNode(widgetNode, this);\n    }\n    return undefined;\n  }\n\n  /**\n   * Finds the title widget from the tab-bar.\n   * @param tabBar used for providing an array of titles.\n   * @returns the selected title widget, else returns the currentTitle or undefined.\n   */\n  findTitle(tabBar: TabBar<Widget>, event?: Event): Title<Widget> | undefined {\n    if (event?.target instanceof HTMLElement) {\n      let tabNode: HTMLElement | null = event.target;\n      while (tabNode && !tabNode.classList.contains('p-TabBar-tab')) {\n        tabNode = tabNode.parentElement;\n      }\n      if (tabNode && tabNode.title) {\n        let title = tabBar.titles.find(t => t.caption === tabNode!.title);\n        if (title) {\n          return title;\n        }\n        title = tabBar.titles.find(t => t.label === tabNode!.title);\n        if (title) {\n          return title;\n        }\n      }\n    }\n    return tabBar.currentTitle || undefined;\n  }\n\n  /**\n   * Finds the tab-bar widget.\n   * @returns the selected tab-bar, else returns the currentTabBar.\n   */\n  findTabBar(event?: Event): TabBar<Widget> | undefined {\n    if (event?.target instanceof HTMLElement) {\n      const tabBar = this.findWidgetForElement(event.target);\n      if (tabBar instanceof TabBar) {\n        return tabBar;\n      }\n    }\n    return this.currentTabBar;\n  }\n\n  /**\n   *  @returns the widget whose title has been targeted by a DOM event on a tabbar, or undefined if none can be found.\n   */\n  findTargetedWidget(event?: Event): Widget | undefined {\n    if (event) {\n      const tab = this.findTabBar(event);\n      const title = tab && this.findTitle(tab, event);\n      return title && title.owner;\n    }\n  }\n\n  /**\n   * Add a widget to the application shell. The given widget must have a unique `id` property,\n   * which will be used as the DOM id.\n   *\n   * Widgets are removed from the shell by calling their `close` or `dispose` methods.\n   *\n   * Widgets added to the top area are not tracked regarding the _current_ and _active_ states.\n   */\n  async addWidget(widget: Widget, options: Readonly<ApplicationShell.WidgetOptions> = {}): Promise<void> {\n    if (!widget.id) {\n      console.error('Widgets added to the application shell must have a unique id property.');\n      return;\n    }\n    let ref: Widget | undefined = options.ref;\n    let area: ApplicationShell.Area = options.area || 'main';\n    if (!ref && (area === 'main' || area === 'bottom')) {\n      const tabBar = this.getTabBarFor(area);\n      ref = tabBar && tabBar.currentTitle && tabBar.currentTitle.owner || undefined;\n    }\n    // make sure that ref belongs to area\n    area = ref && this.getAreaFor(ref) || area;\n    const addOptions: DockPanel.IAddOptions = {};\n    if (ApplicationShell.isOpenToSideMode(options.mode)) {\n      const areaPanel = area === 'main' ? this.mainPanel : area === 'bottom' ? this.bottomPanel : undefined;\n      const sideRef = areaPanel && ref && (options.mode === 'open-to-left' ?\n          areaPanel.previousTabBarWidget(ref) :\n          areaPanel.nextTabBarWidget(ref));\n      if (sideRef) {\n        addOptions.ref = sideRef;\n      } else {\n        addOptions.ref = ref;\n        addOptions.mode = options.mode === 'open-to-left' ? 'split-left' : 'split-right';\n      }\n    } else {\n      addOptions.ref = ref;\n      addOptions.mode = options.mode;\n    }\n    const sidePanelOptions: SidePanel.WidgetOptions = {rank: options.rank};\n    switch (area) {\n      case 'main':\n        this.mainPanel.addWidget(widget, addOptions);\n        break;\n      case 'top':\n        this.topPanel.addWidget(widget);\n        break;\n      case 'bottom':\n        this.bottomPanel.addWidget(widget, addOptions);\n        break;\n      case 'left':\n        this.leftPanelHandler.addWidget(widget, sidePanelOptions);\n        break;\n      case 'right':\n        this.rightPanelHandler.addWidget(widget, sidePanelOptions);\n        break;\n      default:\n        throw new Error('Unexpected area: ' + options.area);\n    }\n    if (area !== 'top') {\n      this.track(widget);\n    }\n  }\n\n  /**\n   * Return the tab bar in the given shell area, or the tab bar that has the given widget, or undefined.\n   */\n  getTabBarFor(widgetOrArea: Widget | ApplicationShell.Area): TabBar<Widget> | undefined {\n    if (typeof widgetOrArea === 'string') {\n      switch (widgetOrArea) {\n        case 'main':\n          return this.mainPanel.currentTabBar;\n        case 'bottom':\n          return this.bottomPanel.currentTabBar;\n        case 'left':\n          return this.leftPanelHandler.tabBar;\n        case 'right':\n          return this.rightPanelHandler.tabBar;\n        default:\n          throw new Error('Illegal argument: ' + widgetOrArea);\n      }\n    }\n    const widget = this.toTrackedStack(widgetOrArea.id).pop();\n    if (!widget) {\n      return undefined;\n    }\n    const widgetTitle = widget.title;\n    const mainPanelTabBar = this.mainPanel.findTabBar(widgetTitle);\n    if (mainPanelTabBar) {\n      return mainPanelTabBar;\n    }\n    const bottomPanelTabBar = this.bottomPanel.findTabBar(widgetTitle);\n    if (bottomPanelTabBar) {\n      return bottomPanelTabBar;\n    }\n    const leftPanelTabBar = this.leftPanelHandler.tabBar;\n    if (ArrayExt.firstIndexOf(leftPanelTabBar.titles, widgetTitle) > -1) {\n      return leftPanelTabBar;\n    }\n    const rightPanelTabBar = this.rightPanelHandler.tabBar;\n    if (ArrayExt.firstIndexOf(rightPanelTabBar.titles, widgetTitle) > -1) {\n      return rightPanelTabBar;\n    }\n    return undefined;\n  }\n\n  /**\n   * Determine the name of the shell area where the given widget resides. The result is\n   * undefined if the widget does not reside directly in the shell.\n   */\n  getAreaFor(input: TabBar<Widget> | Widget): ApplicationShell.Area | undefined {\n    if (input instanceof TabBar) {\n      if (find(this.mainPanel.tabBars(), tb => tb === input)) {\n        return 'main';\n      }\n      if (find(this.bottomPanel.tabBars(), tb => tb === input)) {\n        return 'bottom';\n      }\n      if (this.leftPanelHandler.tabBar === input) {\n        return 'left';\n      }\n      if (this.rightPanelHandler.tabBar === input) {\n        return 'right';\n      }\n    }\n    const widget = this.toTrackedStack(input.id).pop();\n    if (!widget) {\n      return undefined;\n    }\n    const title = widget.title;\n    const mainPanelTabBar = this.mainPanel.findTabBar(title);\n    if (mainPanelTabBar) {\n      return 'main';\n    }\n    const bottomPanelTabBar = this.bottomPanel.findTabBar(title);\n    if (bottomPanelTabBar) {\n      return 'bottom';\n    }\n    if (ArrayExt.firstIndexOf(this.leftPanelHandler.tabBar.titles, title) > -1) {\n      return 'left';\n    }\n    if (ArrayExt.firstIndexOf(this.rightPanelHandler.tabBar.titles, title) > -1) {\n      return 'right';\n    }\n    return undefined;\n  }\n\n  /**\n   * Create an object that describes the current shell layout. This object may contain references\n   * to widgets; these need to be transformed before the layout can be serialized.\n   */\n  getLayoutData(): ApplicationShell.LayoutData {\n    return {\n      version: applicationShellLayoutVersion,\n      mainPanel: this.mainPanel.saveLayout(),\n      bottomPanel: {\n        config: this.bottomPanel.saveLayout(),\n        size: this.bottomPanel.isVisible ? this.getBottomPanelSize() : this.bottomPanelState.lastPanelSize,\n        expanded: this.isExpanded('bottom')\n      },\n      leftPanel: this.leftPanelHandler.getLayoutData(),\n      rightPanel: this.rightPanelHandler.getLayoutData(),\n      activeWidgetId: this.activeWidget ? this.activeWidget.id : undefined\n    };\n  }\n\n  /**\n   * Collapse the named side panel area. This makes sure that the panel is hidden,\n   * increasing the space that is available for other shell areas.\n   */\n  collapsePanel(area: ApplicationShell.Area): Promise<void> {\n    switch (area) {\n      case 'bottom':\n        return this.collapseBottomPanel();\n      case 'left':\n        return this.leftPanelHandler.collapse();\n      case 'right':\n        return this.rightPanelHandler.collapse();\n      default:\n        throw new Error('Area cannot be collapsed: ' + area);\n    }\n  }\n\n  /**\n   * Reveal a widget in the application shell. This makes the widget visible,\n   * but does not activate it.\n   *\n   * @returns the revealed widget if it was found\n   */\n  async revealWidget(id: string): Promise<Widget | undefined> {\n    const stack = this.toTrackedStack(id);\n    let current = stack.pop();\n    if (current && !this.doRevealWidget(current.id)) {\n      return undefined;\n    }\n    while (current && stack.length) {\n      const child = stack.pop()!;\n      if (ApplicationShell.TrackableWidgetProvider.is(current) && current.revealWidget) {\n        current = current.revealWidget(child.id);\n      } else {\n        current = child;\n      }\n    }\n    if (!current) {\n      return undefined;\n    }\n    await Promise.all([\n      waitForRevealed(current),\n      this.pendingUpdates\n    ]);\n    return current;\n  }\n\n  /**\n   * Expand the named side panel area. This makes sure that the panel is visible, even if there\n   * are no widgets in it. If the panel is already visible, nothing happens. If the panel is currently\n   * collapsed (see `collapsePanel`) and it contains widgets, the widgets are revealed that were\n   * visible before it was collapsed.\n   */\n  expandPanel(area: ApplicationShell.Area): void {\n    switch (area) {\n      case 'bottom':\n        this.expandBottomPanel();\n        break;\n      case 'left':\n        this.leftPanelHandler.expand();\n        break;\n      case 'right':\n        this.rightPanelHandler.expand();\n        break;\n      default:\n        throw new Error('Area cannot be expanded: ' + area);\n    }\n  }\n\n  /**\n   * Adjusts the size of the given area in the application shell.\n   *\n   * @param size the desired size of the panel in pixels.\n   * @param area the area to resize.\n   */\n  resize(size: number, area: ApplicationShell.Area): void {\n    switch (area) {\n      case 'bottom':\n        if (this.bottomPanel.isHidden) {\n          this.bottomPanelState.lastPanelSize = size;\n        } else {\n          this.setBottomPanelSize(size);\n        }\n        break;\n      case 'left':\n        this.leftPanelHandler.resize(size);\n        break;\n      case 'right':\n        this.rightPanelHandler.resize(size);\n        break;\n      default:\n        throw new Error('Area cannot be resized: ' + area);\n    }\n  }\n\n  /**\n   * Apply a shell layout that has been previously created with `getLayoutData`.\n   */\n  async setLayoutData(layoutData: ApplicationShell.LayoutData): Promise<void> {\n    const {mainPanel, bottomPanel, leftPanel, rightPanel, activeWidgetId} = layoutData;\n    if (leftPanel) {\n      this.leftPanelHandler.setLayoutData(leftPanel);\n      this.registerWithFocusTracker(leftPanel);\n    }\n    if (rightPanel) {\n      this.rightPanelHandler.setLayoutData(rightPanel);\n      this.registerWithFocusTracker(rightPanel);\n    }\n    // Proceed with the bottom panel once the side panels are set up\n    await Promise.all([this.leftPanelHandler.state.pendingUpdate, this.rightPanelHandler.state.pendingUpdate]);\n    if (bottomPanel) {\n      if (bottomPanel.config) {\n        this.bottomPanel.restoreLayout(bottomPanel.config);\n        this.registerWithFocusTracker(bottomPanel.config.main);\n      }\n      if (bottomPanel.size) {\n        this.bottomPanelState.lastPanelSize = bottomPanel.size;\n      }\n      if (bottomPanel.expanded) {\n        this.expandBottomPanel();\n      } else {\n        this.collapseBottomPanel();\n      }\n      this.refreshBottomPanelToggleButton();\n    }\n    // Proceed with the main panel once all others are set up\n    await this.bottomPanelState.pendingUpdate;\n    if (mainPanel) {\n      this.mainPanel.restoreLayout(mainPanel);\n      this.registerWithFocusTracker(mainPanel.main);\n    }\n    if (activeWidgetId) {\n      this.activateWidget(activeWidgetId);\n    }\n  }\n\n  /**\n   * Activate a widget in the application shell. This makes the widget visible and usually\n   * also assigns focus to it.\n   *\n   * _Note:_ Focus is taken by a widget through the `onActivateRequest` method. It is up to the\n   * widget implementation which DOM element will get the focus. The default implementation\n   * does not take any focus.\n   *\n   * @returns the activated widget if it was found\n   */\n  async activateWidget(id: string): Promise<Widget | undefined> {\n    const stack = this.toTrackedStack(id);\n    let current = stack.pop();\n    if (current && !this.doActivateWidget(current.id)) {\n      return undefined;\n    }\n    while (current && stack.length) {\n      const child = stack.pop()!;\n      if (ApplicationShell.TrackableWidgetProvider.is(current) && current.activateWidget) {\n        current = current.activateWidget(child.id);\n      } else {\n        child.activate();\n        current = child;\n      }\n    }\n    if (!current) {\n      return undefined;\n    }\n    await Promise.all([\n      this.waitForActivation(current.id),\n      waitForRevealed(current),\n      this.pendingUpdates\n    ]);\n    return current;\n  }\n\n  async closeWidget(id: string, options?: ApplicationShell.CloseOptions): Promise<Widget | undefined> {\n    // TODO handle save for composite widgets, i.e. the preference widget has 2 editors\n    const stack = this.toTrackedStack(id);\n    const current = stack.pop();\n    if (!current) {\n      return undefined;\n    }\n    let pendingClose;\n    if (SaveableWidget.is(current)) {\n      let shouldSave;\n      if (options && 'save' in options) {\n        shouldSave = () => options.save;\n      }\n      pendingClose = current.closeWithSaving({shouldSave});\n    } else {\n      current.close();\n      pendingClose = waitForClosed(current);\n    }\n    await Promise.all([\n      pendingClose,\n      this.pendingUpdates\n    ]);\n    return stack[0] || current;\n  }\n\n  /**\n   * Save all dirty widgets.\n   */\n  async saveAll(options?: SaveOptions): Promise<void> {\n    await Promise.all(this.tracker.widgets.map(widget => {\n      if (Saveable.isDirty(widget)) {\n        Saveable.save(widget, options);\n      }\n    }));\n  }\n\n  getWidgetById(id: string): Widget | undefined {\n    for (const widget of this.tracker.widgets) {\n      if (widget.id === id) {\n        return widget;\n      }\n    }\n    return undefined;\n  }\n\n  canToggleMaximized(): boolean {\n    const area = this.currentWidget && this.getAreaFor(this.currentWidget);\n    return area === 'main' || area === 'bottom';\n  }\n\n  toggleMaximized(): void {\n    const area = this.currentWidget && this.getAreaPanelFor(this.currentWidget);\n    if (area instanceof TartDockPanel && (area === this.mainPanel || area === this.bottomPanel)) {\n      area.toggleMaximized();\n    }\n  }\n\n  waitForActivation(id: string): Promise<void> {\n    if (this.activeWidget && this.activeWidget.id === id) {\n      return Promise.resolve();\n    }\n    return new Promise(resolve => {\n      const toDispose = this.onDidChangeActiveWidget(() => {\n        if (this.activeWidget && this.activeWidget.id === id) {\n          toDispose.dispose();\n          resolve();\n        }\n      });\n    });\n  }\n\n  activateNextTab(): boolean {\n    const current = this.currentTabBar;\n    if (current) {\n      const ci = current.currentIndex;\n      if (ci !== -1) {\n        if (ci < current.titles.length - 1) {\n          current.currentIndex += 1;\n          if (current.currentTitle) {\n            this.activateWidget(current.currentTitle.owner.id);\n          }\n          return true;\n        } else if (ci === current.titles.length - 1) {\n          return this.activateNextTabBar(current);\n        }\n      }\n    }\n    return false;\n  }\n\n  activateNextTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): boolean {\n    const nextBar = this.nextTabBar(current);\n    if (nextBar) {\n      nextBar.currentIndex = 0;\n      if (nextBar.currentTitle) {\n        this.activateWidget(nextBar.currentTitle.owner.id);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  activatePreviousTab(): boolean {\n    const current = this.currentTabBar;\n    if (current) {\n      const ci = current.currentIndex;\n      if (ci !== -1) {\n        if (ci > 0) {\n          current.currentIndex -= 1;\n          if (current.currentTitle) {\n            this.activateWidget(current.currentTitle.owner.id);\n          }\n          return true;\n        } else if (ci === 0) {\n          return this.activatePreviousTabBar(current);\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Return the tab bar next to the given tab bar; return the given tab bar if there is no adjacent one.\n   */\n  nextTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): TabBar<Widget> | undefined {\n    let bars = toArray(this.bottomPanel.tabBars());\n    let len = bars.length;\n    let ci = ArrayExt.firstIndexOf(bars, current);\n    if (ci < 0) {\n      bars = toArray(this.mainPanel.tabBars());\n      len = bars.length;\n      ci = ArrayExt.firstIndexOf(bars, current);\n    }\n    if (ci >= 0 && ci < len - 1) {\n      return bars[ci + 1];\n    } else if (ci >= 0 && ci === len - 1) {\n      return bars[0];\n    } else {\n      return current;\n    }\n  }\n\n  /*\n* Activate the previous tab in the current tab bar.\n*/\n  activatePreviousTabInTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): boolean {\n    const index = this.previousTabIndexInTabBar(current);\n    if (!current || index === -1) {\n      return false;\n    }\n    current.currentIndex = index;\n    if (current.currentTitle) {\n      this.activateWidget(current.currentTitle.owner.id);\n    }\n    return true;\n  }\n\n  previousTabIndexInTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): number {\n    if (!current || current.titles.length <= 1) {\n      return -1;\n    }\n    const index = current.currentIndex;\n    if (index === -1) {\n      return -1;\n    }\n    if (index > 0) {\n      return index - 1;\n    }\n    return current.titles.length - 1;\n  }\n\n  activatePreviousTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): boolean {\n    const prevBar = this.previousTabBar(current);\n    if (!prevBar) {\n      return false;\n    }\n    const len = prevBar.titles.length;\n    prevBar.currentIndex = len - 1;\n    if (prevBar.currentTitle) {\n      this.activateWidget(prevBar.currentTitle.owner.id);\n    }\n    return true;\n  }\n\n  /**\n   * Return the tab bar previous to the given tab bar; return the given tab bar if there is no adjacent one.\n   */\n  previousTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): TabBar<Widget> | undefined {\n    const bars = toArray(this.mainPanel.tabBars());\n    const len = bars.length;\n    const ci = ArrayExt.firstIndexOf(bars, current);\n    if (ci > 0) {\n      return bars[ci - 1];\n    } else if (ci === 0) {\n      return bars[len - 1];\n    } else {\n      return current;\n    }\n  }\n\n  /*\n   * Activate the next tab in the current tab bar.\n   */\n  activateNextTabInTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): boolean {\n    const index = this.nextTabIndexInTabBar(current);\n    if (!current || index === -1) {\n      return false;\n    }\n    current.currentIndex = index;\n    if (current.currentTitle) {\n      this.activateWidget(current.currentTitle.owner.id);\n    }\n    return true;\n  }\n\n  nextTabIndexInTabBar(current: TabBar<Widget> | undefined = this.currentTabBar): number {\n    if (!current || current.titles.length <= 1) {\n      return -1;\n    }\n    const index = current.currentIndex;\n    if (index === -1) {\n      return -1;\n    }\n    if (index < current.titles.length - 1) {\n      return index + 1;\n    }\n    return 0;\n  }\n\n  /**\n   * Check whether the named side panel area is expanded (returns `true`) or collapsed (returns `false`).\n   */\n  isExpanded(area: ApplicationShell.Area): boolean {\n    switch (area) {\n      case 'bottom':\n        return this.bottomPanelState.expansion === SidePanel.ExpansionState.expanded;\n      case 'left':\n        return this.leftPanelHandler.state.expansion === SidePanel.ExpansionState.expanded;\n      case 'right':\n        return this.rightPanelHandler.state.expansion === SidePanel.ExpansionState.expanded;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Close all tabs or a selection of tabs in a specific part of the application shell.\n   *\n   * @param tabBarOrArea\n   *      Either the name of a shell area or a `TabBar` that is contained in such an area.\n   * @param filter\n   *      If undefined, all tabs are closed; otherwise only those tabs that match the filter are closed.\n   */\n  closeTabs(tabBarOrArea: TabBar<Widget> | ApplicationShell.Area,\n            filter?: (title: Title<Widget>, index: number) => boolean): void {\n    if (tabBarOrArea === 'main') {\n      this.mainAreaTabBars.forEach(tb => this.closeTabs(tb, filter));\n    } else if (tabBarOrArea === 'bottom') {\n      this.bottomAreaTabBars.forEach(tb => this.closeTabs(tb, filter));\n    } else if (typeof tabBarOrArea === 'string') {\n      const tabBar = this.getTabBarFor(tabBarOrArea);\n      if (tabBar) {\n        this.closeTabs(tabBar, filter);\n      }\n    } else if (tabBarOrArea) {\n      const titles = toArray(tabBarOrArea.titles);\n      for (let i = 0; i < titles.length; i++) {\n        if (filter === undefined || filter(titles[i], i)) {\n          titles[i].owner.close();\n        }\n      }\n    }\n  }\n\n  saveTabs(tabBarOrArea: TabBar<Widget> | ApplicationShell.Area,\n           filter?: (title: Title<Widget>, index: number) => boolean): void {\n    if (tabBarOrArea === 'main') {\n      this.mainAreaTabBars.forEach(tb => this.saveTabs(tb, filter));\n    } else if (tabBarOrArea === 'bottom') {\n      this.bottomAreaTabBars.forEach(tb => this.saveTabs(tb, filter));\n    } else if (typeof tabBarOrArea === 'string') {\n      const tabBar = this.getTabBarFor(tabBarOrArea);\n      if (tabBar) {\n        this.saveTabs(tabBar, filter);\n      }\n    } else if (tabBarOrArea) {\n      const titles = toArray(tabBarOrArea.titles);\n      for (let i = 0; i < titles.length; i++) {\n        if (filter === undefined || filter(titles[i], i)) {\n          const widget = titles[i].owner;\n          const saveable = Saveable.get(widget);\n          saveable?.save();\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the last active widget in the given shell area.\n   */\n  getCurrentWidget(area: ApplicationShell.Area): Widget | undefined {\n    let title: Title<Widget> | null | undefined;\n    switch (area) {\n      case 'main':\n        title = this.mainPanel.currentTitle;\n        break;\n      case 'bottom':\n        title = this.bottomPanel.currentTitle;\n        break;\n      case 'left':\n        title = this.leftPanelHandler.tabBar.currentTitle;\n        break;\n      case 'right':\n        title = this.rightPanelHandler.tabBar.currentTitle;\n        break;\n      default:\n        throw new Error('Illegal argument: ' + area);\n    }\n    return title ? title.owner : undefined;\n  }\n\n  protected fireDidAddWidget(widget: Widget): void {\n    this.onDidAddWidgetEmitter.fire(widget);\n  }\n\n  protected fireDidRemoveWidget(widget: Widget): void {\n    this.onDidRemoveWidgetEmitter.fire(widget);\n  }\n\n  @postConstruct()\n  protected init(): void {\n    // this.initSidebarVisibleKeyContext();\n    this.initFocusKeyContexts();\n    this.setTopPanelVisibility('');\n  }\n\n  /**\n   * Create the dock panel in the main shell area.\n   */\n  protected createMainPanel(): TartDockPanel {\n    // const renderer = this.dockPanelRendererFactory();\n    // renderer.tabBarClasses.push(MAIN_BOTTOM_AREA_CLASS);\n    // renderer.tabBarClasses.push(MAIN_AREA_CLASS);\n    const dockPanel = new TartDockPanel({\n      mode: 'multiple-document',\n      spacing: 0,\n    });\n    dockPanel.id = MAIN_AREA_ID;\n    return dockPanel;\n  }\n\n  /**\n   * Create the dock panel in the bottom shell area.\n   */\n  protected createBottomPanel(): TartDockPanel {\n    const dockPanel = new TartDockPanel({\n      mode: 'multiple-document',\n      spacing: 0,\n    });\n    dockPanel.id = BOTTOM_AREA_ID;\n    dockPanel.widgetAdded.connect((sender, widget) => {\n      this.refreshBottomPanelToggleButton();\n    });\n    dockPanel.widgetRemoved.connect((sender, widget) => {\n      if (sender.isEmpty) {\n        this.collapseBottomPanel();\n      }\n      this.refreshBottomPanelToggleButton();\n    }, this);\n    dockPanel.node.addEventListener('p-dragenter', event => {\n      // Make sure that the main panel hides its overlay when the bottom panel is expanded\n      this.mainPanel.overlay.hide(0);\n    });\n    dockPanel.hide();\n    dockPanel.widgetAdded.connect((_, widget) => this.fireDidAddWidget(widget));\n    dockPanel.widgetRemoved.connect((_, widget) => this.fireDidRemoveWidget(widget));\n    return dockPanel;\n  }\n\n  /**\n   * Create the top panel, which is used to hold the main menu.\n   */\n  protected createTopPanel(): Panel {\n    const topPanel = new Panel();\n    topPanel.id = 'tart-top-panel';\n    topPanel.hide();\n    return topPanel;\n  }\n\n  /**\n   * Create a box layout to assemble the application shell layout.\n   */\n  protected createBoxLayout(widgets: Widget[], stretch?: number[], options?: BoxPanel.IOptions): BoxLayout {\n    const boxLayout = new BoxLayout(options);\n    for (let i = 0; i < widgets.length; i++) {\n      if (stretch !== undefined && i < stretch.length) {\n        BoxPanel.setStretch(widgets[i], stretch[i]);\n      }\n      boxLayout.addWidget(widgets[i]);\n    }\n    return boxLayout;\n  }\n\n  /**\n   * Create a split layout to assemble the application shell layout.\n   */\n  protected createSplitLayout(widgets: Widget[], stretch?: number[], options?: Partial<SplitLayout.IOptions>): SplitLayout {\n    let optParam: SplitLayout.IOptions = {renderer: SplitPanel.defaultRenderer,};\n    if (options) {\n      optParam = {...optParam, ...options};\n    }\n    const splitLayout = new SplitLayout(optParam);\n    for (let i = 0; i < widgets.length; i++) {\n      if (stretch !== undefined && i < stretch.length) {\n        SplitPanel.setStretch(widgets[i], stretch[i]);\n      }\n      splitLayout.addWidget(widgets[i]);\n    }\n    return splitLayout;\n  }\n\n  /**\n   * Track the given widget so it is considered in the `current` and `active` state of the shell.\n   */\n  protected track(widget: Widget): void {\n    if (this.tracker.widgets.indexOf(widget) !== -1) {\n      return;\n    }\n    this.tracker.add(widget);\n    this.checkActivation(widget);\n    Saveable.apply(widget);\n    if (ApplicationShell.TrackableWidgetProvider.is(widget)) {\n      for (const toTrack of widget.getTrackableWidgets()) {\n        this.track(toTrack);\n      }\n      if (widget.onDidChangeTrackableWidgets) {\n        widget.onDidChangeTrackableWidgets(widgets => widgets.forEach(w => this.track(w)));\n      }\n    }\n  }\n\n  protected initFocusKeyContexts(): void {\n    const sideBarFocus = this.contextKeyService.createKey('sideBarFocus', false);\n    const panelFocus = this.contextKeyService.createKey('panelFocus', false);\n    const updateFocusContextKeys = () => {\n      const area = this.activeWidget && this.getAreaFor(this.activeWidget);\n      sideBarFocus.set(area === 'left');\n      panelFocus.set(area === 'main');\n    };\n    updateFocusContextKeys();\n    this.activeChanged.connect(updateFocusContextKeys);\n  }\n\n  protected toTrackedStack(id: string): Widget[] {\n    const tracked = new Map<string, Widget>(this.tracker.widgets.map(w => [w.id, w] as [string, Widget]));\n    let current = tracked.get(id);\n    const stack: Widget[] = [];\n    while (current) {\n      if (tracked.has(current.id)) {\n        stack.push(current);\n      }\n      current = current.parent || undefined;\n    }\n    return stack;\n  }\n\n  protected setTopPanelVisibility(preference: string): void {\n    const hiddenPreferences = ['compact', 'hidden'];\n    this.topPanel.setHidden(hiddenPreferences.includes(preference));\n  }\n\n  /**\n   * Track all widgets that are referenced by the given layout data.\n   */\n  protected registerWithFocusTracker(data: DockLayout.ITabAreaConfig | DockLayout.ISplitAreaConfig | SidePanel.LayoutData | null): void {\n    if (data) {\n      if (data.type === 'tab-area') {\n        for (const widget of data.widgets) {\n          if (widget) {\n            this.track(widget);\n          }\n        }\n      } else if (data.type === 'split-area') {\n        for (const child of data.children) {\n          this.registerWithFocusTracker(child);\n        }\n      } else if (data.type === 'sidepanel' && data.items) {\n        for (const item of data.items) {\n          if (item.widget) {\n            this.track(item.widget);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Expand the bottom panel. See `expandPanel` regarding the exact behavior.\n   */\n  protected expandBottomPanel(): void {\n    const bottomPanel = this.bottomPanel;\n    if (bottomPanel.isHidden) {\n      let relativeSizes: number[] | undefined;\n      const parent = bottomPanel.parent;\n      if (parent instanceof SplitPanel) {\n        relativeSizes = parent.relativeSizes();\n      }\n      bottomPanel.show();\n      if (relativeSizes && parent instanceof SplitPanel) {\n        // Make sure that the expansion animation starts at the smallest possible size\n        parent.setRelativeSizes(relativeSizes);\n      }\n\n      let size: number | undefined;\n      if (bottomPanel.isEmpty) {\n        bottomPanel.node.style.minHeight = '0';\n        size = this.options.bottomPanel.emptySize;\n      } else if (this.bottomPanelState.lastPanelSize) {\n        size = this.bottomPanelState.lastPanelSize;\n      } else {\n        size = this.getDefaultBottomPanelSize();\n      }\n      if (size) {\n        this.bottomPanelState.expansion = SidePanel.ExpansionState.expanding;\n        this.setBottomPanelSize(size).then(() => {\n          if (this.bottomPanelState.expansion === SidePanel.ExpansionState.expanding) {\n            this.bottomPanelState.expansion = SidePanel.ExpansionState.expanded;\n          }\n        });\n      } else {\n        this.bottomPanelState.expansion = SidePanel.ExpansionState.expanded;\n      }\n    }\n  }\n\n  /**\n   * Determine the default size to apply when the bottom panel is expanded for the first time.\n   */\n  protected getDefaultBottomPanelSize(): number | undefined {\n    const parent = this.bottomPanel.parent;\n    if (parent && parent.isVisible) {\n      return parent.node.clientHeight * this.options.bottomPanel.initialSizeRatio;\n    }\n  }\n\n  /**\n   * Modify the height of the bottom panel. This implementation assumes that the container of the\n   * bottom panel is a `SplitPanel`.\n   */\n  protected setBottomPanelSize(size: number): Promise<void> {\n    const enableAnimation = this.applicationStateService.state === 'ready';\n    const options: SplitPositionOptions = {\n      side: 'bottom',\n      duration: enableAnimation ? this.options.bottomPanel.expandDuration : 0,\n      referenceWidget: this.bottomPanel\n    };\n    const promise = this.splitPositionHandler.setSidePanelSize(this.bottomPanel, size, options);\n    const result = new Promise<void>(resolve => {\n      // Resolve the resulting promise in any case, regardless of whether resizing was successful\n      promise.then(() => resolve(), () => resolve());\n    });\n    this.bottomPanelState.pendingUpdate = this.bottomPanelState.pendingUpdate.then(() => result);\n    return result;\n  }\n\n  /**\n   * Reveal top-level area widget.\n   */\n  protected doRevealWidget(id: string): Widget | undefined {\n    let widget = find(this.mainPanel.widgets(), w => w.id === id);\n    if (!widget) {\n      widget = find(this.bottomPanel.widgets(), w => w.id === id);\n      if (widget) {\n        this.expandBottomPanel();\n      }\n    }\n    if (widget) {\n      const tabBar = this.getTabBarFor(widget);\n      if (tabBar) {\n        tabBar.currentTitle = widget.title;\n      }\n      return widget;\n    }\n    widget = this.leftPanelHandler.expand(id);\n    if (widget) {\n      return widget;\n    }\n    return this.rightPanelHandler.expand(id);\n  }\n\n  /**\n   * Collapse the bottom panel. All contained widgets are hidden, but not closed.\n   * They can be restored by calling `expandBottomPanel`.\n   */\n  protected collapseBottomPanel(): Promise<void> {\n    const bottomPanel = this.bottomPanel;\n    if (bottomPanel.isHidden) {\n      return Promise.resolve();\n    }\n    if (this.bottomPanelState.expansion === SidePanel.ExpansionState.expanded) {\n      const size = this.getBottomPanelSize();\n      if (size) {\n        this.bottomPanelState.lastPanelSize = size;\n      }\n    }\n    this.bottomPanelState.expansion = SidePanel.ExpansionState.collapsed;\n    bottomPanel.hide();\n    return animationFrame();\n  }\n\n  /**\n   * Refresh the toggle button for the bottom panel. This implementation creates a status bar entry\n   * and refers to the command `core.toggle.bottom.panel`.\n   */\n  protected refreshBottomPanelToggleButton(): void {\n    if (this.bottomPanel.isEmpty) {\n      this.statusBar.removeElement(BOTTOM_PANEL_TOGGLE_ID);\n    } else {\n      const element: StatusBarEntry = {\n        text: '$(codicon-window)',\n        alignment: StatusBarAlignment.RIGHT,\n        tooltip: 'Toggle Bottom Panel',\n        command: 'core.toggle.bottom.panel',\n        priority: -1000\n      };\n      this.statusBar.setElement(BOTTOM_PANEL_TOGGLE_ID, element);\n    }\n  }\n\n  /**\n   * Activate top-level area widget.\n   */\n  protected doActivateWidget(id: string): Widget | undefined {\n    let widget = find(this.mainPanel.widgets(), w => w.id === id);\n    if (widget) {\n      this.mainPanel.activateWidget(widget);\n      return widget;\n    }\n    widget = find(this.bottomPanel.widgets(), w => w.id === id);\n    if (widget) {\n      this.expandBottomPanel();\n      this.bottomPanel.activateWidget(widget);\n      return widget;\n    }\n    widget = this.leftPanelHandler.activate(id);\n    if (widget) {\n      return widget;\n    }\n    widget = this.rightPanelHandler.activate(id);\n    if (widget) {\n      return widget;\n    }\n  }\n\n  protected getAreaPanelFor(input: Widget): DockPanel | undefined {\n    const widget = this.toTrackedStack(input.id).pop();\n    if (!widget) {\n      return undefined;\n    }\n    const title = widget.title;\n    const mainPanelTabBar = this.mainPanel.findTabBar(title);\n    if (mainPanelTabBar) {\n      return this.mainPanel;\n    }\n    const bottomPanelTabBar = this.bottomPanel.findTabBar(title);\n    if (bottomPanelTabBar) {\n      return this.bottomPanel;\n    }\n    if (ArrayExt.firstIndexOf(this.leftPanelHandler.tabBar.titles, title) > -1) {\n      return this.leftPanelHandler.dockPanel;\n    }\n    if (ArrayExt.firstIndexOf(this.rightPanelHandler.tabBar.titles, title) > -1) {\n      return this.rightPanelHandler.dockPanel;\n    }\n    return undefined;\n  }\n\n  /**\n   * Compute the current height of the bottom panel. This implementation assumes that the container\n   * of the bottom panel is a `SplitPanel`.\n   */\n  protected getBottomPanelSize(): number | undefined {\n    const parent = this.bottomPanel.parent;\n    if (parent instanceof SplitPanel && parent.isVisible) {\n      const index = parent.widgets.indexOf(this.bottomPanel) - 1;\n      if (index >= 0) {\n        const handle = parent.handles[index];\n        if (!handle.classList.contains('p-mod-hidden')) {\n          const parentHeight = parent.node.clientHeight;\n          return parentHeight - handle.offsetTop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Assemble the application shell layout. Override this method in order to change the arrangement\n   * of the main area and the side panels.\n   */\n  protected createLayout(): Layout {\n    const bottomSplitLayout = this.createSplitLayout(\n        [this.mainPanel, this.bottomPanel],\n        [1, 0],\n        {orientation: 'vertical', spacing: 0}\n    );\n    const panelForBottomArea = new SplitPanel({layout: bottomSplitLayout});\n    panelForBottomArea.id = 'tart-bottom-split-panel';\n\n    const leftRightSplitLayout = this.createSplitLayout(\n        [this.leftPanelHandler.container, panelForBottomArea, this.rightPanelHandler.container],\n        [0, 1, 0],\n        {orientation: 'horizontal', spacing: 0}\n    );\n    const panelForSideAreas = new SplitPanel({layout: leftRightSplitLayout});\n    panelForSideAreas.id = 'tart-left-right-split-panel';\n\n    return this.createBoxLayout(\n        [this.topPanel, panelForSideAreas, this.statusBar],\n        [0, 1, 0],\n        {direction: 'top-to-bottom', spacing: 0}\n    );\n  }\n\n  private findWidgetForNode(widgetNode: HTMLElement, widget: Widget): Widget | undefined {\n    if (widget.node === widgetNode) {\n      return widget;\n    }\n    let result: Widget | undefined;\n    each(widget.children(), child => {\n      result = this.findWidgetForNode(widgetNode, child);\n      return !result;\n    });\n    return result;\n  }\n\n  /**\n   * Focus is taken by a widget through the `onActivateRequest` method. It is up to the\n   * widget implementation which DOM element will get the focus. The default implementation\n   * of Widget does not take any focus. This method can help finding such problems by logging\n   * a warning in case a widget was explicitly activated, but did not trigger a change of the\n   * `activeWidget` property.\n   */\n  private checkActivation(widget: Widget): Widget {\n    const onActivateRequest = widget['onActivateRequest'].bind(widget);\n    widget['onActivateRequest'] = (msg: Message) => {\n      onActivateRequest(msg);\n      this.assertActivated(widget);\n    };\n    return widget;\n  }\n\n  private assertActivated(widget: Widget): void {\n    this.toDisposeOnActivationCheck.dispose();\n\n    const onDispose = () => this.toDisposeOnActivationCheck.dispose();\n    widget.disposed.connect(onDispose);\n    this.toDisposeOnActivationCheck.push(Disposable.create(() => widget.disposed.disconnect(onDispose)));\n\n    let start = 0;\n    const step: FrameRequestCallback = timestamp => {\n      if (document.activeElement && widget.node.contains(document.activeElement)) {\n        return;\n      }\n      if (!start) {\n        start = timestamp;\n      }\n      const delta = timestamp - start;\n      if (delta < this.activationTimeout) {\n        request = window.requestAnimationFrame(step);\n      } else {\n        console.warn(`Widget was activated, but did not accept focus after ${this.activationTimeout}ms: ${widget.id}`);\n      }\n    };\n    let request = window.requestAnimationFrame(step);\n    this.toDisposeOnActivationCheck.push(Disposable.create(() => window.cancelAnimationFrame(request)));\n  }\n\n  /**\n   * Handle a change to the current widget.\n   */\n  private onCurrentChanged(sender: FocusTracker<Widget>, args: FocusTracker.IChangedArgs<Widget>): void {\n    this.currentChanged.emit(args);\n    this.onDidChangeCurrentWidgetEmitter.fire(args);\n  }\n\n  /**\n   * Set the z-index of the given element and its ancestors to the value `z`.\n   */\n  private setZIndex(element: HTMLElement, z: string | null): void {\n    element.style.zIndex = z || '';\n    const parent = element.parentElement;\n    if (parent && parent !== this.node) {\n      this.setZIndex(parent, z);\n    }\n  }\n\n  /**\n   * Handle a change to the active widget.\n   */\n  private onActiveChanged(sender: FocusTracker<Widget>, args: FocusTracker.IChangedArgs<Widget>): void {\n    this.toDisposeOnActiveChanged.dispose();\n    const {newValue, oldValue} = args;\n    if (oldValue) {\n      let w: Widget | null = oldValue;\n      while (w) {\n        // Remove the mark of the previously active widget\n        w.title.className = w.title.className.replace(' tart-mod-active', '');\n        w = w.parent;\n      }\n      // Reset the z-index to the default\n      // eslint-disable-next-line no-null/no-null\n      this.setZIndex(oldValue.node, null);\n    }\n    if (newValue) {\n      let w: Widget | null = newValue;\n      while (w) {\n        // Mark the tab of the active widget\n        w.title.className += ' tart-mod-active';\n        w = w.parent;\n      }\n      // Reveal the title of the active widget in its tab bar\n      const tabBar = this.getTabBarFor(newValue);\n      if (tabBar instanceof ScrollableTabBar) {\n        const index = tabBar.titles.indexOf(newValue.title);\n        if (index >= 0) {\n          tabBar.revealTab(index);\n        }\n      }\n      const panel = this.getAreaPanelFor(newValue);\n      if (panel instanceof TartDockPanel) {\n        panel.markAsCurrent(newValue.title);\n      }\n      // Set the z-index so elements with `position: fixed` contained in the active widget are displayed correctly\n      this.setZIndex(newValue.node, '1');\n\n      // activate another widget if an active widget will be closed\n      const onCloseRequest = newValue['onCloseRequest'];\n      newValue['onCloseRequest'] = msg => {\n        const currentTabBar = this.currentTabBar;\n        if (currentTabBar) {\n          const recentlyUsedInTabBar = currentTabBar['_previousTitle'] as TabBar<Widget>['currentTitle'];\n          if (recentlyUsedInTabBar && recentlyUsedInTabBar.owner !== newValue) {\n            currentTabBar.currentIndex = ArrayExt.firstIndexOf(currentTabBar.titles, recentlyUsedInTabBar);\n            if (currentTabBar.currentTitle) {\n              this.activateWidget(currentTabBar.currentTitle.owner.id);\n            }\n          } else if (!this.activateNextTabInTabBar(currentTabBar)) {\n            if (!this.activatePreviousTabBar(currentTabBar)) {\n              this.activateNextTabBar(currentTabBar);\n            }\n          }\n        }\n        newValue['onCloseRequest'] = onCloseRequest;\n        newValue['onCloseRequest'](msg);\n      };\n      this.toDisposeOnActiveChanged.push(Disposable.create(() => newValue['onCloseRequest'] = onCloseRequest));\n    }\n    this.activeChanged.emit(args);\n    this.onDidChangeActiveWidgetEmitter.fire(args);\n  }\n\n}\n\n/**\n * The namespace for `ApplicationShell` class statics.\n */\nexport namespace ApplicationShell {\n  /**\n   * The areas of the application shell where widgets can reside.\n   */\n  export type Area = 'main' | 'top' | 'left' | 'right' | 'bottom';\n\n  /**\n   * The _side areas_ are those shell areas that can be collapsed and expanded,\n   * i.e. `left`, `right`, and `bottom`.\n   */\n  export function isSideArea(area?: string): area is 'left' | 'right' | 'bottom' {\n    return area === 'left' || area === 'right' || area === 'bottom';\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function isValidArea(area?: any): area is ApplicationShell.Area {\n    const areas = ['main', 'top', 'left', 'right', 'bottom'];\n    return (area !== undefined && typeof area === 'string' && areas.includes(area));\n  }\n\n  export interface Options extends Widget.IOptions {\n    bottomPanel: BottomPanelOptions;\n    leftPanel: SidePanel.Options;\n    rightPanel: SidePanel.Options;\n  }\n\n  export interface BottomPanelOptions extends SidePanel.Options {\n  }\n\n  /**\n   * The default values for application shell options.\n   */\n  export const DEFAULT_OPTIONS = Object.freeze(<Options>{\n    bottomPanel: Object.freeze(<BottomPanelOptions>{\n      emptySize: 140,\n      expandThreshold: 160,\n      expandDuration: 0,\n      initialSizeRatio: 0.382\n    }),\n    leftPanel: Object.freeze(<SidePanel.Options>{\n      emptySize: 140,\n      expandThreshold: 140,\n      expandDuration: 0,\n      initialSizeRatio: 0.191\n    }),\n    rightPanel: Object.freeze(<SidePanel.Options>{\n      emptySize: 140,\n      expandThreshold: 140,\n      expandDuration: 0,\n      initialSizeRatio: 0.191\n    })\n  });\n\n  /**\n   * Whether a widget should be opened to the side tab bar relatively to the reference widget.\n   */\n  export type OpenToSideMode = 'open-to-left' | 'open-to-right';\n\n\n  export function isOpenToSideMode(mode: OpenToSideMode | any): mode is OpenToSideMode {\n    return mode === 'open-to-left' || mode === 'open-to-right';\n  }\n\n  /**\n   * Data to save and load the application shell layout.\n   */\n  export interface LayoutData {\n    version?: string | ApplicationShellLayoutVersion,\n    mainPanel?: DockPanel.ILayoutConfig;\n    bottomPanel?: BottomPanelLayoutData;\n    leftPanel?: SidePanel.LayoutData;\n    rightPanel?: SidePanel.LayoutData;\n    activeWidgetId?: string;\n  }\n\n\n  export interface CloseOptions {\n    /**\n     * if optional then a user will be prompted\n     * if undefined then close will be canceled\n     * if true then will be saved on close\n     * if false then won't be saved on close\n     */\n    save?: boolean | undefined\n  }\n\n  /**\n   * Data to save and load the bottom panel layout.\n   */\n  export interface BottomPanelLayoutData {\n    config?: DockPanel.ILayoutConfig;\n    size?: number;\n    expanded?: boolean;\n  }\n\n\n  /**\n   * Options for adding a widget to the application shell.\n   */\n  export interface WidgetOptions extends SidePanel.WidgetOptions {\n    /**\n     * The area of the application shell where the widget will reside.\n     */\n    area?: Area;\n    /**\n     * The insertion mode for adding the widget.\n     *\n     * The default is `'tab-after'`.\n     */\n    mode?: DockLayout.InsertMode | OpenToSideMode\n    /**\n     * The reference widget for the insert location.\n     *\n     * The default is `undefined`.\n     */\n    ref?: Widget;\n  }\n\n  /**\n   * Exposes widgets which activation state should be tracked by shell.\n   */\n  export interface TrackableWidgetProvider {\n    readonly onDidChangeTrackableWidgets?: CommonEvent<Widget[]>\n\n    getTrackableWidgets(): Widget[]\n\n    /**\n     * Make visible and focus a trackable widget for the given id.\n     * If not implemented then `activate` request will be sent to a child widget directly.\n     */\n    activateWidget?(id: string): Widget | undefined;\n\n    /**\n     * Make visible a trackable widget for the given id.\n     * If not implemented then a widget should be always visible when an owner is visible.\n     */\n    revealWidget?(id: string): Widget | undefined;\n  }\n\n  export namespace TrackableWidgetProvider {\n    export function is(widget: object | undefined): widget is TrackableWidgetProvider {\n      return !!widget && 'getTrackableWidgets' in widget;\n    }\n  }\n\n}\n"]}