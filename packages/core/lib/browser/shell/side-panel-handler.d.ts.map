{"version":3,"sources":["browser/shell/side-panel-handler.ts"],"names":[],"mappings":"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","file":"../../../src/browser/shell/side-panel-handler.d.ts","sourcesContent":["import {BoxLayout, BoxPanel, DockPanel, Panel, PanelLayout, SplitPanel, TabBar, Title, Widget} from '@lumino/widgets';\nimport {SideTabBar, TabBarRenderer, TabBarRendererFactory} from './tab-bars';\nimport {AttachedProperty} from '@lumino/properties';\nimport {SidebarBottomMenuWidgetFactory, SidebarMenuWidget, SidebarTopMenuWidgetFactory} from './sidebar-menu-widget';\nimport {SidePanelToolbar} from './side-panel-toolbar';\nimport {TartDockPanel} from './tart-dock-panel';\nimport {SidebarTopMenuWidget} from './sidebar-top-menu-widget';\nimport {inject, injectable} from 'inversify';\nimport {MenuPath} from '../../common/menu';\nimport {find, map, some, toArray} from '@lumino/algorithm';\nimport {FrontendApplicationStateService} from '../frontend-application-state';\nimport {Disposable, DisposableCollection} from '../../common';\nimport {MimeData} from '@lumino/coreutils';\nimport {Drag} from '@lumino/dragdrop';\nimport {animationFrame} from '../browser';\nimport {SplitPositionHandler, SplitPositionOptions} from './split-panels';\nimport {SidebarBottomMenuWidget} from './sidebar-bottom-menu-widget';\nimport {TabBarToolbar, TabBarToolbarFactory, TabBarToolbarRegistry} from './tab-bar-toolbar';\nimport {ContextMenuRenderer} from '../context-menu-renderer';\n\n/** The class name added to the left and right area panels. */\nexport const LEFT_RIGHT_AREA_CLASS = 'tart-app-sides';\n\n/** The class name added to collapsed side panels. */\nconst COLLAPSED_CLASS = 'tart-mod-collapsed';\n\n/** Menu path for tab bars used throughout the application shell. */\nexport const SHELL_TABBAR_CONTEXT_MENU: MenuPath = ['shell-tabbar-context-menu'];\n\nexport const SidePanelHandlerFactory = Symbol('SidePanelHandlerFactory');\n\nexport const SIDE_PANEL_TOOLBAR_CONTEXT_MENU: MenuPath = ['SIDE_PANEL_TOOLBAR_CONTEXT_MENU'];\n\n@injectable()\nexport class SidePanelHandler {\n\n  /**\n   * A property that can be attached to widgets in order to determine the insertion index\n   * of their title in the tab bar.\n   */\n  protected static readonly rankProperty = new AttachedProperty<Widget, number | undefined>({\n    name: 'sidePanelRank',\n    create: () => undefined\n  });\n\n  /**\n   * The tab bar displays the titles of the widgets in the side panel. Visibility of the widgets\n   * is controlled entirely through tab selection: a widget is revealed by setting the `currentTitle`\n   * accordingly in the tab bar, and the panel is hidden by setting that property to `null`. The\n   * tab bar itself remains visible as long as there is at least one widget.\n   */\n  tabBar: SideTabBar;\n  /**\n   * The menu placed on the sidebar top.\n   * Displayed as icons.\n   * Open menus when on clicks.\n   */\n  topMenu: SidebarMenuWidget;\n  /**\n   * The menu placed on the sidebar bottom.\n   * Displayed as icons.\n   * Open menus when on clicks.\n   */\n  bottomMenu: SidebarMenuWidget;\n  /**\n   * A tool bar, which displays a title and widget specific command buttons.\n   */\n  toolBar: SidePanelToolbar;\n  /**\n   * The widget container is a dock panel in `single-document` mode, which means that the panel\n   * cannot be split.\n   */\n  dockPanel: TartDockPanel;\n  /**\n   * The panel that contains the tab bar and the dock panel. This one is hidden whenever the dock\n   * panel is empty.\n   */\n  container: Panel;\n  /**\n   * The current state of the side panel.\n   */\n  readonly state: SidePanel.State = {\n    empty: true,\n    expansion: SidePanel.ExpansionState.collapsed,\n    pendingUpdate: Promise.resolve()\n  };\n\n  /**\n   * The shell area where the panel is placed. This property should not be modified directly, but\n   * only by calling `create`.\n   */\n  protected side: 'left' | 'right';\n  /**\n   * Options that control the behavior of the side panel.\n   */\n  protected options: SidePanel.Options;\n\n  @inject(TabBarToolbarRegistry) protected tabBarToolBarRegistry: TabBarToolbarRegistry;\n  @inject(SidebarTopMenuWidgetFactory) protected sidebarTopWidgetFactory: () => SidebarTopMenuWidget;\n  @inject(TabBarToolbarFactory) protected tabBarToolBarFactory: () => TabBarToolbar;\n  @inject(TabBarRendererFactory) protected tabBarRendererFactory: () => TabBarRenderer;\n  @inject(SidebarBottomMenuWidgetFactory) protected sidebarBottomWidgetFactory: () => SidebarBottomMenuWidget;\n  @inject(SplitPositionHandler) protected splitPositionHandler: SplitPositionHandler;\n  @inject(FrontendApplicationStateService) protected readonly applicationStateService: FrontendApplicationStateService;\n\n  @inject(ContextMenuRenderer)\n  protected readonly contextMenuRenderer: ContextMenuRenderer;\n  protected readonly toDisposeOnCurrentTabChanged = new DisposableCollection();\n\n  /**\n   * Create the side bar and dock panel widgets.\n   */\n  create(side: 'left' | 'right', options: SidePanel.Options): void {\n    this.side = side;\n    this.options = options;\n    this.topMenu = this.createSidebarTopMenu();\n    this.tabBar = this.createSideBar();\n    this.bottomMenu = this.createSidebarBottomMenu();\n    this.toolBar = this.createToolbar();\n    this.dockPanel = this.createSidePanel();\n    this.container = this.createContainer();\n\n    this.refresh();\n  }\n\n  /**\n   * Sets the size of the side panel.\n   *\n   * @param size the desired size (width) of the panel in pixels.\n   */\n  resize(size: number): void {\n    if (this.dockPanel.isHidden) {\n      this.state.lastPanelSize = size;\n    } else {\n      this.setPanelSize(size);\n    }\n  }\n\n  /**\n   * Add a widget and its title to the dock panel and side bar.\n   *\n   * If the widget is already added, it will be moved.\n   */\n  addWidget(widget: Widget, options: SidePanel.WidgetOptions): void {\n    if (options.rank) {\n      SidePanelHandler.rankProperty.set(widget, options.rank);\n    }\n    this.dockPanel.addWidget(widget);\n  }\n\n  /**\n   * Collapse the sidebar so no items are expanded.\n   */\n  collapse(): Promise<void> {\n    if (this.tabBar.currentTitle) {\n      // eslint-disable-next-line no-null/no-null\n      this.tabBar.currentTitle = null;\n    } else {\n      this.refresh();\n    }\n    return animationFrame();\n  }\n\n  /**\n   * Refresh the visibility of the side bar and dock panel.\n   */\n  refresh(): void {\n    const container = this.container;\n    const parent = container.parent;\n    const tabBar = this.tabBar;\n    const dockPanel = this.dockPanel;\n    const isEmpty = tabBar.titles.length === 0;\n    const currentTitle = tabBar.currentTitle;\n    // eslint-disable-next-line no-null/no-null\n    const hideDockPanel = currentTitle === null;\n    let relativeSizes: number[] | undefined;\n\n    if (hideDockPanel) {\n      container.addClass(COLLAPSED_CLASS);\n      if (this.state.expansion === SidePanel.ExpansionState.expanded && !this.state.empty) {\n        // Update the lastPanelSize property\n        const size = this.getPanelSize();\n        if (size) {\n          this.state.lastPanelSize = size;\n        }\n      }\n      this.state.expansion = SidePanel.ExpansionState.collapsed;\n    } else {\n      container.removeClass(COLLAPSED_CLASS);\n      let size: number | undefined;\n      if (this.state.expansion !== SidePanel.ExpansionState.expanded) {\n        if (this.state.lastPanelSize) {\n          size = this.state.lastPanelSize;\n        } else {\n          size = this.getDefaultPanelSize();\n        }\n      }\n      if (size) {\n        // Restore the panel size to the last known size or the default size\n        this.state.expansion = SidePanel.ExpansionState.expanding;\n        if (parent instanceof SplitPanel) {\n          relativeSizes = parent.relativeSizes();\n        }\n        this.setPanelSize(size).then(() => {\n          if (this.state.expansion === SidePanel.ExpansionState.expanding) {\n            this.state.expansion = SidePanel.ExpansionState.expanded;\n          }\n        });\n      } else {\n        this.state.expansion = SidePanel.ExpansionState.expanded;\n      }\n    }\n    container.setHidden(isEmpty && hideDockPanel);\n    tabBar.setHidden(isEmpty);\n    dockPanel.setHidden(hideDockPanel);\n    this.state.empty = isEmpty;\n    if (currentTitle) {\n      dockPanel.selectWidget(currentTitle.owner);\n    }\n    if (relativeSizes && parent instanceof SplitPanel) {\n      // Make sure that the expansion animation starts at the smallest possible size\n      parent.setRelativeSizes(relativeSizes);\n    }\n  }\n\n  /**\n   * Create an object that describes the current side panel layout. This object may contain references\n   * to widgets; these need to be transformed before the layout can be serialized.\n   */\n  getLayoutData(): SidePanel.LayoutData {\n    const currentTitle = this.tabBar.currentTitle;\n    const items = toArray(map(this.tabBar.titles, title => <SidePanel.WidgetItem>{\n      widget: title.owner,\n      rank: SidePanelHandler.rankProperty.get(title.owner),\n      expanded: title === currentTitle\n    }));\n    // eslint-disable-next-line no-null/no-null\n    const size = currentTitle !== null ? this.getPanelSize() : this.state.lastPanelSize;\n    return {type: 'sidepanel', items, size};\n  }\n\n  /**\n   * Apply a side panel layout that has been previously created with `getLayoutData`.\n   */\n  setLayoutData(layoutData: SidePanel.LayoutData): void {\n    // eslint-disable-next-line no-null/no-null\n    this.tabBar.currentTitle = null;\n\n    let currentTitle: Title<Widget> | undefined;\n    if (layoutData.items) {\n      for (const {widget, rank, expanded} of layoutData.items) {\n        if (widget) {\n          if (rank) {\n            SidePanelHandler.rankProperty.set(widget, rank);\n          }\n          if (expanded) {\n            currentTitle = widget.title;\n          }\n          // Add the widgets directly to the tab bar in the same order as they are stored\n          this.tabBar.addTab(widget.title);\n        }\n      }\n    }\n    if (layoutData.size) {\n      this.state.lastPanelSize = layoutData.size;\n    }\n\n    // If the layout data contains an expanded item, update the currentTitle property\n    // This implies a refresh through the `currentChanged` signal\n    if (currentTitle) {\n      this.tabBar.currentTitle = currentTitle;\n    } else {\n      this.refresh();\n    }\n  }\n\n  /**\n   * Activate a widget residing in the side panel by ID.\n   *\n   * @returns the activated widget if it was found\n   */\n  activate(id: string): Widget | undefined {\n    const widget = this.expand(id);\n    if (widget) {\n      widget.activate();\n    }\n    return widget;\n  }\n\n  /**\n   * Expand a widget residing in the side panel by ID. If no ID is given and the panel is\n   * currently collapsed, the last active tab of this side panel is expanded. If no tab\n   * was expanded previously, the first one is taken.\n   *\n   * @returns the expanded widget if it was found\n   */\n  expand(id?: string): Widget | undefined {\n    if (id) {\n      const widget = find(this.dockPanel.widgets(), w => w.id === id);\n      if (widget) {\n        this.tabBar.currentTitle = widget.title;\n      }\n      return widget;\n    } else if (this.tabBar.currentTitle) {\n      return this.tabBar.currentTitle.owner;\n    } else if (this.tabBar.titles.length > 0) {\n      let index = this.state.lastActiveTabIndex;\n      if (!index) {\n        index = 0;\n      } else if (index >= this.tabBar.titles.length) {\n        index = this.tabBar.titles.length - 1;\n      }\n      const title = this.tabBar.titles[index];\n      this.tabBar.currentTitle = title;\n      return title.owner;\n    } else {\n      // Reveal the tab bar and dock panel even if there is no widget\n      // The next call to `refreshVisibility` will collapse them again\n      this.state.expansion = SidePanel.ExpansionState.expanding;\n      let relativeSizes: number[] | undefined;\n      const parent = this.container.parent;\n      if (parent instanceof SplitPanel) {\n        relativeSizes = parent.relativeSizes();\n      }\n      this.container.removeClass(COLLAPSED_CLASS);\n      this.container.show();\n      this.tabBar.show();\n      this.dockPanel.node.style.minWidth = '0';\n      this.dockPanel.show();\n      if (relativeSizes && parent instanceof SplitPanel) {\n        // Make sure that the expansion animation starts at zero size\n        parent.setRelativeSizes(relativeSizes);\n      }\n      this.setPanelSize(this.options.emptySize).then(() => {\n        if (this.state.expansion === SidePanel.ExpansionState.expanding) {\n          this.state.expansion = SidePanel.ExpansionState.expanded;\n        }\n      });\n    }\n  }\n\n  protected createSideBar(): SideTabBar {\n    const side = this.side;\n    const tabBarRenderer = this.tabBarRendererFactory();\n    const sideBar = new SideTabBar({\n      // Tab bar options\n      orientation: side === 'left' || side === 'right' ? 'vertical' : 'horizontal',\n      insertBehavior: 'none',\n      removeBehavior: 'select-previous-tab',\n      allowDeselect: false,\n      tabsMovable: true,\n      renderer: tabBarRenderer,\n      // Scroll bar options\n      handlers: ['drag-thumb', 'keyboard', 'wheel', 'touch'],\n      useBothWheelAxes: true,\n      scrollYMarginOffset: 8,\n      suppressScrollX: true\n    });\n    tabBarRenderer.tabBar = sideBar;\n    sideBar.disposed.connect(() => tabBarRenderer.dispose());\n    tabBarRenderer.contextMenuPath = SHELL_TABBAR_CONTEXT_MENU;\n    sideBar.addClass('tart-app-' + side);\n    sideBar.addClass(LEFT_RIGHT_AREA_CLASS);\n\n    sideBar.tabAdded.connect((sender, {title}) => {\n      const widget = title.owner;\n      if (!some(this.dockPanel.widgets(), w => w === widget)) {\n        this.dockPanel.addWidget(widget);\n      }\n    }, this);\n    sideBar.tabActivateRequested.connect((sender, {title}) => title.owner.activate());\n    sideBar.tabCloseRequested.connect((sender, {title}) => title.owner.close());\n    sideBar.collapseRequested.connect(() => this.collapse(), this);\n    sideBar.currentChanged.connect(this.onCurrentTabChanged, this);\n    sideBar.tabDetachRequested.connect(this.onTabDetachRequested, this);\n    return sideBar;\n  }\n\n  protected createSidebarTopMenu(): SidebarTopMenuWidget {\n    return this.createSidebarMenu(this.sidebarTopWidgetFactory);\n  }\n\n  protected createSidebarMenu<T extends SidebarMenuWidget>(factory: () => T): T {\n    const menu = factory();\n    menu.addClass('tart-sidebar-menu');\n    return menu;\n  }\n\n  protected createSidebarBottomMenu(): SidebarBottomMenuWidget {\n    return this.createSidebarMenu(this.sidebarBottomWidgetFactory);\n  }\n\n  protected createToolbar(): SidePanelToolbar {\n    const toolbar = new SidePanelToolbar(this.tabBarToolBarRegistry, this.tabBarToolBarFactory, this.side);\n    toolbar.onContextMenu(e => this.showContextMenu(e));\n    return toolbar;\n  }\n\n  protected showContextMenu(e: MouseEvent): void {\n    const title = this.tabBar.currentTitle;\n    if (!title) {\n      return;\n    }\n    e.stopPropagation();\n    e.preventDefault();\n\n    this.contextMenuRenderer.render({\n      args: [title.owner],\n      menuPath: SIDE_PANEL_TOOLBAR_CONTEXT_MENU,\n      anchor: e\n    });\n  }\n\n  protected createContainer(): Panel {\n    const contentBox = new BoxLayout({direction: 'top-to-bottom', spacing: 0});\n    BoxPanel.setStretch(this.toolBar, 0);\n    contentBox.addWidget(this.toolBar);\n    BoxPanel.setStretch(this.dockPanel, 1);\n    contentBox.addWidget(this.dockPanel);\n    const contentPanel = new BoxPanel({layout: contentBox});\n\n    const side = this.side;\n    let direction: BoxLayout.Direction;\n    switch (side) {\n      case 'left':\n        direction = 'left-to-right';\n        break;\n      case 'right':\n        direction = 'right-to-left';\n        break;\n      default:\n        throw new Error('Illegal argument: ' + side);\n    }\n    const containerLayout = new BoxLayout({direction, spacing: 0});\n    const sidebarContainerLayout = new PanelLayout();\n    const sidebarContainer = new Panel({layout: sidebarContainerLayout});\n    sidebarContainer.addClass('tart-app-sidebar-container');\n    sidebarContainerLayout.addWidget(this.topMenu);\n    sidebarContainerLayout.addWidget(this.tabBar);\n    sidebarContainerLayout.addWidget(this.bottomMenu);\n\n    BoxPanel.setStretch(sidebarContainer, 0);\n    BoxPanel.setStretch(contentPanel, 1);\n    containerLayout.addWidget(sidebarContainer);\n    containerLayout.addWidget(contentPanel);\n    const boxPanel = new BoxPanel({layout: containerLayout});\n    boxPanel.id = 'tart-' + side + '-content-panel';\n    return boxPanel;\n  }\n\n  protected createSidePanel(): TartDockPanel {\n    const sidePanel = new TartDockPanel({\n      mode: 'single-document'\n    });\n    sidePanel.id = 'tart-' + this.side + '-side-panel';\n    sidePanel.addClass('tart-side-panel');\n\n    sidePanel.widgetActivated.connect((sender, widget) => {\n      this.tabBar.currentTitle = widget.title;\n    }, this);\n    sidePanel.widgetAdded.connect(this.onWidgetAdded, this);\n    sidePanel.widgetRemoved.connect(this.onWidgetRemoved, this);\n    return sidePanel;\n  }\n\n  /*\n   * Handle the `widgetAdded` signal from the dock panel. The widget's title is inserted into the\n   * tab bar according to the `rankProperty` value that may be attached to the widget.\n   */\n  protected onWidgetAdded(sender: DockPanel, widget: Widget): void {\n    const titles = this.tabBar.titles;\n    if (!find(titles, t => t.owner === widget)) {\n      const rank = SidePanelHandler.rankProperty.get(widget);\n      let index = titles.length;\n      if (rank !== undefined) {\n        for (let i = index - 1; i >= 0; i--) {\n          const r = SidePanelHandler.rankProperty.get(titles[i].owner);\n          if (r !== undefined && r > rank) {\n            index = i;\n          }\n        }\n      }\n      this.tabBar.insertTab(index, widget.title);\n      this.refresh();\n    }\n  }\n\n  /*\n   * Handle the `widgetRemoved` signal from the dock panel. The widget's title is also removed\n   * from the tab bar.\n   */\n  protected onWidgetRemoved(sender: DockPanel, widget: Widget): void {\n    this.tabBar.removeTab(widget.title);\n    this.refresh();\n  }\n\n  /**\n   * Determine the default size to apply when the panel is expanded for the first time.\n   */\n  protected getDefaultPanelSize(): number | undefined {\n    const parent = this.container.parent;\n    if (parent && parent.isVisible) {\n      return parent.node.clientWidth * this.options.initialSizeRatio;\n    }\n  }\n\n  /**\n   * Modify the width of the panel. This implementation assumes that the parent of the panel\n   * container is a `SplitPanel`.\n   */\n  protected setPanelSize(size: number): Promise<void> {\n    const enableAnimation = this.applicationStateService.state === 'ready';\n    const options: SplitPositionOptions = {\n      side: this.side,\n      duration: enableAnimation ? this.options.expandDuration : 0,\n      referenceWidget: this.dockPanel\n    };\n    const promise = this.splitPositionHandler.setSidePanelSize(this.container, size, options);\n    const result = new Promise<void>(resolve => {\n      // Resolve the resulting promise in any case, regardless of whether resizing was successful\n      promise.then(() => resolve(), () => resolve());\n    });\n    this.state.pendingUpdate = this.state.pendingUpdate.then(() => result);\n    return result;\n  }\n\n  /**\n   * Compute the current width of the panel. This implementation assumes that the parent of\n   * the panel container is a `SplitPanel`.\n   */\n  protected getPanelSize(): number | undefined {\n    const parent = this.container.parent;\n    if (parent instanceof SplitPanel && parent.isVisible) {\n      const index = parent.widgets.indexOf(this.container);\n      if (this.side === 'left') {\n        const handle = parent.handles[index];\n        if (!handle.classList.contains('p-mod-hidden')) {\n          return handle.offsetLeft;\n        }\n      } else if (this.side === 'right') {\n        const handle = parent.handles[index - 1];\n        if (!handle.classList.contains('p-mod-hidden')) {\n          const parentWidth = parent.node.clientWidth;\n          return parentWidth - handle.offsetLeft;\n        }\n      }\n    }\n  }\n\n  // should be a property to preserve fn identity\n  protected updateToolbarTitle = (): void => {\n    const currentTitle = this.tabBar && this.tabBar.currentTitle;\n    this.toolBar.toolbarTitle = currentTitle || undefined;\n  };\n\n  /**\n   * Handle a `currentChanged` signal from the sidebar. The side panel is refreshed so it displays\n   * the new selected widget.\n   */\n  protected onCurrentTabChanged(sender: SideTabBar, {\n    currentTitle,\n    currentIndex\n  }: TabBar.ICurrentChangedArgs<Widget>): void {\n    this.toDisposeOnCurrentTabChanged.dispose();\n    if (currentTitle) {\n      this.updateToolbarTitle();\n      currentTitle.changed.connect(this.updateToolbarTitle);\n      this.toDisposeOnCurrentTabChanged.push(Disposable.create(() => currentTitle.changed.disconnect(this.updateToolbarTitle)));\n    }\n    if (currentIndex >= 0) {\n      this.state.lastActiveTabIndex = currentIndex;\n      sender.revealTab(currentIndex);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Handle a `tabDetachRequested` signal from the sidebar. A drag is started so the widget can be\n   * moved to another application shell area.\n   */\n  protected onTabDetachRequested(sender: SideTabBar,\n                                 {title, tab, clientX, clientY}: TabBar.ITabDetachRequestedArgs<Widget>): void {\n    // Release the tab bar's hold on the mouse\n    sender.releaseMouse();\n\n    // Clone the selected tab and use that as drag image\n    const clonedTab = tab.cloneNode(true) as HTMLElement;\n    clonedTab.style.width = '';\n    clonedTab.style.height = '';\n    const label = clonedTab.getElementsByClassName('p-TabBar-tabLabel')[0] as HTMLElement;\n    label.style.width = '';\n    label.style.height = '';\n\n    // Create and start a drag to move the selected tab to another panel\n    const mimeData = new MimeData();\n    mimeData.setData('application/vnd.phosphor.widget-factory', () => title.owner);\n    const drag = new Drag({\n      mimeData,\n      dragImage: clonedTab,\n      proposedAction: 'move',\n      supportedActions: 'move',\n    });\n\n    tab.classList.add('p-mod-hidden');\n    drag.start(clientX, clientY).then(() => {\n      // The promise is resolved when the drag has ended\n      tab.classList.remove('p-mod-hidden');\n    });\n  }\n}\n\nexport namespace SidePanel {\n  /**\n   * Options that control the behavior of side panels.\n   */\n  export interface Options {\n    /**\n     * When a widget is being dragged and the distance of the mouse cursor to the shell border\n     * is below this threshold, the respective side panel is expanded so the widget can be dropped\n     * into that panel. Set this to `-1` to disable expanding the side panel while dragging.\n     */\n    expandThreshold: number;\n    /**\n     * The duration in milliseconds of the animation shown when a side panel is expanded.\n     * Set this to `0` to disable expansion animation.\n     */\n    expandDuration: number;\n    /**\n     * The ratio of the available shell size to use as initial size for the side panel.\n     */\n    initialSizeRatio: number\n    /**\n     * How large the panel should be when it's expanded and empty.\n     */\n    emptySize: number;\n  }\n\n  /**\n   * The options for adding a widget to a side panel\n   */\n  export interface WidgetOptions {\n    /**\n     * The rank order of the widget among its siblings\n     */\n    rank?: number;\n  }\n\n  /**\n   * Data structure used to save and restore the side panel layout.\n   */\n  export interface WidgetItem extends WidgetOptions {\n    /** Can be undefined in case the widget could not be restored. */\n    widget?: Widget;\n    expanded?: boolean;\n  }\n\n  export interface State {\n    /**\n     * Indicates whether the panel is empty.\n     */\n    empty: boolean;\n    /**\n     * Indicates whether the panel is expanded, collapsed, or in a transition between the two.\n     */\n    expansion: ExpansionState;\n    /**\n     * A promise that is resolved when the currently pending side panel updates are done.\n     */\n    pendingUpdate: Promise<void>;\n    /**\n     * The index of the last tab that was selected. When the panel is expanded, it tries to restore\n     * the tab selection to the previous state.\n     */\n    lastActiveTabIndex?: number;\n    /**\n     * The width or height of the panel before it was collapsed. When the panel is expanded, it tries\n     * to restore its size to this value.\n     */\n    lastPanelSize?: number;\n  }\n\n  /**\n   * Data to save and load the layout of a side panel.\n   */\n  export interface LayoutData {\n    type: 'sidepanel',\n    items?: WidgetItem[];\n    size?: number;\n  }\n\n  export enum ExpansionState {\n    collapsed = 'collapsed',\n    expanding = 'expanding',\n    expanded = 'expanded',\n    collapsing = 'collapsing'\n  }\n}\n"]}