{"version":3,"sources":["browser/widget-manager.ts"],"names":[],"mappings":"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","file":"../../src/browser/widget-manager.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {Widget} from '@lumino/widgets';\nimport {ContributionProvider, Emitter, Event, MaybePromise, WaitUntilEvent} from '../common';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const WidgetFactory = Symbol('WidgetFactory');\n\n/**\n * A {@link WidgetFactory} is used to create new widgets. Factory-specific information (options) can be passed as serializable JSON data.\n * The common {@link WidgetManager} collects  `WidgetFactory` contributions and delegates to the corresponding factory when\n * a widget should be created or restored. To identify widgets the `WidgetManager` uses a description composed of the factory id and the options.\n * The `WidgetFactory` does support both, synchronous and asynchronous widget creation.\n *\n * ### Example usage\n *\n * ```typescript\n * export class MyWidget extends BaseWidget {\n * }\n *\n * @injectable()\n * export class MyWidgetFactory implements WidgetFactory {\n *     id = 'myWidgetFactory';\n *\n *     createWidget(): MaybePromise<Widget> {\n *         return new MyWidget();\n *    }\n * }\n * ```\n */\nexport interface WidgetFactory {\n\n  /**\n   * The factory id.\n   */\n  readonly id: string;\n\n  /**\n   * Creates a widget using the given options.\n   * @param options factory specific information as serializable JSON data.\n   *\n   * @returns the newly created widget or a promise of the widget\n   */\n  createWidget(options?: any): MaybePromise<Widget>;\n}\n\n/**\n * Representation of the `WidgetConstructionOptions`.\n * Defines a serializable description to create widgets.\n */\nexport interface WidgetConstructionOptions {\n  /**\n   * The id of the widget factory to use.\n   */\n  factoryId: string,\n\n  /**\n   * The widget factory specific information.\n   */\n  options?: any\n}\n\n/**\n * Representation of a `willCreateWidgetEvent`.\n */\nexport interface WillCreateWidgetEvent extends WaitUntilEvent {\n  /**\n   * The widget which will be created.\n   */\n  readonly widget: Widget;\n  /**\n   * The widget factory id.\n   */\n  readonly factoryId: string;\n}\n\n/**\n * Representation of a `didCreateWidgetEvent`.\n */\nexport interface DidCreateWidgetEvent {\n  /**\n   * The widget which was created.\n   */\n  readonly widget: Widget;\n  /**\n   * The widget factory id.\n   */\n  readonly factoryId: string;\n}\n\n/**\n * The {@link WidgetManager} is the common component responsible for creating and managing widgets. Additional widget factories\n * can be registered by using the {@link WidgetFactory} contribution point. To identify a widget, created by a factory, the factory id and\n * the creation options are used. This key is commonly referred to as `description` of the widget.\n */\n@injectable()\nexport class WidgetManager {\n\n  protected _cachedFactories: Map<string, WidgetFactory>;\n  protected readonly widgets = new Map<string, Widget>();\n  protected readonly widgetPromises = new Map<string, MaybePromise<Widget>>();\n  protected readonly pendingWidgetPromises = new Map<string, MaybePromise<Widget>>();\n\n  @inject(ContributionProvider) @named(WidgetFactory)\n  protected readonly factoryProvider: ContributionProvider<WidgetFactory>;\n\n  protected readonly onWillCreateWidgetEmitter = new Emitter<WillCreateWidgetEvent>();\n  /**\n   * An event can be used to participate in the widget creation.\n   * Listeners may not dispose the given widget.\n   */\n  readonly onWillCreateWidget: Event<WillCreateWidgetEvent> = this.onWillCreateWidgetEmitter.event;\n\n  protected readonly onDidCreateWidgetEmitter = new Emitter<DidCreateWidgetEvent>();\n\n  readonly onDidCreateWidget: Event<DidCreateWidgetEvent> = this.onDidCreateWidgetEmitter.event;\n\n  protected get factories(): Map<string, WidgetFactory> {\n    if (!this._cachedFactories) {\n      this._cachedFactories = new Map();\n      for (const factory of this.factoryProvider.getContributions()) {\n        if (factory.id) {\n          this._cachedFactories.set(factory.id, factory);\n        } else {\n          // this.logger.error('Invalid ID for factory: ' + factory + \". ID was: '\" + factory.id + \"'.\");\n        }\n      }\n    }\n    return this._cachedFactories;\n  }\n\n  /**\n   * Get the list of widgets created by the given widget factory.\n   * @param factoryId the widget factory id.\n   *\n   * @returns the list of widgets created by the factory with the given id.\n   */\n  getWidgets(factoryId: string): Widget[] {\n    const result: Widget[] = [];\n    for (const [key, widget] of this.widgets.entries()) {\n      if (this.fromKey(key).factoryId === factoryId) {\n        result.push(widget);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Try to get the existing widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns the widget if available, else `undefined`.\n   */\n  tryGetWidget<T extends Widget>(factoryId: string, options?: any): T | undefined {\n    const key = this.toKey({factoryId, options});\n    const existing = this.widgetPromises.get(key);\n    if (existing instanceof Widget) {\n      return existing as T;\n    }\n    return undefined;\n  }\n\n  /**\n   * Try to get the existing widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns A promise that resolves to the widget, if any exists. The promise may be pending, so be cautious when assuming that it will not reject.\n   */\n  tryGetPendingWidget<T extends Widget>(factoryId: string, options?: any): MaybePromise<T> | undefined {\n    const key = this.toKey({factoryId, options});\n    return this.doGetWidget(key);\n  }\n\n  /**\n   * Get the widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns a promise resolving to the widget if available, else `undefined`.\n   */\n  async getWidget<T extends Widget>(factoryId: string, options?: any): Promise<T | undefined> {\n    const key = this.toKey({factoryId, options});\n    const pendingWidget = this.doGetWidget<T>(key);\n    const widget = pendingWidget && await pendingWidget;\n    return widget;\n  }\n\n  /**\n   * Creates a new widget or returns the existing widget for the given description.\n   * @param factoryId the widget factory id.\n   * @param options the widget factory specific information.\n   *\n   * @returns a promise resolving to the widget.\n   */\n  async getOrCreateWidget<T extends Widget>(factoryId: string, options?: any): Promise<T> {\n    const key = this.toKey({factoryId, options});\n    const existingWidget = this.doGetWidget<T>(key);\n    if (existingWidget) {\n      return existingWidget;\n    }\n    const factory = this.factories.get(factoryId);\n    if (!factory) {\n      throw Error(\"No widget factory '\" + factoryId + \"' has been registered.\");\n    }\n    try {\n      const widgetPromise = factory.createWidget(options);\n      this.pendingWidgetPromises.set(key, widgetPromise);\n      const widget = await widgetPromise;\n      await WaitUntilEvent.fire(this.onWillCreateWidgetEmitter, {factoryId, widget});\n      this.widgetPromises.set(key, widgetPromise);\n      this.widgets.set(key, widget);\n      widget.disposed.connect(() => {\n        this.widgets.delete(key);\n        this.widgetPromises.delete(key);\n      });\n      this.onDidCreateWidgetEmitter.fire({factoryId, widget});\n      return widget as T;\n    } finally {\n      this.pendingWidgetPromises.delete(key);\n    }\n  }\n\n  /**\n   * Get the widget construction options.\n   * @param widget the widget.\n   *\n   * @returns the widget construction options if the widget was created through the manager, else `undefined`.\n   */\n  getDescription(widget: Widget): WidgetConstructionOptions | undefined {\n    for (const [key, aWidget] of this.widgets.entries()) {\n      if (aWidget === widget) {\n        return this.fromKey(key);\n      }\n    }\n    return undefined;\n  }\n\n  protected doGetWidget<T extends Widget>(key: string): MaybePromise<T> | undefined {\n    const pendingWidget = this.widgetPromises.get(key) ?? this.pendingWidgetPromises.get(key);\n    if (pendingWidget) {\n      return pendingWidget as MaybePromise<T>;\n    }\n    return undefined;\n  }\n\n  /**\n   * Convert the widget construction options to string.\n   * @param options the widget construction options.\n   *\n   * @returns the widget construction options represented as a string.\n   */\n  protected toKey(options: WidgetConstructionOptions): string {\n    return JSON.stringify(options);\n  }\n\n  /**\n   * Convert the key into the widget construction options object.\n   * @param key the key.\n   *\n   * @returns the widget construction options object.\n   */\n  protected fromKey(key: string): WidgetConstructionOptions {\n    return JSON.parse(key);\n  }\n\n}\n"]}