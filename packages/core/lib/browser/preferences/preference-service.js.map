{"version":3,"sources":["browser/preferences/preference-service.ts"],"names":[],"mappings":"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","file":"../../../src/browser/preferences/preference-service.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {deepFreeze, Disposable, DisposableCollection, Emitter, Event, unreachable} from '../../common';\nimport {Deferred} from '../../common/promise-util';\nimport {\n  PreferenceProvider,\n  PreferenceProviderDataChange,\n  PreferenceProviderDataChanges,\n  PreferenceResolveResult\n} from './preference-provider';\nimport {PreferenceSchemaProvider} from './preference-contribution';\nimport URI from '../../common/uri';\nimport {PreferenceScope} from './preference-scope';\nimport {PreferenceConfigurations} from './preference-configurations';\nimport {JSONExt, JSONValue} from '@lumino/coreutils';\nimport {OverridePreferenceName, PreferenceLanguageOverrideService} from './preference-language-override-service';\n\nexport {PreferenceScope};\n\n/**\n * Representation of a preference change. A preference value can be set to `undefined` for a specific scope.\n * This means that the value from a more general scope will be used.\n */\nexport interface PreferenceChange {\n  /**\n   * The name of the changed preference.\n   */\n  readonly preferenceName: string;\n  /**\n   * The new value of the changed preference.\n   */\n  readonly newValue?: any;\n  /**\n   * The old value of the changed preference.\n   */\n  readonly oldValue?: any;\n  /**\n   * The {@link PreferenceScope} of the changed preference.\n   */\n  readonly scope: PreferenceScope;\n\n  /**\n   * Tests wether the given resource is affected by the preference change.\n   * @param resourceUri the uri of the resource to test.\n   */\n  affects(resourceUri?: string): boolean;\n}\n\nexport class PreferenceChangeImpl implements PreferenceChange {\n  constructor(\n      private change: PreferenceProviderDataChange\n  ) {\n  }\n\n  get preferenceName(): string {\n    return this.change.preferenceName;\n  }\n\n  get newValue(): string {\n    return this.change.newValue;\n  }\n\n  get oldValue(): string {\n    return this.change.oldValue;\n  }\n\n  get scope(): PreferenceScope {\n    return this.change.scope;\n  }\n\n  // TODO add tests\n  affects(resourceUri?: string): boolean {\n    const resourcePath = resourceUri && new URI(resourceUri).path;\n    const domain = this.change.domain;\n    return !resourcePath || !domain || domain.some(uri => new URI(uri).path.relativity(resourcePath) >= 0);\n  }\n}\n\n/**\n * A key-value storage for {@link PreferenceChange}s. Used to aggregate multiple simultaneous preference changes.\n */\nexport interface PreferenceChanges {\n  [preferenceName: string]: PreferenceChange\n}\n\nexport const PreferenceService = Symbol('PreferenceService');\n\n/**\n * Service to manage preferences including, among others, getting and setting preference values as well\n * as listening to preference changes.\n *\n * Depending on your use case you might also want to look at {@link createPreferenceProxy} with which\n * you can easily create a typesafe schema-based interface for your preferences. Internally the proxy\n * uses the PreferenceService so both approaches are compatible.\n */\nexport interface PreferenceService extends Disposable {\n  /**\n   * Promise indicating whether the service successfully initialized.\n   */\n  readonly ready: Promise<void>;\n  /**\n   * Registers a callback which will be called whenever a preference is changed.\n   */\n  onPreferenceChanged: Event<PreferenceChange>;\n  /**\n   * Registers a callback which will be called whenever one or more preferences are changed.\n   */\n  onPreferencesChanged: Event<PreferenceChanges>;\n\n  /**\n   * Retrieve the stored value for the given preference.\n   *\n   * @param preferenceName the preference identifier.\n   *\n   * @returns the value stored for the given preference when it exists, `undefined` otherwise.\n   */\n  get<T>(preferenceName: string): T | undefined;\n\n  /**\n   * Retrieve the stored value for the given preference.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   *\n   * @returns the value stored for the given preference when it exists, otherwise the given default value.\n   */\n  get<T>(preferenceName: string, defaultValue: T): T;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns the value stored for the given preference and resourceUri when it exists, otherwise the given\n   * default value.\n   */\n  get<T>(preferenceName: string, defaultValue: T, resourceUri?: string): T;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns the value stored for the given preference and resourceUri when it exists, otherwise the given\n   * default value.\n   */\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined;\n\n  /**\n   * Sets the given preference to the given value.\n   *\n   * @param preferenceName the preference identifier.\n   * @param value the new value of the preference.\n   * @param scope the scope for which the value shall be set, i.e. user, workspace etc.\n   * When the folder scope is specified a resourceUri must be provided.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to store\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns a promise which resolves to `undefined` when setting the preference was successful. Otherwise it rejects\n   * with an error.\n   */\n  set(preferenceName: string, value: any, scope?: PreferenceScope, resourceUri?: string): Promise<void>;\n\n  /**\n   * Determines and applies the changes necessary to apply `value` to either the `resourceUri` supplied or the active session.\n   * If there is no setting for the `preferenceName`, the change will be applied in user scope.\n   * If there is a setting conflicting with the specified `value`, the change will be applied in the most specific scope with a conflicting value.\n   *\n   * @param preferenceName the identifier of the preference to modify.\n   * @param value the value to which to set the preference. `undefined` will reset the preference to its default value.\n   * @param resourceUri the uri of the resource to which the change is to apply. If none is provided, folder scope will be ignored.\n   */\n  updateValue(preferenceName: string, value: any, resourceUri?: string): Promise<void>\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri in all available scopes.\n   *\n   * @param preferenceName the preference identifier.\n   * @param resourceUri the uri of the resource for which the preference is stored.\n   *\n   * @return an object containing the value of the given preference for all scopes.\n   */\n  inspect<T extends JSONValue>(preferenceName: string, resourceUri?: string): PreferenceInspection<T> | undefined;\n\n  /**\n   * Returns a new preference identifier based on the given OverridePreferenceName.\n   *\n   * @param options the override specification.\n   *\n   * @returns the calculated string based on the given OverridePreferenceName.\n   */\n  overridePreferenceName(options: OverridePreferenceName): string;\n\n  /**\n   * Tries to split the given preference identifier into the original OverridePreferenceName attributes\n   * with which this identifier was created. Returns `undefined` if this is not possible, for example\n   * when the given preference identifier was not generated by `overridePreferenceName`.\n   *\n   * This method is checked when resolving preferences. Therefore together with \"overridePreferenceName\"\n   * this can be used to handle specialized preferences, e.g. \"[markdown].editor.autoIndent\" and \"editor.autoIndent\".\n   *\n   * @param preferenceName the preferenceName which might have been created via {@link PreferenceService.overridePreferenceName}.\n   *\n   * @returns the OverridePreferenceName which was used to create the given `preferenceName` if this was the case,\n   * `undefined` otherwise.\n   */\n  overriddenPreferenceName(preferenceName: string): OverridePreferenceName | undefined;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns an object containing the value stored for the given preference and resourceUri when it exists,\n   * otherwise the given default value. If determinable the object will also contain the uri of the configuration\n   * resource in which the preference was stored.\n   */\n  resolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T>;\n\n  /**\n   * Returns the uri of the configuration resource for the given scope and optional resource uri.\n   *\n   * @param scope the PreferenceScope to query for.\n   * @param resourceUri the optional uri of the resource-specific preference handling\n   * @param sectionName the optional preference section to query for.\n   *\n   * @returns the uri of the configuration resource for the given scope and optional resource uri it it exists,\n   * `undefined` otherwise.\n   */\n  getConfigUri(scope: PreferenceScope, resourceUri?: string, sectionName?: string): URI | undefined;\n}\n\n/**\n * Return type of the {@link PreferenceService.inspect} call.\n */\nexport interface PreferenceInspection<T = JSONValue> {\n  /**\n   * The preference identifier.\n   */\n  preferenceName: string,\n  /**\n   * Value in default scope.\n   */\n  defaultValue: T | undefined,\n  /**\n   * Value in user scope.\n   */\n  // globalValue: T | undefined,\n  /**\n   * Value in workspace scope.\n   */\n  // workspaceValue: T | undefined,\n  /**\n   * Value in folder scope.\n   */\n  // workspaceFolderValue: T | undefined,\n  /**\n   * The value that is active, i.e. the value set in the lowest scope available.\n   */\n  value: T | undefined;\n}\n\nexport type PreferenceInspectionScope = keyof Omit<PreferenceInspection<unknown>, 'preferenceName'>;\n\n/**\n * We cannot load providers directly in the case if they depend on `PreferenceService` somehow.\n * It allows to load them lazily after DI is configured.\n */\nexport const PreferenceProviderProvider = Symbol('PreferenceProviderProvider');\nexport type PreferenceProviderProvider = (scope: PreferenceScope, uri?: URI) => PreferenceProvider;\n\n@injectable()\nexport class PreferenceServiceImpl implements PreferenceService {\n\n  protected readonly onPreferenceChangedEmitter = new Emitter<PreferenceChange>();\n  readonly onPreferenceChanged = this.onPreferenceChangedEmitter.event;\n\n  protected readonly onPreferencesChangedEmitter = new Emitter<PreferenceChanges>();\n  readonly onPreferencesChanged = this.onPreferencesChangedEmitter.event;\n\n  protected readonly toDispose = new DisposableCollection(this.onPreferenceChangedEmitter, this.onPreferencesChangedEmitter);\n\n  @inject(PreferenceSchemaProvider)\n  protected readonly schema: PreferenceSchemaProvider;\n\n  @inject(PreferenceProviderProvider)\n  protected readonly providerProvider: PreferenceProviderProvider;\n\n  @inject(PreferenceConfigurations)\n  protected readonly configurations: PreferenceConfigurations;\n\n  @inject(PreferenceLanguageOverrideService)\n  protected readonly preferenceOverrideService: PreferenceLanguageOverrideService;\n\n  protected readonly preferenceProviders = new Map<PreferenceScope, PreferenceProvider>();\n  protected readonly _ready = new Deferred<void>();\n\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  has(preferenceName: string, resourceUri?: string): boolean {\n    return this.get(preferenceName, undefined, resourceUri) !== undefined;\n  }\n\n  get<T>(preferenceName: string): T | undefined;\n\n  get<T>(preferenceName: string, defaultValue: T): T;\n\n  get<T>(preferenceName: string, defaultValue: T, resourceUri: string): T;\n\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined;\n\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined {\n    return this.resolve<T>(preferenceName, defaultValue, resourceUri).value;\n  }\n\n  resolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T> {\n    const {value, configUri} = this.doResolve(preferenceName, defaultValue, resourceUri);\n    if (value === undefined) {\n      const overridden = this.overriddenPreferenceName(preferenceName);\n      if (overridden) {\n        return this.doResolve(overridden.preferenceName, defaultValue, resourceUri);\n      }\n    }\n    return {value, configUri};\n  }\n\n  async set(preferenceName: string, value: any, scope: PreferenceScope | undefined, resourceUri?: string): Promise<void> {\n    // const resolvedScope = scope ?? (!resourceUri ? PreferenceScope.Workspace : PreferenceScope.Folder);\n    // if (resolvedScope === PreferenceScope.Folder && !resourceUri) {\n    //     throw new Error('Unable to write to Folder Settings because no resource is provided.');\n    // }\n    // const provider = this.getProvider(resolvedScope);\n    // if (provider && await provider.setPreference(preferenceName, value, resourceUri)) {\n    return;\n    // }\n    // throw new Error(`Unable to write to ${PreferenceScope[resolvedScope]} Settings.`);\n  }\n\n  getBoolean(preferenceName: string): boolean | undefined;\n\n  getBoolean(preferenceName: string, defaultValue: boolean): boolean;\n\n  getBoolean(preferenceName: string, defaultValue: boolean, resourceUri: string): boolean;\n\n  getBoolean(preferenceName: string, defaultValue?: boolean, resourceUri?: string): boolean | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    return value !== null && value !== undefined ? !!value : defaultValue;\n  }\n\n  getString(preferenceName: string): string | undefined;\n\n  getString(preferenceName: string, defaultValue: string): string;\n\n  getString(preferenceName: string, defaultValue: string, resourceUri: string): string;\n\n  getString(preferenceName: string, defaultValue?: string, resourceUri?: string): string | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n    return value.toString();\n  }\n\n  getNumber(preferenceName: string): number | undefined;\n\n  getNumber(preferenceName: string, defaultValue: number): number;\n\n  getNumber(preferenceName: string, defaultValue: number, resourceUri: string): number;\n\n  getNumber(preferenceName: string, defaultValue?: number, resourceUri?: string): number | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n    if (typeof value === 'number') {\n      return value;\n    }\n    return Number(value);\n  }\n\n  inspect<T>(preferenceName: string, resourceUri?: string): PreferenceInspection<T> | undefined {\n    const defaultValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Default, resourceUri);\n    // const globalValue = this.inspectInScope<T>(preferenceName, PreferenceScope.User, resourceUri);\n    // const workspaceValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Workspace, resourceUri);\n    // const workspaceFolderValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Folder, resourceUri);\n\n    const valueApplied = defaultValue;\n    // const valueApplied = workspaceFolderValue ?? workspaceValue ?? globalValue ?? defaultValue;\n\n    return {preferenceName, defaultValue, value: valueApplied};\n    // return { preferenceName, defaultValue, globalValue, workspaceValue, workspaceFolderValue, value: valueApplied };\n  }\n\n  async updateValue(preferenceName: string, value: any, resourceUri?: string): Promise<void> {\n    const inspection = this.inspect<any>(preferenceName, resourceUri);\n    if (inspection) {\n      const scopesToChange = this.getScopesToChange(inspection, value);\n      const isDeletion = value === undefined\n          || (scopesToChange.length === 1 && JSONExt.deepEqual(value, inspection.defaultValue));\n\n      // const isDeletion = value === undefined\n      //     || (scopesToChange.length === 1 && scopesToChange[0] === PreferenceScope.User && JSONExt.deepEqual(value, inspection.defaultValue));\n      const effectiveValue = isDeletion ? undefined : value;\n      await Promise.all(scopesToChange.map(scope => this.set(preferenceName, effectiveValue, scope, resourceUri)));\n    }\n  }\n\n  overridePreferenceName(options: OverridePreferenceName): string {\n    return this.preferenceOverrideService.overridePreferenceName(options);\n  }\n\n  overriddenPreferenceName(preferenceName: string): OverridePreferenceName | undefined {\n    return this.preferenceOverrideService.overriddenPreferenceName(preferenceName);\n  }\n\n  getConfigUri(scope: PreferenceScope, resourceUri?: string, sectionName: string = this.configurations.getConfigName()): URI | undefined {\n    const provider = this.getProvider(scope);\n    if (!provider || !this.configurations.isAnyConfig(sectionName)) {\n      return undefined;\n    }\n    const configUri = provider.getConfigUri(resourceUri, sectionName);\n    if (configUri) {\n      return configUri;\n    }\n    return provider.getContainingConfigUri && provider.getContainingConfigUri(resourceUri, sectionName);\n  }\n\n  protected async initializeProviders(): Promise<void> {\n    try {\n      for (const scope of PreferenceScope.getScopes()) {\n        const provider = this.providerProvider(scope);\n        this.preferenceProviders.set(scope, provider);\n        this.toDispose.push(provider.onDidPreferencesChanged(changes =>\n            this.reconcilePreferences(changes)\n        ));\n        await provider.ready;\n      }\n      this._ready.resolve();\n    } catch (e) {\n      console.log('error');\n      console.log(e);\n      this._ready.reject(e);\n    }\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.toDispose.push(Disposable.create(() => this._ready.reject(new Error('preference service is disposed'))));\n    this.initializeProviders();\n  }\n\n  protected reconcilePreferences(changes: PreferenceProviderDataChanges): void {\n    const changesToEmit: PreferenceChanges = {};\n    const acceptChange = (change: PreferenceProviderDataChange) =>\n        this.getAffectedPreferenceNames(change, preferenceName =>\n            changesToEmit[preferenceName] = new PreferenceChangeImpl({...change, preferenceName})\n        );\n\n    for (const preferenceName of Object.keys(changes)) {\n      let change = changes[preferenceName];\n      if (change.newValue === undefined) {\n        const overridden = this.overriddenPreferenceName(change.preferenceName);\n        if (overridden) {\n          change = {\n            ...change, newValue: this.doGet(overridden.preferenceName)\n          };\n        }\n      }\n      // if (this.schema.isValidInScope(preferenceName, PreferenceScope.Folder)) {\n      //     acceptChange(change);\n      //     continue;\n      // }\n      for (const scope of PreferenceScope.getReversedScopes()) {\n        if (this.schema.isValidInScope(preferenceName, scope)) {\n          const provider = this.getProvider(scope);\n          if (provider) {\n            const value = provider.get(preferenceName);\n            if (scope > change.scope && value !== undefined) {\n              // preference defined in a more specific scope\n              break;\n            } else if (scope === change.scope && change.newValue !== undefined) {\n              // preference is changed into something other than `undefined`\n              acceptChange(change);\n            } else if (scope < change.scope && change.newValue === undefined && value !== undefined) {\n              // preference is changed to `undefined`, use the value from a more general scope\n              change = {\n                ...change,\n                newValue: value,\n                scope\n              };\n              acceptChange(change);\n            }\n          }\n        } else if (change.newValue === undefined && change.scope === PreferenceScope.Default) {\n          // preference is removed\n          acceptChange(change);\n          break;\n        }\n      }\n    }\n\n    // emit the changes\n    const changedPreferenceNames = Object.keys(changesToEmit);\n    if (changedPreferenceNames.length > 0) {\n      this.onPreferencesChangedEmitter.fire(changesToEmit);\n    }\n    changedPreferenceNames.forEach(preferenceName => this.onPreferenceChangedEmitter.fire(changesToEmit[preferenceName]));\n  }\n\n  protected getAffectedPreferenceNames(change: PreferenceProviderDataChange, accept: (affectedPreferenceName: string) => void): void {\n    accept(change.preferenceName);\n    for (const overridePreferenceName of this.schema.getOverridePreferenceNames(change.preferenceName)) {\n      if (!this.doHas(overridePreferenceName)) {\n        accept(overridePreferenceName);\n      }\n    }\n  }\n\n  protected getProvider(scope: PreferenceScope): PreferenceProvider | undefined {\n    return this.preferenceProviders.get(scope);\n  }\n\n  protected inspectInScope<T>(preferenceName: string, scope: PreferenceScope, resourceUri?: string): T | undefined {\n    const value = this.doInspectInScope<T>(preferenceName, scope, resourceUri);\n    if (value === undefined) {\n      const overridden = this.overriddenPreferenceName(preferenceName);\n      if (overridden) {\n        return this.doInspectInScope(overridden.preferenceName, scope, resourceUri);\n      }\n    }\n    return value;\n  }\n\n  protected getScopedValueFromInspection<T>(inspection: PreferenceInspection<T>, scope: PreferenceScope): T | undefined {\n    switch (scope) {\n      case PreferenceScope.Default:\n        return inspection.defaultValue;\n        // case PreferenceScope.User:\n        //     return inspection.globalValue;\n        // case PreferenceScope.Workspace:\n        //     return inspection.workspaceValue;\n        // case PreferenceScope.Folder:\n        //     return inspection.workspaceFolderValue;\n    }\n    unreachable(scope, 'Not all PreferenceScope enum variants handled.');\n  }\n\n  protected getScopesToChange(inspection: PreferenceInspection<any>, intendedValue: any): PreferenceScope[] {\n    if (JSONExt.deepEqual(inspection.value, intendedValue)) {\n      return [];\n    }\n\n    // Scopes in ascending order of scope breadth.\n    const allScopes = PreferenceScope.getReversedScopes();\n    // Get rid of Default scope. We can't set anything there.\n    allScopes.pop();\n\n    const isScopeDefined = (scope: PreferenceScope) => this.getScopedValueFromInspection(inspection, scope) !== undefined;\n\n    if (intendedValue === undefined) {\n      return allScopes.filter(isScopeDefined);\n    }\n\n    return [allScopes.find(isScopeDefined)];\n    // return [allScopes.find(isScopeDefined) ?? PreferenceScope.User];\n  }\n\n  protected doHas(preferenceName: string, resourceUri?: string): boolean {\n    return this.doGet(preferenceName, undefined, resourceUri) !== undefined;\n  }\n\n  protected doInspectInScope<T>(preferenceName: string, scope: PreferenceScope, resourceUri?: string): T | undefined {\n    const provider = this.getProvider(scope);\n    return provider && provider.get<T>(preferenceName, resourceUri);\n  }\n\n  protected doGet<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined {\n    return this.doResolve(preferenceName, defaultValue, resourceUri).value;\n  }\n\n  protected doResolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T> {\n    const result: PreferenceResolveResult<T> = {};\n    for (const scope of PreferenceScope.getScopes()) {\n      if (this.schema.isValidInScope(preferenceName, scope)) {\n        const provider = this.getProvider(scope);\n        if (provider) {\n          const {configUri, value} = provider.resolve<T>(preferenceName, resourceUri);\n          if (value !== undefined) {\n            result.configUri = configUri;\n            result.value = PreferenceProvider.merge(result.value as any, value as any) as any;\n          }\n        }\n      }\n    }\n    return {\n      configUri: result.configUri,\n      value: result.value !== undefined ? deepFreeze(result.value) : defaultValue\n    };\n  }\n}\n"]}