{"version":3,"sources":["browser/preferences/preference-service.ts"],"names":[],"mappings":"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","file":"../../../src/browser/preferences/preference-service.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {deepFreeze, Disposable, DisposableCollection, Emitter, Event, unreachable} from '../../common';\nimport {Deferred} from '../../common/promise-util';\nimport {\n  PreferenceProvider,\n  PreferenceProviderDataChange,\n  PreferenceProviderDataChanges,\n  PreferenceResolveResult\n} from './preference-provider';\nimport {PreferenceSchemaProvider} from './preference-contribution';\nimport URI from '../../common/uri';\nimport {PreferenceScope} from './preference-scope';\nimport {PreferenceConfigurations} from './preference-configurations';\nimport {JSONExt, JSONValue} from '@lumino/coreutils';\nimport {OverridePreferenceName, PreferenceLanguageOverrideService} from './preference-language-override-service';\n\nexport {PreferenceScope};\n\n/**\n * Representation of a preference change. A preference value can be set to `undefined` for a specific scope.\n * This means that the value from a more general scope will be used.\n */\nexport interface PreferenceChange {\n  /**\n   * The name of the changed preference.\n   */\n  readonly preferenceName: string;\n  /**\n   * The new value of the changed preference.\n   */\n  readonly newValue?: any;\n  /**\n   * The old value of the changed preference.\n   */\n  readonly oldValue?: any;\n  /**\n   * The {@link PreferenceScope} of the changed preference.\n   */\n  readonly scope: PreferenceScope;\n\n  /**\n   * Tests wether the given resource is affected by the preference change.\n   * @param resourceUri the uri of the resource to test.\n   */\n  affects(resourceUri?: string): boolean;\n}\n\nexport class PreferenceChangeImpl implements PreferenceChange {\n  constructor(\n      private change: PreferenceProviderDataChange\n  ) {\n  }\n\n  get preferenceName(): string {\n    return this.change.preferenceName;\n  }\n\n  get newValue(): string {\n    return this.change.newValue;\n  }\n\n  get oldValue(): string {\n    return this.change.oldValue;\n  }\n\n  get scope(): PreferenceScope {\n    return this.change.scope;\n  }\n\n  // TODO add tests\n  affects(resourceUri?: string): boolean {\n    const resourcePath = resourceUri && new URI(resourceUri).path;\n    const domain = this.change.domain;\n    return !resourcePath || !domain || domain.some(uri => new URI(uri).path.relativity(resourcePath) >= 0);\n  }\n}\n\n/**\n * A key-value storage for {@link PreferenceChange}s. Used to aggregate multiple simultaneous preference changes.\n */\nexport interface PreferenceChanges {\n  [preferenceName: string]: PreferenceChange\n}\n\nexport const PreferenceService = Symbol('PreferenceService');\n\n/**\n * Service to manage preferences including, among others, getting and setting preference values as well\n * as listening to preference changes.\n *\n * Depending on your use case you might also want to look at {@link createPreferenceProxy} with which\n * you can easily create a typesafe schema-based interface for your preferences. Internally the proxy\n * uses the PreferenceService so both approaches are compatible.\n */\nexport interface PreferenceService extends Disposable {\n  /**\n   * Promise indicating whether the service successfully initialized.\n   */\n  readonly ready: Promise<void>;\n  /**\n   * Registers a callback which will be called whenever a preference is changed.\n   */\n  onPreferenceChanged: Event<PreferenceChange>;\n  /**\n   * Registers a callback which will be called whenever one or more preferences are changed.\n   */\n  onPreferencesChanged: Event<PreferenceChanges>;\n\n  /**\n   * Retrieve the stored value for the given preference.\n   *\n   * @param preferenceName the preference identifier.\n   *\n   * @returns the value stored for the given preference when it exists, `undefined` otherwise.\n   */\n  get<T>(preferenceName: string): T | undefined;\n\n  /**\n   * Retrieve the stored value for the given preference.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   *\n   * @returns the value stored for the given preference when it exists, otherwise the given default value.\n   */\n  get<T>(preferenceName: string, defaultValue: T): T;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns the value stored for the given preference and resourceUri when it exists, otherwise the given\n   * default value.\n   */\n  get<T>(preferenceName: string, defaultValue: T, resourceUri?: string): T;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns the value stored for the given preference and resourceUri when it exists, otherwise the given\n   * default value.\n   */\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined;\n\n  /**\n   * Sets the given preference to the given value.\n   *\n   * @param preferenceName the preference identifier.\n   * @param value the new value of the preference.\n   * @param scope the scope for which the value shall be set, i.e. user, workspace etc.\n   * When the folder scope is specified a resourceUri must be provided.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to store\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns a promise which resolves to `undefined` when setting the preference was successful. Otherwise it rejects\n   * with an error.\n   */\n  set(preferenceName: string, value: any, scope?: PreferenceScope, resourceUri?: string): Promise<void>;\n\n  /**\n   * Determines and applies the changes necessary to apply `value` to either the `resourceUri` supplied or the active session.\n   * If there is no setting for the `preferenceName`, the change will be applied in user scope.\n   * If there is a setting conflicting with the specified `value`, the change will be applied in the most specific scope with a conflicting value.\n   *\n   * @param preferenceName the identifier of the preference to modify.\n   * @param value the value to which to set the preference. `undefined` will reset the preference to its default value.\n   * @param resourceUri the uri of the resource to which the change is to apply. If none is provided, folder scope will be ignored.\n   */\n  updateValue(preferenceName: string, value: any, resourceUri?: string): Promise<void>\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri in all available scopes.\n   *\n   * @param preferenceName the preference identifier.\n   * @param resourceUri the uri of the resource for which the preference is stored.\n   *\n   * @return an object containing the value of the given preference for all scopes.\n   */\n  inspect<T extends JSONValue>(preferenceName: string, resourceUri?: string): PreferenceInspection<T> | undefined;\n\n  /**\n   * Returns a new preference identifier based on the given OverridePreferenceName.\n   *\n   * @param options the override specification.\n   *\n   * @returns the calculated string based on the given OverridePreferenceName.\n   */\n  overridePreferenceName(options: OverridePreferenceName): string;\n\n  /**\n   * Tries to split the given preference identifier into the original OverridePreferenceName attributes\n   * with which this identifier was created. Returns `undefined` if this is not possible, for example\n   * when the given preference identifier was not generated by `overridePreferenceName`.\n   *\n   * This method is checked when resolving preferences. Therefore together with \"overridePreferenceName\"\n   * this can be used to handle specialized preferences, e.g. \"[markdown].editor.autoIndent\" and \"editor.autoIndent\".\n   *\n   * @param preferenceName the preferenceName which might have been created via {@link PreferenceService.overridePreferenceName}.\n   *\n   * @returns the OverridePreferenceName which was used to create the given `preferenceName` if this was the case,\n   * `undefined` otherwise.\n   */\n  overriddenPreferenceName(preferenceName: string): OverridePreferenceName | undefined;\n\n  /**\n   * Retrieve the stored value for the given preference and resourceUri.\n   *\n   * @param preferenceName the preference identifier.\n   * @param defaultValue the value to return when no value for the given preference is stored.\n   * @param resourceUri the uri of the resource for which the preference is stored. This used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns an object containing the value stored for the given preference and resourceUri when it exists,\n   * otherwise the given default value. If determinable the object will also contain the uri of the configuration\n   * resource in which the preference was stored.\n   */\n  resolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T>;\n\n  /**\n   * Returns the uri of the configuration resource for the given scope and optional resource uri.\n   *\n   * @param scope the PreferenceScope to query for.\n   * @param resourceUri the optional uri of the resource-specific preference handling\n   * @param sectionName the optional preference section to query for.\n   *\n   * @returns the uri of the configuration resource for the given scope and optional resource uri it it exists,\n   * `undefined` otherwise.\n   */\n  getConfigUri(scope: PreferenceScope, resourceUri?: string, sectionName?: string): URI | undefined;\n}\n\n/**\n * Return type of the {@link PreferenceService.inspect} call.\n */\nexport interface PreferenceInspection<T = JSONValue> {\n  /**\n   * The preference identifier.\n   */\n  preferenceName: string,\n  /**\n   * Value in default scope.\n   */\n  defaultValue: T | undefined,\n  /**\n   * Value in user scope.\n   */\n  // globalValue: T | undefined,\n  /**\n   * Value in workspace scope.\n   */\n  // workspaceValue: T | undefined,\n  /**\n   * Value in folder scope.\n   */\n  // workspaceFolderValue: T | undefined,\n  /**\n   * The value that is active, i.e. the value set in the lowest scope available.\n   */\n  value: T | undefined;\n}\n\nexport type PreferenceInspectionScope = keyof Omit<PreferenceInspection<unknown>, 'preferenceName'>;\n\n/**\n * We cannot load providers directly in the case if they depend on `PreferenceService` somehow.\n * It allows to load them lazily after DI is configured.\n */\nexport const PreferenceProviderProvider = Symbol('PreferenceProviderProvider');\nexport type PreferenceProviderProvider = (scope: PreferenceScope, uri?: URI) => PreferenceProvider;\n\n@injectable()\nexport class PreferenceServiceImpl implements PreferenceService {\n\n  protected readonly onPreferenceChangedEmitter = new Emitter<PreferenceChange>();\n  readonly onPreferenceChanged = this.onPreferenceChangedEmitter.event;\n\n  protected readonly onPreferencesChangedEmitter = new Emitter<PreferenceChanges>();\n  readonly onPreferencesChanged = this.onPreferencesChangedEmitter.event;\n\n  protected readonly toDispose = new DisposableCollection(this.onPreferenceChangedEmitter, this.onPreferencesChangedEmitter);\n\n  @inject(PreferenceSchemaProvider)\n  protected readonly schema: PreferenceSchemaProvider;\n\n  @inject(PreferenceProviderProvider)\n  protected readonly providerProvider: PreferenceProviderProvider;\n\n  @inject(PreferenceConfigurations)\n  protected readonly configurations: PreferenceConfigurations;\n\n  @inject(PreferenceLanguageOverrideService)\n  protected readonly preferenceOverrideService: PreferenceLanguageOverrideService;\n\n  protected readonly preferenceProviders = new Map<PreferenceScope, PreferenceProvider>();\n  protected readonly _ready = new Deferred<void>();\n\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  has(preferenceName: string, resourceUri?: string): boolean {\n    return this.get(preferenceName, undefined, resourceUri) !== undefined;\n  }\n\n  get<T>(preferenceName: string): T | undefined;\n\n  get<T>(preferenceName: string, defaultValue: T): T;\n\n  get<T>(preferenceName: string, defaultValue: T, resourceUri: string): T;\n\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined;\n\n  get<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined {\n    return this.resolve<T>(preferenceName, defaultValue, resourceUri).value;\n  }\n\n  resolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T> {\n    const {value, configUri} = this.doResolve(preferenceName, defaultValue, resourceUri);\n    if (value === undefined) {\n      const overridden = this.overriddenPreferenceName(preferenceName);\n      if (overridden) {\n        return this.doResolve(overridden.preferenceName, defaultValue, resourceUri);\n      }\n    }\n    return {value, configUri};\n  }\n\n  async set(preferenceName: string, value: any, scope: PreferenceScope | undefined, resourceUri?: string): Promise<void> {\n    // const resolvedScope = scope ?? (!resourceUri ? PreferenceScope.Workspace : PreferenceScope.Folder);\n    // if (resolvedScope === PreferenceScope.Folder && !resourceUri) {\n    //     throw new Error('Unable to write to Folder Settings because no resource is provided.');\n    // }\n    // const provider = this.getProvider(resolvedScope);\n    // if (provider && await provider.setPreference(preferenceName, value, resourceUri)) {\n    return;\n    // }\n    // throw new Error(`Unable to write to ${PreferenceScope[resolvedScope]} Settings.`);\n  }\n\n  getBoolean(preferenceName: string): boolean | undefined;\n\n  getBoolean(preferenceName: string, defaultValue: boolean): boolean;\n\n  getBoolean(preferenceName: string, defaultValue: boolean, resourceUri: string): boolean;\n\n  getBoolean(preferenceName: string, defaultValue?: boolean, resourceUri?: string): boolean | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    return value !== null && value !== undefined ? !!value : defaultValue;\n  }\n\n  getString(preferenceName: string): string | undefined;\n\n  getString(preferenceName: string, defaultValue: string): string;\n\n  getString(preferenceName: string, defaultValue: string, resourceUri: string): string;\n\n  getString(preferenceName: string, defaultValue?: string, resourceUri?: string): string | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n    return value.toString();\n  }\n\n  getNumber(preferenceName: string): number | undefined;\n\n  getNumber(preferenceName: string, defaultValue: number): number;\n\n  getNumber(preferenceName: string, defaultValue: number, resourceUri: string): number;\n\n  getNumber(preferenceName: string, defaultValue?: number, resourceUri?: string): number | undefined {\n    const value = resourceUri ? this.get(preferenceName, defaultValue, resourceUri) : this.get(preferenceName, defaultValue);\n    // eslint-disable-next-line no-null/no-null\n    if (value === null || value === undefined) {\n      return defaultValue;\n    }\n    if (typeof value === 'number') {\n      return value;\n    }\n    return Number(value);\n  }\n\n  inspect<T>(preferenceName: string, resourceUri?: string): PreferenceInspection<T> | undefined {\n    const defaultValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Default, resourceUri);\n    // const globalValue = this.inspectInScope<T>(preferenceName, PreferenceScope.User, resourceUri);\n    // const workspaceValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Workspace, resourceUri);\n    // const workspaceFolderValue = this.inspectInScope<T>(preferenceName, PreferenceScope.Folder, resourceUri);\n\n    const valueApplied = defaultValue;\n    // const valueApplied = workspaceFolderValue ?? workspaceValue ?? globalValue ?? defaultValue;\n\n    return {preferenceName, defaultValue, value: valueApplied};\n    // return { preferenceName, defaultValue, globalValue, workspaceValue, workspaceFolderValue, value: valueApplied };\n  }\n\n  async updateValue(preferenceName: string, value: any, resourceUri?: string): Promise<void> {\n    const inspection = this.inspect<any>(preferenceName, resourceUri);\n    if (inspection) {\n      const scopesToChange = this.getScopesToChange(inspection, value);\n      const isDeletion = value === undefined\n          || (scopesToChange.length === 1 && JSONExt.deepEqual(value, inspection.defaultValue));\n\n      // const isDeletion = value === undefined\n      //     || (scopesToChange.length === 1 && scopesToChange[0] === PreferenceScope.User && JSONExt.deepEqual(value, inspection.defaultValue));\n      const effectiveValue = isDeletion ? undefined : value;\n      await Promise.all(scopesToChange.map(scope => this.set(preferenceName, effectiveValue, scope, resourceUri)));\n    }\n  }\n\n  overridePreferenceName(options: OverridePreferenceName): string {\n    return this.preferenceOverrideService.overridePreferenceName(options);\n  }\n\n  overriddenPreferenceName(preferenceName: string): OverridePreferenceName | undefined {\n    return this.preferenceOverrideService.overriddenPreferenceName(preferenceName);\n  }\n\n  getConfigUri(scope: PreferenceScope, resourceUri?: string, sectionName: string = this.configurations.getConfigName()): URI | undefined {\n    const provider = this.getProvider(scope);\n    if (!provider || !this.configurations.isAnyConfig(sectionName)) {\n      return undefined;\n    }\n    const configUri = provider.getConfigUri(resourceUri, sectionName);\n    if (configUri) {\n      return configUri;\n    }\n    return provider.getContainingConfigUri && provider.getContainingConfigUri(resourceUri, sectionName);\n  }\n\n  protected async initializeProviders(): Promise<void> {\n    try {\n      for (const scope of PreferenceScope.getScopes()) {\n        const provider = this.providerProvider(scope);\n        this.preferenceProviders.set(scope, provider);\n        this.toDispose.push(provider.onDidPreferencesChanged(changes =>\n            this.reconcilePreferences(changes)\n        ));\n        await provider.ready;\n      }\n      this._ready.resolve();\n    } catch (e) {\n      console.log('error');\n      console.log(e);\n      this._ready.reject(e);\n    }\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.toDispose.push(Disposable.create(() => this._ready.reject(new Error('preference service is disposed'))));\n    this.initializeProviders();\n  }\n\n  protected reconcilePreferences(changes: PreferenceProviderDataChanges): void {\n    const changesToEmit: PreferenceChanges = {};\n    const acceptChange = (change: PreferenceProviderDataChange) =>\n        this.getAffectedPreferenceNames(change, preferenceName =>\n            changesToEmit[preferenceName] = new PreferenceChangeImpl({...change, preferenceName})\n        );\n\n    for (const preferenceName of Object.keys(changes)) {\n      let change = changes[preferenceName];\n      if (change.newValue === undefined) {\n        const overridden = this.overriddenPreferenceName(change.preferenceName);\n        if (overridden) {\n          change = {\n            ...change, newValue: this.doGet(overridden.preferenceName)\n          };\n        }\n      }\n      // if (this.schema.isValidInScope(preferenceName, PreferenceScope.Folder)) {\n      //     acceptChange(change);\n      //     continue;\n      // }\n      for (const scope of PreferenceScope.getReversedScopes()) {\n        if (this.schema.isValidInScope(preferenceName, scope)) {\n          const provider = this.getProvider(scope);\n          if (provider) {\n            const value = provider.get(preferenceName);\n            if (scope > change.scope && value !== undefined) {\n              // preference defined in a more specific scope\n              break;\n            } else if (scope === change.scope && change.newValue !== undefined) {\n              // preference is changed into something other than `undefined`\n              acceptChange(change);\n            } else if (scope < change.scope && change.newValue === undefined && value !== undefined) {\n              // preference is changed to `undefined`, use the value from a more general scope\n              change = {\n                ...change,\n                newValue: value,\n                scope\n              };\n              acceptChange(change);\n            }\n          }\n        } else if (change.newValue === undefined && change.scope === PreferenceScope.Default) {\n          // preference is removed\n          acceptChange(change);\n          break;\n        }\n      }\n    }\n\n    // emit the changes\n    const changedPreferenceNames = Object.keys(changesToEmit);\n    if (changedPreferenceNames.length > 0) {\n      this.onPreferencesChangedEmitter.fire(changesToEmit);\n    }\n    changedPreferenceNames.forEach(preferenceName => this.onPreferenceChangedEmitter.fire(changesToEmit[preferenceName]));\n  }\n\n  protected getAffectedPreferenceNames(change: PreferenceProviderDataChange, accept: (affectedPreferenceName: string) => void): void {\n    accept(change.preferenceName);\n    for (const overridePreferenceName of this.schema.getOverridePreferenceNames(change.preferenceName)) {\n      if (!this.doHas(overridePreferenceName)) {\n        accept(overridePreferenceName);\n      }\n    }\n  }\n\n  protected getProvider(scope: PreferenceScope): PreferenceProvider | undefined {\n    return this.preferenceProviders.get(scope);\n  }\n\n  protected inspectInScope<T>(preferenceName: string, scope: PreferenceScope, resourceUri?: string): T | undefined {\n    const value = this.doInspectInScope<T>(preferenceName, scope, resourceUri);\n    if (value === undefined) {\n      const overridden = this.overriddenPreferenceName(preferenceName);\n      if (overridden) {\n        return this.doInspectInScope(overridden.preferenceName, scope, resourceUri);\n      }\n    }\n    return value;\n  }\n\n  protected getScopedValueFromInspection<T>(inspection: PreferenceInspection<T>, scope: PreferenceScope): T | undefined {\n    switch (scope) {\n      case PreferenceScope.Default:\n        return inspection.defaultValue;\n        // case PreferenceScope.User:\n        //     return inspection.globalValue;\n        // case PreferenceScope.Workspace:\n        //     return inspection.workspaceValue;\n        // case PreferenceScope.Folder:\n        //     return inspection.workspaceFolderValue;\n    }\n    unreachable(scope, 'Not all PreferenceScope enum variants handled.');\n  }\n\n  protected getScopesToChange(inspection: PreferenceInspection<any>, intendedValue: any): PreferenceScope[] {\n    if (JSONExt.deepEqual(inspection.value, intendedValue)) {\n      return [];\n    }\n\n    // Scopes in ascending order of scope breadth.\n    const allScopes = PreferenceScope.getReversedScopes();\n    // Get rid of Default scope. We can't set anything there.\n    allScopes.pop();\n\n    const isScopeDefined = (scope: PreferenceScope) => this.getScopedValueFromInspection(inspection, scope) !== undefined;\n\n    if (intendedValue === undefined) {\n      return allScopes.filter(isScopeDefined);\n    }\n\n    return [allScopes.find(isScopeDefined)];\n    // return [allScopes.find(isScopeDefined) ?? PreferenceScope.User];\n  }\n\n  protected doHas(preferenceName: string, resourceUri?: string): boolean {\n    return this.doGet(preferenceName, undefined, resourceUri) !== undefined;\n  }\n\n  protected doInspectInScope<T>(preferenceName: string, scope: PreferenceScope, resourceUri?: string): T | undefined {\n    const provider = this.getProvider(scope);\n    return provider && provider.get<T>(preferenceName, resourceUri);\n  }\n\n  protected doGet<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): T | undefined {\n    return this.doResolve(preferenceName, defaultValue, resourceUri).value;\n  }\n\n  protected doResolve<T>(preferenceName: string, defaultValue?: T, resourceUri?: string): PreferenceResolveResult<T> {\n    const result: PreferenceResolveResult<T> = {};\n    for (const scope of PreferenceScope.getScopes()) {\n      if (this.schema.isValidInScope(preferenceName, scope)) {\n        const provider = this.getProvider(scope);\n        if (provider) {\n          const {configUri, value} = provider.resolve<T>(preferenceName, resourceUri);\n          if (value !== undefined) {\n            result.configUri = configUri;\n            result.value = PreferenceProvider.merge(result.value as any, value as any) as any;\n          }\n        }\n      }\n    }\n    return {\n      configUri: result.configUri,\n      value: result.value !== undefined ? deepFreeze(result.value) : defaultValue\n    };\n  }\n}\n"]}