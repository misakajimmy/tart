{"version":3,"sources":["browser/preferences/preference-provider.ts"],"names":[],"mappings":"AACA,OAAO,GAAG,MAAM,kBAAkB,CAAC;AAEnC,OAAO,EAAC,eAAe,EAAC,MAAM,oBAAoB,CAAC;AACnD,OAAO,EAAC,UAAU,EAAE,oBAAoB,EAAE,OAAO,EAAE,KAAK,EAAC,MAAM,cAAc,CAAC;AAC9E,OAAO,EAAC,iCAAiC,EAAC,MAAM,wCAAwC,CAAC;AACzF,OAAO,EAAC,QAAQ,EAAC,MAAM,2BAA2B,CAAC;AACnD,OAAO,EAAU,SAAS,EAAC,MAAM,mBAAmB,CAAC;AAErD,MAAM,WAAW,4BAA4B;IAC3C,QAAQ,CAAC,cAAc,EAAE,MAAM,CAAC;IAChC,QAAQ,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC;IACxB,QAAQ,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC;IACxB,QAAQ,CAAC,KAAK,EAAE,eAAe,CAAC;IAChC,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC;CAC5B;AAED,yBAAiB,4BAA4B,CAAC;IAC5C,SAAgB,OAAO,CAAC,MAAM,EAAE,4BAA4B,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,OAAO,CAI3F;CACF;AAED,MAAM,WAAW,6BAA6B;IAC5C,CAAC,cAAc,EAAE,MAAM,GAAG,4BAA4B,CAAC;CACxD;AAED,MAAM,WAAW,uBAAuB,CAAC,CAAC;IACxC,SAAS,CAAC,EAAE,GAAG,CAAA;IACf,KAAK,CAAC,EAAE,CAAC,CAAA;CACV;AAED;;;;GAIG;AACH,8BACsB,kBAAmB,YAAW,UAAU;IAEjB,SAAS,CAAC,QAAQ,CAAC,yBAAyB,EAAE,iCAAiC,CAAC;IAE3H,SAAS,CAAC,QAAQ,CAAC,8BAA8B,yCAAgD;IACjG,QAAQ,CAAC,uBAAuB,EAAE,KAAK,CAAC,6BAA6B,CAAC,CAA6C;IAEnH,SAAS,CAAC,QAAQ,CAAC,SAAS,uBAA8B;IAE1D,SAAS,CAAC,QAAQ,CAAC,MAAM,iBAAwB;IACjD,SAAS,CAAC,eAAe,EAAE,6BAA6B,GAAG,SAAS,CAAC;IACrE,SAAS,CAAC,yBAAyB,yBAQ7B;;IAMN,SAAS,CAAC,eAAe,EAAE,OAAO,CAAC,OAAO,CAAC,CAA0B;IACrE,IAAI,cAAc,IAAI,OAAO,CAAC,OAAO,CAAC,CAErC;IAED;;;OAGG;IACH,IAAI,KAAK,IAAI,OAAO,CAAC,IAAI,CAAC,CAEzB;IAED,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,GAAG,SAAS,EAAE,MAAM,EAAE,SAAS,GAAG,SAAS;IAoBzE;;OAEG;IACH,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,GAAG,SAAS,EAAE,CAAC,EAAE,SAAS,GAAG,SAAS,GAAG,OAAO;IAU7E,OAAO,IAAI,IAAI;IAIf;;;;;;;;OAQG;IACH,GAAG,CAAC,CAAC,EAAE,cAAc,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,CAAC,GAAG,SAAS;IAInE;;;;;;;;;OASG;IACH,OAAO,CAAC,CAAC,EAAE,cAAc,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,uBAAuB,CAAC,CAAC,CAAC;IAWpF,QAAQ,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE,MAAM,GAAG;QAAE,CAAC,CAAC,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE;IAEnE;;;;;;;;;;OAUG;IACH,QAAQ,CAAC,aAAa,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAEvF;;;;OAIG;IACH,SAAS,IAAI,MAAM,EAAE,GAAG,SAAS;IAIjC;;;;;;OAMG;IACH,YAAY,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,GAAG,GAAG,SAAS;IAIzE;;;;;;OAMG;IACH,sBAAsB,CAAC,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,GAAG,GAAG,SAAS;IAEpF;;;OAGG;IACH,SAAS,CAAC,2BAA2B,CAAC,OAAO,EAAE,6BAA6B,GAAG,4BAA4B,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC;IAahI,SAAS,CAAC,iCAAiC,CAAC,MAAM,EAAE,4BAA4B,GAAG,IAAI;IAkBvF,SAAS,CAAC,gBAAgB,CAAC,QAAQ,EAAE,GAAG,GAAG;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;KAAE;CAoBlE","file":"../../../src/browser/preferences/preference-provider.d.ts","sourcesContent":["import {default as debounce} from 'p-debounce';\nimport URI from '../../common/uri';\nimport {inject, injectable} from 'inversify';\nimport {PreferenceScope} from './preference-scope';\nimport {Disposable, DisposableCollection, Emitter, Event} from '../../common';\nimport {PreferenceLanguageOverrideService} from './preference-language-override-service';\nimport {Deferred} from '../../common/promise-util';\nimport {JSONExt, JSONValue} from '@lumino/coreutils';\n\nexport interface PreferenceProviderDataChange {\n  readonly preferenceName: string;\n  readonly newValue?: any;\n  readonly oldValue?: any;\n  readonly scope: PreferenceScope;\n  readonly domain?: string[];\n}\n\nexport namespace PreferenceProviderDataChange {\n  export function affects(change: PreferenceProviderDataChange, resourceUri?: string): boolean {\n    const resourcePath = resourceUri && new URI(resourceUri).path;\n    const domain = change.domain;\n    return !resourcePath || !domain || domain.some(uri => new URI(uri).path.relativity(resourcePath) >= 0);\n  }\n}\n\nexport interface PreferenceProviderDataChanges {\n  [preferenceName: string]: PreferenceProviderDataChange;\n}\n\nexport interface PreferenceResolveResult<T> {\n  configUri?: URI\n  value?: T\n}\n\n/**\n * The {@link PreferenceProvider} is used to store and retrieve preference values. A {@link PreferenceProvider} does not operate in a global scope but is\n * configured for one or more {@link PreferenceScope}s. The (default implementation for the) {@link PreferenceService} aggregates all {@link PreferenceProvider}s and\n * serves as a common facade for manipulating preference values.\n */\n@injectable()\nexport abstract class PreferenceProvider implements Disposable {\n\n  @inject(PreferenceLanguageOverrideService) protected readonly preferenceOverrideService: PreferenceLanguageOverrideService;\n\n  protected readonly onDidPreferencesChangedEmitter = new Emitter<PreferenceProviderDataChanges>();\n  readonly onDidPreferencesChanged: Event<PreferenceProviderDataChanges> = this.onDidPreferencesChangedEmitter.event;\n\n  protected readonly toDispose = new DisposableCollection();\n\n  protected readonly _ready = new Deferred<void>();\n  protected deferredChanges: PreferenceProviderDataChanges | undefined;\n  protected fireDidPreferencesChanged = debounce(() => {\n    const changes = this.deferredChanges;\n    this.deferredChanges = undefined;\n    if (changes && Object.keys(changes).length) {\n      this.onDidPreferencesChangedEmitter.fire(changes);\n      return true;\n    }\n    return false;\n  }, 0);\n\n  constructor() {\n    this.toDispose.push(this.onDidPreferencesChangedEmitter);\n  }\n\n  protected _pendingChanges: Promise<boolean> = Promise.resolve(false);\n  get pendingChanges(): Promise<boolean> {\n    return this._pendingChanges;\n  }\n\n  /**\n   * Resolved when the preference provider is ready to provide preferences\n   * It should be resolved by subclasses.\n   */\n  get ready(): Promise<void> {\n    return this._ready.promise;\n  }\n\n  static merge(source: JSONValue | undefined, target: JSONValue): JSONValue {\n    if (source === undefined || !JSONExt.isObject(source)) {\n      return JSONExt.deepCopy(target);\n    }\n    if (JSONExt.isPrimitive(target)) {\n      return {};\n    }\n    for (const key of Object.keys(target)) {\n      const value = (target as any)[key];\n      if (key in source) {\n        if (JSONExt.isObject(source[key]) && JSONExt.isObject(value)) {\n          this.merge(source[key], value);\n          continue;\n        }\n      }\n      source[key] = JSONExt.deepCopy(value);\n    }\n    return source;\n  }\n\n  /**\n   * Handles deep equality with the possibility of `undefined`\n   */\n  static deepEqual(a: JSONValue | undefined, b: JSONValue | undefined): boolean {\n    if (a === b) {\n      return true;\n    }\n    if (a === undefined || b === undefined) {\n      return false;\n    }\n    return JSONExt.deepEqual(a, b);\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  /**\n   * Retrieve the stored value for the given preference and resource URI.\n   *\n   * @param preferenceName the preference identifier.\n   * @param resourceUri the uri of the resource for which the preference is stored. This is used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns the value stored for the given preference and resourceUri if it exists, otherwise `undefined`.\n   */\n  get<T>(preferenceName: string, resourceUri?: string): T | undefined {\n    return this.resolve<T>(preferenceName, resourceUri).value;\n  }\n\n  /**\n   * Resolve the value for the given preference and resource URI.\n   *\n   * @param preferenceName the preference identifier.\n   * @param resourceUri the URI of the resource for which this provider should resolve the preference. This is used to retrieve\n   * a potentially different value for the same preference for different resources, for example `files.encoding`.\n   *\n   * @returns an object containing the value stored for the given preference and resourceUri if it exists,\n   * otherwise `undefined`.\n   */\n  resolve<T>(preferenceName: string, resourceUri?: string): PreferenceResolveResult<T> {\n    // const value = this.getPreferences(resourceUri)[preferenceName];\n    // if (value !== undefined) {\n    //     return {\n    //         value,\n    //         configUri: this.getConfigUri(resourceUri)\n    //     };\n    // }\n    return {};\n  }\n\n  abstract getPreferences(resourceUri?: string): { [p: string]: any };\n\n  /**\n   * Stores a new value for the given preference key in the provider.\n   * @param key the preference key (typically the name).\n   * @param value the new preference value.\n   * @param resourceUri the URI of the resource for which the preference is stored.\n   *\n   * @returns a promise that only resolves if all changes were delivered.\n   * If changes were made then implementation must either\n   * await on `this.emitPreferencesChangedEvent(...)` or\n   * `this.pendingChanges` if changes are fired indirectly.\n   */\n  abstract setPreference(key: string, value: any, resourceUri?: string): Promise<boolean>;\n\n  /**\n   * Retrieve the domain for this provider.\n   *\n   * @returns the domain or `undefined` if this provider is suitable for all domains.\n   */\n  getDomain(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * Retrieve the configuration URI for the given resource URI.\n   * @param resourceUri the uri of the resource or `undefined`.\n   * @param sectionName the section to return the URI for, e.g. `tasks` or `launch`. Defaults to settings.\n   *\n   * @returns the corresponding resource URI or `undefined` if there is no valid URI.\n   */\n  getConfigUri(resourceUri?: string, sectionName?: string): URI | undefined {\n    return undefined;\n  }\n\n  /**\n   * Retrieves the first valid configuration URI contained by the given resource.\n   * @param resourceUri the uri of the container resource or `undefined`.\n   *\n   * @returns the first valid configuration URI contained by the given resource `undefined`\n   * if there is no valid configuration URI at all.\n   */\n  getContainingConfigUri?(resourceUri?: string, sectionName?: string): URI | undefined;\n\n  /**\n   * Informs the listeners that one or more preferences of this provider are changed.\n   * The listeners are able to find what was changed from the emitted event.\n   */\n  protected emitPreferencesChangedEvent(changes: PreferenceProviderDataChanges | PreferenceProviderDataChange[]): Promise<boolean> {\n    if (Array.isArray(changes)) {\n      for (const change of changes) {\n        this.mergePreferenceProviderDataChange(change);\n      }\n    } else {\n      for (const preferenceName of Object.keys(changes)) {\n        this.mergePreferenceProviderDataChange(changes[preferenceName]);\n      }\n    }\n    return this._pendingChanges = this.fireDidPreferencesChanged();\n  }\n\n  protected mergePreferenceProviderDataChange(change: PreferenceProviderDataChange): void {\n    if (!this.deferredChanges) {\n      this.deferredChanges = {};\n    }\n    const current = this.deferredChanges[change.preferenceName];\n    const {newValue, scope, domain} = change;\n    if (!current) {\n      // new\n      this.deferredChanges[change.preferenceName] = change;\n    } else if (current.oldValue === newValue) {\n      // delete\n      delete this.deferredChanges[change.preferenceName];\n    } else {\n      // update\n      Object.assign(current, {newValue, scope, domain});\n    }\n  }\n\n  protected getParsedContent(jsonData: any): { [key: string]: any } {\n    const preferences: { [key: string]: any } = {};\n    if (typeof jsonData !== 'object') {\n      return preferences;\n    }\n    // eslint-disable-next-line guard-for-in\n    for (const preferenceName in jsonData) {\n      const preferenceValue = jsonData[preferenceName];\n      if (this.preferenceOverrideService.testOverrideValue(preferenceName, preferenceValue)) {\n        // eslint-disable-next-line guard-for-in\n        for (const overriddenPreferenceName in preferenceValue) {\n          const overriddenValue = preferenceValue[overriddenPreferenceName];\n          preferences[`${preferenceName}.${overriddenPreferenceName}`] = overriddenValue;\n        }\n      } else {\n        preferences[preferenceName] = preferenceValue;\n      }\n    }\n    return preferences;\n  }\n}\n"]}