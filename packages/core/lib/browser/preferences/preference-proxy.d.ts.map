{"version":3,"sources":["browser/preferences/preference-proxy.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAIlF,OAAO,EAAC,UAAU,EAAE,KAAK,EAAE,YAAY,EAAC,MAAM,cAAc,CAAC;AAC7D,OAAO,EAAC,iBAAiB,EAAC,MAAM,sBAAsB,CAAC;AACvD,OAAO,EAAC,gBAAgB,EAAC,MAAM,2BAA2B,CAAC;AAI3D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCG;AAEH;;GAEG;AACH,oBAAY,qBAAqB,CAAC,CAAC,IAAI;IACrC,OAAO,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC;CACrE,GAAG;KACD,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,GAAG;QAChB,QAAQ,CAAC,cAAc,EAAE,CAAC,CAAC;QAC3B,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;QACxB;;WAEG;QAEH,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;KAC1B;CACF,CAAC,MAAM,CAAC,CAAC,CAAC;AAEX,MAAM,WAAW,sBAAsB,CAAC,CAAC;IACvC,QAAQ,CAAC,mBAAmB,EAAE,KAAK,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9D,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;CAC/B;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,WAAW,mBAAmB,CAAC,CAAC;IACpC,GAAG,CAAC,CAAC,SAAS,MAAM,CAAC,EAAE,cAAc,EAAE,CAAC,GAAG;QACzC,cAAc,EAAE,CAAC,CAAC;QAClB,kBAAkB,CAAC,EAAE,MAAM,CAAA;KAC5B,EAAE,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;CACrD;AAED;;;;;;;;;;;;GAYG;AACH,oBAAY,eAAe,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,sBAAsB,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC;AAE/G;;GAEG;AACH,MAAM,WAAW,sBAAsB;IACrC;;OAEG;IACH,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB;;OAEG;IACH,WAAW,CAAC,EAAE,MAAM,CAAC;IACrB;;;;;;OAMG;IACH,kBAAkB,CAAC,EAAE,MAAM,CAAC;IAC5B;;;;;OAKG;IACH,KAAK,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,MAAM,CAAC;CAClC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,wBAAgB,qBAAqB,CAAC,CAAC,EAAE,WAAW,EAAE,iBAAiB,EAAE,cAAc,EAAE,YAAY,CAAC,gBAAgB,CAAC,EAAE,OAAO,CAAC,EAAE,sBAAsB,GAAG,eAAe,CAAC,CAAC,CAAC,CAyM7K","file":"../../../src/browser/preferences/preference-proxy.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {Disposable, Event, MaybePromise} from '../../common';\nimport {PreferenceService} from './preference-service';\nimport {PreferenceSchema} from './preference-contribution';\nimport {PreferenceScope} from './preference-scope';\nimport {OverridePreferenceName} from './preference-language-override-service';\n\n/**\n * It is worth explaining the type for `PreferenceChangeEvent`:\n *\n * // Given T:\n * type T = { a: string, b: number }\n *\n * // We construct a new type such as:\n * type U = {\n *     a: {\n *         preferenceName: 'a'\n *         newValue: string\n *         oldValue?: string\n *     }\n *     b: {\n *        preferenceName: 'b'\n *        newValue: number\n *        oldValue?: number\n *     }\n * }\n *\n * // Then we get the union of all values of U by selecting by `keyof T`:\n * type V = U[keyof T]\n *\n * // Implementation:\n * type PreferenceChangeEvent<T> = {\n *     // Create a mapping where each key is a key from T,\n *     // -? normalizes optional typings to avoid getting\n *     // `undefined` as part of the final union:\n *     [K in keyof T]-?: {\n *         // In this object, K will take the value of each\n *         // independent key from T:\n *         preferenceName: K\n *         newValue: T[K]\n *         oldValue?: T[K]\n *     // Finally we create the union by doing so:\n *     }[keyof T]\n * }\n */\n\n/**\n * Union of all possible key/value pairs for a type `T`\n */\nexport type PreferenceChangeEvent<T> = {\n  affects(resourceUri?: string, overrideIdentifier?: string): boolean;\n} & {\n  [K in keyof T]-?: {\n    readonly preferenceName: K;\n    readonly newValue: T[K];\n    /**\n     * Undefined if the preference is set for the first time.\n     */\n    // TODO: Use the default value instead of undefined?\n    readonly oldValue?: T[K];\n  }\n}[keyof T];\n\nexport interface PreferenceEventEmitter<T> {\n  readonly onPreferenceChanged: Event<PreferenceChangeEvent<T>>;\n  readonly ready: Promise<void>;\n}\n\n/**\n * Generic interface to declare a typesafe get function based on the given\n * configuration type.\n *\n * ### Illustration\n *\n * ```ts\n * interface PreferenceConfiguration {\n *  'myext.enabled': boolean,\n * }\n * const enabled : boolean = prefs.get('myext.enabled'); // valid\n * const debug : string = prefs.get('myext.enabled'); // invalid\n * prefs.get('foobar'); // invalid\n * ```\n */\nexport interface PreferenceRetrieval<T> {\n  get<K extends keyof T>(preferenceName: K | {\n    preferenceName: K,\n    overrideIdentifier?: string\n  }, defaultValue?: T[K], resourceUri?: string): T[K];\n}\n\n/**\n * Typesafe schema-based preferences utility based on the {@link PreferenceService}.\n * Can be used to get preferences as well as listen to preference changes.\n *\n * See {@link createPreferenceProxy} on how to instantiate preference proxies.\n *\n * ### Example usage\n *\n * ```ts\n * preferences.onPreferenceChanged(({ preferenceName, newValue }) => { ... });\n * const enabled = preferences['myext.enabled'];\n * ```\n */\nexport type PreferenceProxy<T> = Readonly<T> & Disposable & PreferenceEventEmitter<T> & PreferenceRetrieval<T>;\n\n/**\n * Proxy configuration parameters.\n */\nexport interface PreferenceProxyOptions {\n  /**\n   * Prefix which is transparently added to all preference identifiers.\n   */\n  prefix?: string;\n  /**\n   * The default resourceUri to use if none was specified when calling \"set\" or \"get\".\n   */\n  resourceUri?: string;\n  /**\n   * The overrideIdentifier to use with the underlying preferenceService.\n   * Useful to potentially override existing values while keeping both values in store.\n   *\n   * For example to store different editor settings, e.g. \"[markdown].editor.autoIndent\",\n   * \"[json].editor.autoIndent\" and \"editor.autoIndent\"\n   */\n  overrideIdentifier?: string;\n  /**\n   * Indicates whether '.' in schema properties shall be interpreted as regular names (flat),\n   * as declaring nested objects (deep) or both. Default is flat.\n   *\n   * When 'deep' or 'both' is given, nested preference proxies can be retrieved.\n   */\n  style?: 'flat' | 'deep' | 'both';\n}\n\n/**\n * Creates a preference proxy for typesafe preference handling.\n *\n * @param preferences the underlying preference service to use for preference handling.\n * @param promisedSchema the JSON Schema which describes which preferences are available including types and descriptions. Can be a promise.\n * @param options configuration options.\n *\n * @returns the created preference proxy.\n *\n * ### Usage\n *\n *  1. Create JSON Schema specifying your preferences\n *  2. Create Configuration type based on the JSON Schema\n *  3. Bind the return value of `createPreferenceProxy` to make your preferences available wherever needed.\n *\n * See {@link CorePreferences} for an example.\n *\n * Note that if `schema` is a Promise, most actions will be no-ops until the promise is resolved.\n */\nexport function createPreferenceProxy<T>(preferences: PreferenceService, promisedSchema: MaybePromise<PreferenceSchema>, options?: PreferenceProxyOptions): PreferenceProxy<T> {\n  const opts = options || {};\n  const prefix = opts.prefix || '';\n  const style = opts.style || 'flat';\n  const isDeep = style === 'deep' || style === 'both';\n  const isFlat = style === 'both' || style === 'flat';\n  let schema: PreferenceSchema | undefined;\n  if (PreferenceSchema.is(promisedSchema)) {\n    schema = promisedSchema;\n  } else {\n    promisedSchema.then(s => schema = s);\n  }\n  const onPreferenceChanged = (listener: (e: PreferenceChangeEvent<T>) => any, thisArgs?: any, disposables?: Disposable[]) => preferences.onPreferencesChanged(changes => {\n    if (schema) {\n      for (const key of Object.keys(changes)) {\n        const e = changes[key];\n        const overridden = preferences.overriddenPreferenceName(e.preferenceName);\n        const preferenceName: any = overridden ? overridden.preferenceName : e.preferenceName;\n        if (preferenceName.startsWith(prefix) && (!overridden || !opts.overrideIdentifier || overridden.overrideIdentifier === opts.overrideIdentifier)) {\n          if (schema.properties[preferenceName]) {\n            const {newValue, oldValue} = e;\n            listener({\n              newValue, oldValue, preferenceName,\n              affects: (resourceUri, overrideIdentifier) => {\n                if (overrideIdentifier !== undefined) {\n                  if (overridden && overridden.overrideIdentifier !== overrideIdentifier) {\n                    return false;\n                  }\n                }\n                return e.affects(resourceUri);\n              }\n            });\n          }\n        }\n      }\n    }\n  }, thisArgs, disposables);\n\n  const unsupportedOperation = (_: any, __: string) => {\n    throw new Error('Unsupported operation');\n  };\n\n  const getValue: PreferenceRetrieval<any>['get'] = (arg, defaultValue, resourceUri) => {\n    const preferenceName = OverridePreferenceName.is(arg) ?\n        preferences.overridePreferenceName(arg) :\n        <string>arg;\n    return preferences.get(preferenceName, defaultValue, resourceUri || opts.resourceUri);\n  };\n\n  const ownKeys: () => string[] = () => {\n    const properties = [];\n    if (schema) {\n      for (const p of Object.keys(schema.properties)) {\n        if (p.startsWith(prefix)) {\n          const idx = p.indexOf('.', prefix.length);\n          if (idx !== -1 && isDeep) {\n            const pre = p.substr(prefix.length, idx - prefix.length);\n            if (properties.indexOf(pre) === -1) {\n              properties.push(pre);\n            }\n          }\n          const prop = p.substr(prefix.length);\n          if (isFlat || prop.indexOf('.') === -1) {\n            properties.push(prop);\n          }\n        }\n      }\n    }\n    return properties;\n  };\n\n  const set: (target: any, prop: string, value: any, receiver: any) => boolean = (_, property: string | symbol | number, value: any) => {\n    if (typeof property !== 'string') {\n      throw new Error(`unexpected property: ${String(property)}`);\n    }\n    if (style === 'deep' && property.indexOf('.') !== -1) {\n      return false;\n    }\n    if (schema) {\n      const fullProperty = prefix ? prefix + property : property;\n      if (schema.properties[fullProperty]) {\n        preferences.set(fullProperty, value, PreferenceScope.Default);\n        return true;\n      }\n      const newPrefix = fullProperty + '.';\n      for (const p of Object.keys(schema.properties)) {\n        if (p.startsWith(newPrefix)) {\n          const subProxy: { [k: string]: any } = createPreferenceProxy(preferences, schema, {\n            prefix: newPrefix,\n            resourceUri: opts.resourceUri,\n            overrideIdentifier: opts.overrideIdentifier,\n            style\n          });\n          for (const k of Object.keys(value)) {\n            subProxy[k] = value[k];\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  const get: (target: any, prop: string) => any = (_, property: string | symbol | number) => {\n    if (typeof property !== 'string') {\n      throw new Error(`unexpected property: ${String(property)}`);\n    }\n    const fullProperty = prefix ? prefix + property : property;\n    if (schema) {\n      if (isFlat || property.indexOf('.') === -1) {\n        if (schema.properties[fullProperty]) {\n          let value;\n          if (opts.overrideIdentifier) {\n            value = preferences.get(preferences.overridePreferenceName({\n              overrideIdentifier: opts.overrideIdentifier,\n              preferenceName: fullProperty\n            }), undefined, opts.resourceUri);\n          }\n          if (value === undefined) {\n            value = preferences.get(fullProperty, undefined, opts.resourceUri);\n          }\n          if (value === undefined) {\n            value = schema.properties[fullProperty].default;\n          }\n          return value;\n        }\n      }\n    }\n    if (property === 'onPreferenceChanged') {\n      return onPreferenceChanged;\n    }\n    if (property === 'dispose') {\n      return () => { /* do nothing */\n      };\n    }\n    if (property === 'ready') {\n      return preferences.ready;\n    }\n    if (property === 'get') {\n      return getValue;\n    }\n    if (property === 'toJSON') {\n      return toJSON();\n    }\n    if (schema && isDeep) {\n      const newPrefix = fullProperty + '.';\n      for (const p of Object.keys(schema.properties)) {\n        if (p.startsWith(newPrefix)) {\n          return createPreferenceProxy(preferences, schema, {\n            prefix: newPrefix,\n            resourceUri: opts.resourceUri,\n            overrideIdentifier: opts.overrideIdentifier,\n            style\n          });\n        }\n      }\n\n      let value;\n      let parentSegment = fullProperty;\n      const segments = [];\n      do {\n        const index = parentSegment.lastIndexOf('.');\n        segments.push(parentSegment.substring(index + 1));\n        parentSegment = parentSegment.substring(0, index);\n        if (parentSegment in schema.properties) {\n          value = get(_, parentSegment);\n        }\n      } while (parentSegment && value === undefined);\n\n      let segment;\n      while (typeof value === 'object' && (segment = segments.pop())) {\n        value = value[segment];\n      }\n      return segments.length ? undefined : value;\n    }\n    return undefined;\n  };\n\n  const toJSON = () => {\n    const result: any = {};\n    for (const k of ownKeys()) {\n      result[k] = get(undefined, k);\n    }\n    return result;\n  };\n\n  return new Proxy({}, {\n    get,\n    ownKeys,\n    getOwnPropertyDescriptor: (_, property: string) => {\n      if (ownKeys().indexOf(property) !== -1) {\n        return {\n          enumerable: true,\n          configurable: true\n        };\n      }\n      return {};\n    },\n    set,\n    deleteProperty: unsupportedOperation,\n    defineProperty: unsupportedOperation\n  });\n}\n"]}