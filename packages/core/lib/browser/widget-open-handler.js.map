{"version":3,"sources":["browser/widget-open-handler.ts"],"names":[],"mappings":"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","file":"../../src/browser/widget-open-handler.js","sourcesContent":["import {OpenerOptions, OpenHandler} from './opener-service';\nimport {ApplicationShell} from './shell';\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {BaseWidget} from './widgets';\nimport {WidgetManager} from './widget-manager';\nimport URI from '../common/uri';\nimport {Emitter, Event, MaybePromise} from '../common';\n\nexport type WidgetOpenMode = 'open' | 'reveal' | 'activate';\n\n/**\n * `WidgetOpenerOptions` define serializable generic options used by the {@link WidgetOpenHandler}.\n */\nexport interface WidgetOpenerOptions extends OpenerOptions {\n  /**\n   * Determines whether the widget should be only opened, revealed or activated.\n   * By default is `activate`.\n   */\n  mode?: WidgetOpenMode;\n  /**\n   * Specify how an opened widget should be added to the shell.\n   * By default to the main area.\n   */\n  widgetOptions?: ApplicationShell.WidgetOptions;\n}\n\n@injectable()\nexport abstract class WidgetOpenHandler<W extends BaseWidget> implements OpenHandler {\n\n  /**\n   * The widget open handler id.\n   *\n   * #### Implementation\n   * - A widget factory for this id should be registered.\n   * - Subclasses should not implement `WidgetFactory`\n   * to avoid exposing capabilities to create a widget outside of `WidgetManager`.\n   */\n  abstract readonly id: string;\n  @inject(ApplicationShell)\n  protected readonly shell: ApplicationShell;\n  @inject(WidgetManager)\n  protected readonly widgetManager: WidgetManager;\n  protected readonly onCreatedEmitter = new Emitter<W>();\n  /**\n   * Emit when a new widget is created.\n   */\n  readonly onCreated: Event<W> = this.onCreatedEmitter.event;\n\n  /**\n   * Retrieves all open widgets that have been opened by this handler.\n   *\n   * @returns all open widgets for this open handler.\n   */\n  get all(): W[] {\n    return this.widgetManager.getWidgets(this.id) as W[];\n  }\n\n  abstract canHandle(uri: URI, options?: WidgetOpenerOptions): MaybePromise<number>;\n\n  /**\n   * Open a widget for the given uri and options.\n   * Reject if the given options are not widget options or a widget cannot be opened.\n   * @param uri the uri of the resource that should be opened.\n   * @param options the widget opener options.\n   *\n   * @returns promise of the widget that resolves when the widget has been opened.\n   */\n  async open(uri: URI, options?: WidgetOpenerOptions): Promise<W> {\n    const widget = await this.getOrCreateWidget(uri, options);\n    await this.doOpen(widget, options);\n    return widget;\n  }\n\n  /**\n   * Tries to get an existing widget for the given uri.\n   * @param uri the uri of the widget.\n   *\n   * @returns a promise that resolves to the existing widget or `undefined` if no widget for the given uri exists.\n   */\n  getByUri(uri: URI): Promise<W | undefined> {\n    return this.getWidget(uri);\n  }\n\n  /**\n   * Return an existing widget for the given uri or creates a new one.\n   *\n   * It does not open a widget, use {@link WidgetOpenHandler#open} instead.\n   * @param uri uri of the widget.\n   *\n   * @returns a promise of the existing or newly created widget.\n   */\n  getOrCreateByUri(uri: URI): Promise<W> {\n    return this.getOrCreateWidget(uri);\n  }\n\n  /**\n   * Closes all widgets that have been opened by this open handler.\n   * @param options the close options that should be applied to all widgets.\n   *\n   * @returns a promise of all closed widgets that resolves after they have been closed.\n   */\n  async closeAll(options?: ApplicationShell.CloseOptions): Promise<W[]> {\n    const closed = await Promise.all(this.all.map(widget => this.shell.closeWidget(widget.id, options)));\n    return closed.filter(widget => !!widget) as W[];\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.widgetManager.onDidCreateWidget(({factoryId, widget}) => {\n      if (factoryId === this.id) {\n        this.onCreatedEmitter.fire(widget as W);\n      }\n    });\n  }\n\n  protected async doOpen(widget: W, options?: WidgetOpenerOptions): Promise<void> {\n    const op: WidgetOpenerOptions = {\n      mode: 'activate',\n      ...options\n    };\n    if (!widget.isAttached) {\n      this.shell.addWidget(widget, op.widgetOptions || {area: 'main'});\n    }\n    if (op.mode === 'activate') {\n      await this.shell.activateWidget(widget.id);\n    } else if (op.mode === 'reveal') {\n      await this.shell.revealWidget(widget.id);\n    }\n  }\n\n  protected tryGetPendingWidget(uri: URI, options?: WidgetOpenerOptions): MaybePromise<W> | undefined {\n    const factoryOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.tryGetPendingWidget(this.id, factoryOptions);\n  }\n\n  protected getWidget(uri: URI, options?: WidgetOpenerOptions): Promise<W | undefined> {\n    const widgetOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.getWidget<W>(this.id, widgetOptions);\n  }\n\n  protected getOrCreateWidget(uri: URI, options?: WidgetOpenerOptions): Promise<W> {\n    const widgetOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.getOrCreateWidget<W>(this.id, widgetOptions);\n  }\n\n  protected abstract createWidgetOptions(uri: URI, options?: WidgetOpenerOptions): Object;\n\n}\n"]}