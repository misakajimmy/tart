{"version":3,"sources":["browser/view-container.ts"],"names":[],"mappings":"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","file":"../../src/browser/view-container.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018-2019 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, interfaces, postConstruct} from 'inversify';\nimport {ArrayExt, every, find, IIterator, map, some, toArray} from '@lumino/algorithm';\nimport {\n  addEventListener,\n  addKeyListener,\n  BaseWidget,\n  CODICON_TREE_ITEM_CLASSES,\n  COLLAPSED_CLASS,\n  EXPANSION_TOGGLE_CLASS,\n  LayoutItem,\n  Message,\n  MessageLoop,\n  PanelLayout,\n  SplitLayout,\n  SplitPanel,\n  UnsafeWidgetUtilities,\n  waitForRevealed,\n  Widget\n} from './widgets';\nimport {Emitter, Event as CommonEvent, isEmpty} from '../common';\nimport {Disposable, DisposableCollection} from '../common/disposable';\nimport {CommandRegistry} from '../common/command';\nimport {MenuAction, MenuModelRegistry, MenuPath} from '../common/menu';\nimport {\n  ApplicationShell,\n  SIDE_PANEL_TOOLBAR_CONTEXT_MENU,\n  SplitPositionHandler,\n  SplitPositionOptions,\n  StatefulWidget\n} from './shell';\nimport {BOTTOM_AREA_ID, MAIN_AREA_ID} from './shell/tart-dock-panel';\nimport {FrontendApplicationStateService} from './frontend-application-state';\nimport {Anchor, ContextMenuRenderer} from './context-menu-renderer';\nimport {parseCssMagnitude} from './browser';\nimport {WidgetManager} from './widget-manager';\nimport {\n  TabBarDelegator,\n  TabBarToolbar,\n  TabBarToolbarFactory,\n  TabBarToolbarItem,\n  TabBarToolbarRegistry\n} from './shell/tab-bar-toolbar';\nimport {Key} from './keys';\nimport {ProgressBarFactory} from './progress-bar-factory';\nimport {TabBarDecoratorService} from './shell/tab-bar-decorator';\nimport {Drag, IDragEvent} from '@lumino/dragdrop';\nimport {ElementExt} from '@lumino/domutils';\nimport {MimeData} from '@lumino/coreutils';\nimport {DockPanel} from '@lumino/widgets';\n\nexport interface ViewContainerTitleOptions {\n  label: string;\n  caption?: string;\n  iconClass?: string;\n  closeable?: boolean;\n}\n\n@injectable()\nexport class ViewContainerIdentifier {\n  id: string;\n  progressLocationId?: string;\n}\n\nexport interface DescriptionWidget {\n  description: string;\n  onDidChangeDescription: Emitter<void>;\n}\n\nexport namespace DescriptionWidget {\n  export function is(arg: Object | undefined): arg is DescriptionWidget {\n    return !!arg && typeof arg === 'object' && 'onDidChangeDescription' in arg;\n  }\n}\n\n/**\n * A view container holds an arbitrary number of widgets inside a split panel.\n * Each widget is wrapped in a _part_ that displays the widget title and toolbar\n * and allows to collapse / expand the widget content.\n */\n@injectable()\nexport class ViewContainer extends BaseWidget implements StatefulWidget, ApplicationShell.TrackableWidgetProvider, TabBarDelegator {\n\n  /**\n   * Disable dragging parts from/to this view container.\n   */\n  disableDNDBetweenContainers = false;\n  @inject(ViewContainerIdentifier)\n  readonly options: ViewContainerIdentifier;\n  toDisposeOnDragEnd = new DisposableCollection();\n  protected panel: SplitPanel;\n  protected currentPart: ViewContainerPart | undefined;\n  @inject(FrontendApplicationStateService)\n  protected readonly applicationStateService: FrontendApplicationStateService;\n  @inject(ContextMenuRenderer)\n  protected readonly contextMenuRenderer: ContextMenuRenderer;\n  @inject(CommandRegistry)\n  protected readonly commandRegistry: CommandRegistry;\n  @inject(MenuModelRegistry)\n  protected readonly menuRegistry: MenuModelRegistry;\n  @inject(WidgetManager)\n  protected readonly widgetManager: WidgetManager;\n  @inject(SplitPositionHandler)\n  protected readonly splitPositionHandler: SplitPositionHandler;\n  @inject(TabBarToolbarRegistry)\n  protected readonly toolbarRegistry: TabBarToolbarRegistry;\n  @inject(TabBarToolbarFactory)\n  protected readonly toolbarFactory: TabBarToolbarFactory;\n  protected readonly onDidChangeTrackableWidgetsEmitter = new Emitter<Widget[]>();\n  readonly onDidChangeTrackableWidgets = this.onDidChangeTrackableWidgetsEmitter.event;\n  @inject(ProgressBarFactory)\n  protected readonly progressBarFactory: ProgressBarFactory;\n  @inject(ApplicationShell)\n  protected readonly shell: ApplicationShell;\n  @inject(TabBarDecoratorService)\n  protected readonly decoratorService: TabBarDecoratorService;\n  protected readonly toDisposeOnCurrentPart = new DisposableCollection();\n  protected titleOptions: ViewContainerTitleOptions | undefined;\n  protected readonly toDisposeOnUpdateTitle = new DisposableCollection();\n  protected _tabBarDelegate: Widget = this;\n  protected readonly toRemoveWidgets = new Map<string, DisposableCollection>();\n  protected lastVisibleState: ViewContainer.State | undefined;\n\n  get containerLayout(): ViewContainerLayout {\n    const layout = this.panel.layout;\n    if (layout instanceof ViewContainerLayout) {\n      return layout;\n    }\n    throw new Error('view container is disposed');\n  }\n\n  protected get orientation(): SplitLayout.Orientation {\n    return ViewContainer.getOrientation(this.node);\n  }\n\n  protected get enableAnimation(): boolean {\n    return this.applicationStateService.state === 'ready';\n  }\n\n  protected get contextMenuPath(): MenuPath {\n    return [`${this.id}-context-menu`];\n  }\n\n  protected get globalHideCommandId(): string {\n    return `${this.id}:toggle-visibility`;\n  }\n\n  setTitleOptions(titleOptions: ViewContainerTitleOptions | undefined): void {\n    this.titleOptions = titleOptions;\n    this.updateTitle();\n  }\n\n  updateTabBarDelegate(): void {\n    const visibleParts = this.getParts().filter(part => !part.isHidden);\n    if (visibleParts.length === 1) {\n      this._tabBarDelegate = visibleParts[0].wrapped;\n    } else {\n      this._tabBarDelegate = this;\n    }\n  }\n\n  getTabBarDelegate(): Widget | undefined {\n    return this._tabBarDelegate;\n  }\n\n  addWidget(widget: Widget, options?: ViewContainer.Factory.WidgetOptions, originalContainerId?: string, originalContainerTitle?: ViewContainerTitleOptions): Disposable {\n    const existing = this.toRemoveWidgets.get(widget.id);\n    if (existing) {\n      return existing;\n    }\n    const partId = this.createPartId(widget);\n    const newPart = this.createPart(widget, partId, originalContainerId || this.id, originalContainerTitle || this.titleOptions, options);\n    return this.attachNewPart(newPart);\n  }\n\n  removeWidget(widget: Widget): boolean {\n    const disposable = this.toRemoveWidgets.get(widget.id);\n    if (disposable) {\n      disposable.dispose();\n      return true;\n    }\n    return false;\n  }\n\n  getParts(): ViewContainerPart[] {\n    return this.containerLayout.widget;\n  }\n\n  getPartFor(widget: Widget): ViewContainerPart | undefined {\n    return this.getParts().find(p => p.wrapped.id === widget.id);\n  }\n\n  storeState(): ViewContainer.State {\n    if (!this.isVisible && this.lastVisibleState) {\n      return this.lastVisibleState;\n    }\n    return this.doStoreState();\n  }\n\n  restoreState(state: ViewContainer.State): void {\n    this.lastVisibleState = state;\n    this.doRestoreState(state);\n  }\n\n  getTrackableWidgets(): Widget[] {\n    return this.getParts().map(w => w.wrapped);\n  }\n\n  activateWidget(id: string): Widget | undefined {\n    const part = this.revealPart(id);\n    if (!part) {\n      return undefined;\n    }\n    this.updateCurrentPart(part);\n    part.collapsed = false;\n    return part.wrapped;\n  }\n\n  revealWidget(id: string): Widget | undefined {\n    const part = this.revealPart(id);\n    return part && part.wrapped;\n  }\n\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'p-dragenter':\n        this.handleDragEnter(event as IDragEvent);\n        break;\n      case 'p-dragover':\n        this.handleDragOver(event as IDragEvent);\n        break;\n      case 'p-dragleave':\n        this.handleDragLeave(event as IDragEvent);\n        break;\n      case 'p-drop':\n        this.handleDrop(event as IDragEvent);\n        break;\n    }\n  }\n\n  handleDragEnter(event: IDragEvent): void {\n    if (event.mimeData.hasData('application/vnd.phosphor.view-container-factory')) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  }\n\n  handleDragOver(event: IDragEvent): void {\n    const factory = event.mimeData.getData('application/vnd.phosphor.view-container-factory');\n    const widget = factory && factory();\n    if (!(widget instanceof ViewContainerPart)) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n\n    const sameContainers = this.id === widget.currentViewContainerId;\n    const targetPart = ArrayExt.findFirstValue(this.getParts(), (p => ElementExt.hitTest(p.node, event.clientX, event.clientY)));\n    if (!targetPart && sameContainers) {\n      event.dropAction = 'none';\n      return;\n    }\n    if (targetPart) {\n      // add overlay class style to the `targetPart` node.\n      targetPart.node.classList.add('drop-target');\n      this.toDisposeOnDragEnd.push(Disposable.create(() => targetPart.node.classList.remove('drop-target')));\n    } else {\n      // show panel overlay.\n      const dockPanel = this.getDockPanel();\n      if (dockPanel) {\n        dockPanel.overlay.show({top: 0, bottom: 0, right: 0, left: 0});\n        this.toDisposeOnDragEnd.push(Disposable.create(() => dockPanel.overlay.hide(100)));\n      }\n    }\n\n    const isDraggingOutsideDisabled = this.disableDNDBetweenContainers || widget.viewContainer?.disableDNDBetweenContainers\n        || widget.options.disableDraggingToOtherContainers;\n    if (isDraggingOutsideDisabled && !sameContainers) {\n      const {target} = event;\n      if (target instanceof HTMLElement) {\n        target.classList.add('tart-cursor-no-drop');\n        this.toDisposeOnDragEnd.push(Disposable.create(() => {\n          target.classList.remove('tart-cursor-no-drop');\n        }));\n      }\n      event.dropAction = 'none';\n      return;\n    }\n\n\n    event.dropAction = event.proposedAction;\n  };\n\n  handleDragLeave(event: IDragEvent): void {\n    this.toDisposeOnDragEnd.dispose();\n    if (event.mimeData.hasData('application/vnd.phosphor.view-container-factory')) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  handleDrop(event: IDragEvent): void {\n    this.toDisposeOnDragEnd.dispose();\n    const factory = event.mimeData.getData('application/vnd.phosphor.view-container-factory');\n    const draggedPart = factory && factory();\n    if (!(draggedPart instanceof ViewContainerPart)) {\n      event.dropAction = 'none';\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    const parts = this.getParts();\n    const toIndex = ArrayExt.findFirstIndex(parts, part => ElementExt.hitTest(part.node, event.clientX, event.clientY));\n    if (draggedPart.currentViewContainerId !== this.id) {\n      this.attachNewPart(draggedPart, toIndex > -1 ? toIndex + 1 : toIndex);\n      draggedPart.onPartMoved(this);\n    } else {\n      this.moveBefore(draggedPart.id, parts[toIndex].id);\n    }\n    event.dropAction = event.proposedAction;\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.id = this.options.id;\n    this.addClass('tart-view-container');\n    const layout = new PanelLayout();\n    this.layout = layout;\n    this.panel = new SplitPanel({\n      layout: new ViewContainerLayout({\n        renderer: SplitPanel.defaultRenderer,\n        orientation: this.orientation,\n        spacing: 2,\n        headerSize: ViewContainerPart.HEADER_HEIGHT,\n        animationDuration: 200\n      }, this.splitPositionHandler)\n    });\n    this.panel.node.tabIndex = -1;\n    this.configureLayout(layout);\n\n    const {commandRegistry, menuRegistry, contextMenuRenderer} = this;\n    this.toDispose.pushAll([\n      addEventListener(this.node, 'contextmenu', event => {\n        if (event.button === 2 && every(this.containerLayout.iter(), part => !!part.isHidden)) {\n          event.stopPropagation();\n          event.preventDefault();\n          contextMenuRenderer.render({menuPath: this.contextMenuPath, anchor: event});\n        }\n      }),\n      commandRegistry.registerCommand({id: this.globalHideCommandId}, {\n        execute: (anchor: Anchor) => {\n          const toHide = this.findPartForAnchor(anchor);\n          if (toHide && toHide.canHide) {\n            toHide.hide();\n          }\n        },\n        isVisible: (anchor: Anchor) => {\n          const toHide = this.findPartForAnchor(anchor);\n          if (toHide) {\n            return toHide.canHide && !toHide.isHidden;\n          } else {\n            return some(this.containerLayout.iter(), part => !part.isHidden);\n          }\n        }\n      }),\n      menuRegistry.registerMenuAction([...this.contextMenuPath, '0_global'], {\n        commandId: this.globalHideCommandId,\n        label: 'Hide'\n      }),\n      this.onDidChangeTrackableWidgetsEmitter,\n      this.onDidChangeTrackableWidgets(() => this.decoratorService.fireDidChangeDecorations())\n    ]);\n    if (this.options.progressLocationId) {\n      this.toDispose.push(this.progressBarFactory({\n        container: this.node,\n        insertMode: 'prepend',\n        locationId: this.options.progressLocationId\n      }));\n    }\n  }\n\n  protected configureLayout(layout: PanelLayout): void {\n    layout.addWidget(this.panel);\n  }\n\n  protected updateCurrentPart(part?: ViewContainerPart): void {\n    if (part && this.getParts().indexOf(part) !== -1) {\n      this.currentPart = part;\n    }\n    if (this.currentPart && !this.currentPart.isDisposed) {\n      return;\n    }\n    const visibleParts = this.getParts().filter(p => !p.isHidden);\n    const expandedParts = visibleParts.filter(p => !p.collapsed);\n    this.currentPart = expandedParts[0] || visibleParts[0];\n  }\n\n  protected updateTitle(): void {\n    this.toDisposeOnUpdateTitle.dispose();\n    this.toDispose.push(this.toDisposeOnUpdateTitle);\n    this.updateTabBarDelegate();\n    let title = Object.assign({}, this.titleOptions);\n    if (isEmpty(title)) {\n      return;\n    }\n    const allParts = this.getParts();\n    const visibleParts = allParts.filter(part => !part.isHidden);\n    this.title.label = title.label;\n    // If there's only one visible part - inline it's title into the container title except in case the part\n    // isn't originally belongs to this container but there are other **original** hidden parts.\n    if (visibleParts.length === 1 && (visibleParts[0].originalContainerId === this.id || !this.findOriginalPart())) {\n      const part = visibleParts[0];\n      this.toDisposeOnUpdateTitle.push(part.onTitleChanged(() => this.updateTitle()));\n      const partLabel = part.wrapped.title.label;\n      // Change the container title if it contains only one part that originally belongs to another container.\n      if (allParts.length === 1 && part.originalContainerId !== this.id && !this.isCurrentTitle(part.originalContainerTitle)) {\n        title = Object.assign({}, part.originalContainerTitle);\n        this.setTitleOptions(title);\n        return;\n      }\n      if (partLabel) {\n        if (this.title.label && this.title.label !== partLabel) {\n          this.title.label += ': ' + partLabel;\n        } else {\n          this.title.label = partLabel;\n        }\n      }\n      part.collapsed = false;\n      part.hideTitle();\n    } else {\n      visibleParts.forEach(part => part.showTitle());\n      // If at least one part originally belongs to this container the title should return to its original value.\n      const originalPart = this.findOriginalPart();\n      if (originalPart && !this.isCurrentTitle(originalPart.originalContainerTitle)) {\n        title = Object.assign({}, originalPart.originalContainerTitle);\n        this.setTitleOptions(title);\n        return;\n      }\n    }\n    this.updateToolbarItems(allParts);\n    const caption = title?.caption || title?.label;\n    if (caption) {\n      this.title.caption = caption;\n      if (visibleParts.length === 1) {\n        const partCaption = visibleParts[0].wrapped.title.caption || visibleParts[0].wrapped.title.label;\n        if (partCaption) {\n          this.title.caption += ': ' + partCaption;\n        }\n      }\n    }\n    if (title.iconClass) {\n      this.title.iconClass = title.iconClass;\n    }\n    if (title.closeable !== undefined) {\n      this.title.closable = title.closeable;\n    }\n  }\n\n  protected updateToolbarItems(allParts: ViewContainerPart[]): void {\n    if (allParts.length > 1) {\n      const group = this.getToggleVisibilityGroupLabel();\n      for (const part of allParts) {\n        const existingId = this.toggleVisibilityCommandId(part);\n        const {caption, label, dataset: {visibilityCommandLabel}} = part.wrapped.title;\n        this.registerToolbarItem(existingId, {tooltip: visibilityCommandLabel || caption || label, group});\n      }\n    }\n  }\n\n  protected getToggleVisibilityGroupLabel(): string {\n    return 'view';\n  }\n\n  protected registerToolbarItem(commandId: string, options?: Partial<Omit<TabBarToolbarItem, 'id' | 'command'>>): void {\n    const newId = `${this.id}-tabbar-toolbar-${commandId}`;\n    const existingHandler = this.commandRegistry.getAllHandlers(commandId)[0];\n    const existingCommand = this.commandRegistry.getCommand(commandId);\n    if (existingHandler && existingCommand) {\n      this.toDisposeOnUpdateTitle.push(this.commandRegistry.registerCommand({...existingCommand, id: newId}, {\n        execute: (_widget, ...args) => this.commandRegistry.executeCommand(commandId, ...args),\n        isToggled: (_widget, ...args) => this.commandRegistry.isToggled(commandId, ...args),\n        isEnabled: (_widget, ...args) => this.commandRegistry.isEnabled(commandId, ...args),\n        isVisible: (widget, ...args) => widget === this.getTabBarDelegate() && this.commandRegistry.isVisible(commandId, ...args),\n      }));\n      this.toDisposeOnUpdateTitle.push(this.toolbarRegistry.registerItem({\n        ...options,\n        id: newId,\n        command: newId,\n      }));\n    }\n  }\n\n  protected findOriginalPart(): ViewContainerPart | undefined {\n    return this.getParts().find(part => part.originalContainerId === this.id);\n  }\n\n  protected isCurrentTitle(titleOptions: ViewContainerTitleOptions | undefined): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (!!titleOptions && !!this.titleOptions && Object.keys(titleOptions).every(key => (titleOptions as any)[key] === (this.titleOptions as any)[key]))\n        || (!titleOptions && !this.titleOptions);\n  }\n\n  protected findPartForAnchor(anchor: Anchor): ViewContainerPart | undefined {\n    const element = document.elementFromPoint(anchor.x, anchor.y);\n    if (element instanceof Element) {\n      const closestPart = ViewContainerPart.closestPart(element);\n      if (closestPart && closestPart.id) {\n        return find(this.containerLayout.iter(), part => part.id === closestPart.id);\n      }\n    }\n    return undefined;\n  }\n\n  protected createPartId(widget: Widget): string {\n    const description = this.widgetManager.getDescription(widget);\n    return widget.id || JSON.stringify(description);\n  }\n\n  protected attachNewPart(newPart: ViewContainerPart, insertIndex?: number): Disposable {\n    const toRemoveWidget = new DisposableCollection();\n    this.toDispose.push(toRemoveWidget);\n    this.toRemoveWidgets.set(newPart.wrapped.id, toRemoveWidget);\n    toRemoveWidget.push(Disposable.create(() => this.toRemoveWidgets.delete(newPart.wrapped.id)));\n    this.registerPart(newPart);\n    if (insertIndex !== undefined || (newPart.options && newPart.options.order !== undefined)) {\n      const index = insertIndex ?? this.getParts().findIndex(part => part.options.order === undefined || part.options.order > newPart.options.order!);\n      if (index >= 0) {\n        this.containerLayout.insertWidget(index, newPart);\n      } else {\n        this.containerLayout.addWidget(newPart);\n      }\n    } else {\n      this.containerLayout.addWidget(newPart);\n    }\n    this.refreshMenu(newPart);\n    this.updateTitle();\n    this.updateCurrentPart();\n    this.update();\n    this.fireDidChangeTrackableWidgets();\n    toRemoveWidget.pushAll([\n      Disposable.create(() => {\n        if (newPart.currentViewContainerId === this.id) {\n          newPart.dispose();\n        }\n        this.unregisterPart(newPart);\n        if (!newPart.isDisposed && this.getPartIndex(newPart.id) > -1) {\n          this.containerLayout.removeWidget(newPart);\n        }\n        if (!this.isDisposed) {\n          this.update();\n          this.updateTitle();\n          this.updateCurrentPart();\n          this.fireDidChangeTrackableWidgets();\n        }\n      }),\n      this.registerDND(newPart),\n      newPart.onDidChangeVisibility(() => {\n        this.updateTitle();\n        this.updateCurrentPart();\n      }),\n      newPart.onCollapsed(() => {\n        this.containerLayout.updateCollapsed(newPart, this.enableAnimation);\n        this.updateCurrentPart();\n      }),\n      newPart.onContextMenu(event => {\n        if (event.button === 2) {\n          event.preventDefault();\n          event.stopPropagation();\n          this.contextMenuRenderer.render({menuPath: this.contextMenuPath, anchor: event});\n        }\n      }),\n      newPart.onTitleChanged(() => this.refreshMenu(newPart)),\n      newPart.onDidFocus(() => this.updateCurrentPart(newPart))\n    ]);\n\n    newPart.disposed.connect(() => toRemoveWidget.dispose());\n    return toRemoveWidget;\n  }\n\n  protected createPart(widget: Widget, partId: string, originalContainerId: string, originalContainerTitle?: ViewContainerTitleOptions,\n                       options?: ViewContainer.Factory.WidgetOptions): ViewContainerPart {\n\n    return new ViewContainerPart(widget, partId, this.id, originalContainerId, originalContainerTitle, this.toolbarRegistry, this.toolbarFactory, options);\n  }\n\n  protected getPartIndex(partId: string | undefined): number {\n    if (partId) {\n      return this.getParts().findIndex(part => part.id === partId);\n    }\n    return -1;\n  }\n\n  protected doStoreState(): ViewContainer.State {\n    const parts = this.getParts();\n    const availableSize = this.containerLayout.getAvailableSize();\n    const orientation = this.orientation;\n    const partStates = parts.map(part => {\n      let size = this.containerLayout.getPartSize(part);\n      if (size && size > ViewContainerPart.HEADER_HEIGHT && orientation === 'vertical') {\n        size -= ViewContainerPart.HEADER_HEIGHT;\n      }\n      return <ViewContainerPart.State>{\n        widget: part.wrapped,\n        partId: part.partId,\n        collapsed: part.collapsed,\n        hidden: part.isHidden,\n        relativeSize: size && availableSize ? size / availableSize : undefined,\n        originalContainerId: part.originalContainerId,\n        originalContainerTitle: part.originalContainerTitle\n      };\n    });\n    return {parts: partStates, title: this.titleOptions};\n  }\n\n  protected doRestoreState(state: ViewContainer.State): void {\n    this.setTitleOptions(state.title);\n    // restore widgets\n    for (const part of state.parts) {\n      if (part.widget) {\n        this.addWidget(part.widget, undefined, part.originalContainerId, part.originalContainerTitle || {} as ViewContainerTitleOptions);\n      }\n    }\n    const partStates = state.parts.filter(partState => some(this.containerLayout.iter(), p => p.partId === partState.partId));\n\n    // Reorder the parts according to the stored state\n    for (let index = 0; index < partStates.length; index++) {\n      const partState = partStates[index];\n      const currentIndex = this.getParts().findIndex(part => part.partId === partState.partId);\n      if (currentIndex > index) {\n        this.containerLayout.moveWidget(currentIndex, index, this.getParts()[currentIndex]);\n      }\n    }\n\n    // Restore visibility and collapsed state\n    const parts = this.getParts();\n    for (let index = 0; index < parts.length; index++) {\n      const part = parts[index];\n      const partState = partStates.find(s => part.partId === s.partId);\n      if (partState) {\n        part.setHidden(partState.hidden);\n        part.collapsed = partState.collapsed || !partState.relativeSize;\n      } else if (part.canHide) {\n        part.hide();\n      }\n      this.refreshMenu(part);\n    }\n\n    // Restore part sizes\n    waitForRevealed(this).then(() => {\n      this.containerLayout.setPartSizes(partStates.map(partState => partState.relativeSize));\n    });\n  }\n\n  /**\n   * Register a command to toggle the visibility of the new part.\n   */\n  protected registerPart(toRegister: ViewContainerPart): void {\n    const commandId = this.toggleVisibilityCommandId(toRegister);\n    this.commandRegistry.registerCommand({id: commandId}, {\n      execute: () => {\n        const toHide = find(this.containerLayout.iter(), part => part.id === toRegister.id);\n        if (toHide) {\n          toHide.setHidden(!toHide.isHidden);\n        }\n      },\n      isToggled: () => {\n        if (!toRegister.canHide) {\n          return true;\n        }\n        const widgetToToggle = find(this.containerLayout.iter(), part => part.id === toRegister.id);\n        if (widgetToToggle) {\n          return !widgetToToggle.isHidden;\n        }\n        return false;\n      },\n      isEnabled: arg => toRegister.canHide && (!this.titleOptions || !(arg instanceof Widget) || (arg instanceof ViewContainer && arg.id === this.id)),\n      isVisible: arg => !this.titleOptions || !(arg instanceof Widget) || (arg instanceof ViewContainer && arg.id === this.id)\n    });\n  }\n\n  /**\n   * Register a menu action to toggle the visibility of the new part.\n   * The menu action is unregistered first to enable refreshing the order of menu actions.\n   */\n  protected refreshMenu(part: ViewContainerPart): void {\n    const commandId = this.toggleVisibilityCommandId(part);\n    this.menuRegistry.unregisterMenuAction(commandId);\n    if (!part.wrapped.title.label) {\n      return;\n    }\n    const {dataset: {visibilityCommandLabel}, caption, label} = part.wrapped.title;\n    const action: MenuAction = {\n      commandId: commandId,\n      label: visibilityCommandLabel || caption || label,\n      order: this.getParts().indexOf(part).toString()\n    };\n    this.menuRegistry.registerMenuAction([...this.contextMenuPath, '1_widgets'], action);\n    if (this.titleOptions) {\n      this.menuRegistry.registerMenuAction([...SIDE_PANEL_TOOLBAR_CONTEXT_MENU, 'navigation'], action);\n    }\n  }\n\n  protected unregisterPart(part: ViewContainerPart): void {\n    const commandId = this.toggleVisibilityCommandId(part);\n    this.commandRegistry.unregisterCommand(commandId);\n    this.menuRegistry.unregisterMenuAction(commandId);\n  }\n\n  protected toggleVisibilityCommandId(part: ViewContainerPart): string {\n    return `${this.id}:toggle-visibility-${part.id}`;\n  }\n\n  protected moveBefore(toMovedId: string, moveBeforeThisId: string): void {\n    const parts = this.getParts();\n    const toMoveIndex = parts.findIndex(part => part.id === toMovedId);\n    const moveBeforeThisIndex = parts.findIndex(part => part.id === moveBeforeThisId);\n    if (toMoveIndex >= 0 && moveBeforeThisIndex >= 0) {\n      this.containerLayout.moveWidget(toMoveIndex, moveBeforeThisIndex, parts[toMoveIndex]);\n      for (let index = Math.min(toMoveIndex, moveBeforeThisIndex); index < parts.length; index++) {\n        this.refreshMenu(parts[index]);\n        this.activate();\n      }\n    }\n  }\n\n  protected fireDidChangeTrackableWidgets(): void {\n    this.onDidChangeTrackableWidgetsEmitter.fire(this.getTrackableWidgets());\n  }\n\n  protected revealPart(id: string): ViewContainerPart | undefined {\n    const part = this.getParts().find(p => p.wrapped.id === id);\n    if (!part) {\n      return undefined;\n    }\n    part.setHidden(false);\n    return part;\n  }\n\n  protected onActivateRequest(msg: Message): void {\n    super.onActivateRequest(msg);\n    if (this.currentPart) {\n      this.currentPart.activate();\n    } else {\n      this.panel.node.focus({preventScroll: true});\n    }\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    const orientation = this.orientation;\n    this.containerLayout.orientation = orientation;\n    if (orientation === 'horizontal') {\n      for (const part of this.getParts()) {\n        part.collapsed = false;\n      }\n    }\n    super.onAfterAttach(msg);\n  }\n\n  protected onBeforeHide(msg: Message): void {\n    super.onBeforeHide(msg);\n    this.lastVisibleState = this.storeState();\n  }\n\n  protected onAfterShow(msg: Message): void {\n    super.onAfterShow(msg);\n    this.updateTitle();\n    this.lastVisibleState = undefined;\n  }\n\n  protected onBeforeAttach(msg: Message): void {\n    super.onBeforeAttach(msg);\n    this.node.addEventListener('p-dragenter', this, true);\n    this.node.addEventListener('p-dragover', this, true);\n    this.node.addEventListener('p-dragleave', this, true);\n    this.node.addEventListener('p-drop', this, true);\n  }\n\n  protected onAfterDetach(msg: Message): void {\n    super.onAfterDetach(msg);\n    this.node.removeEventListener('p-dragenter', this, true);\n    this.node.removeEventListener('p-dragover', this, true);\n    this.node.removeEventListener('p-dragleave', this, true);\n    this.node.removeEventListener('p-drop', this, true);\n  }\n\n  protected registerDND(part: ViewContainerPart): Disposable {\n    part.headerElement.draggable = true;\n\n    return new DisposableCollection(\n        addEventListener(part.headerElement, 'dragstart',\n            event => {\n              event.preventDefault();\n              const mimeData = new MimeData();\n              mimeData.setData('application/vnd.phosphor.view-container-factory', () => part);\n              const clonedHeader = part.headerElement.cloneNode(true) as HTMLElement;\n              clonedHeader.style.width = part.node.style.width;\n              clonedHeader.style.opacity = '0.6';\n              const drag = new Drag({\n                mimeData,\n                dragImage: clonedHeader,\n                proposedAction: 'move',\n                supportedActions: 'move'\n              });\n              part.node.classList.add('p-mod-hidden');\n              drag.start(event.clientX, event.clientY).then(dropAction => {\n                // The promise is resolved when the drag has ended\n                if (dropAction === 'move' && part.currentViewContainerId !== this.id) {\n                  this.removeWidget(part.wrapped);\n                  this.lastVisibleState = this.doStoreState();\n                }\n              });\n              setTimeout(() => {\n                part.node.classList.remove('p-mod-hidden');\n              }, 0);\n            }, false));\n  }\n\n  protected getDockPanel(): DockPanel | undefined {\n    let panel: DockPanel | undefined;\n    let parent = this.parent;\n    while (!panel && parent) {\n      if (this.isSideDockPanel(parent)) {\n        panel = parent as DockPanel;\n      } else {\n        parent = parent.parent;\n      }\n    }\n    return panel;\n  }\n\n  protected isSideDockPanel(widget: Widget): boolean {\n    // @ts-ignore\n    const {leftPanelHandler, rightPanelHandler} = this.shell;\n    if (widget instanceof DockPanel && (widget.id === rightPanelHandler.dockPanel.id || widget.id === leftPanelHandler.dockPanel.id)) {\n      return true;\n    }\n    return false;\n  }\n\n}\n\nexport namespace ViewContainer {\n\n  export const Factory = Symbol('ViewContainerFactory');\n\n  export interface Factory {\n    (options: ViewContainerIdentifier): ViewContainer;\n  }\n\n  export namespace Factory {\n\n    export interface WidgetOptions {\n      readonly order?: number;\n      readonly weight?: number;\n      readonly initiallyCollapsed?: boolean;\n      readonly canHide?: boolean;\n      readonly initiallyHidden?: boolean;\n      /**\n       * Disable dragging this part from its original container to other containers,\n       * But allow dropping parts from other containers on it,\n       * This option only applies to the `ViewContainerPart` and has no effect on the ViewContainer.\n       */\n      readonly disableDraggingToOtherContainers?: boolean;\n    }\n\n    export interface WidgetDescriptor {\n      readonly widget: Widget | interfaces.ServiceIdentifier<Widget>;\n      readonly options?: WidgetOptions;\n    }\n\n  }\n\n  export interface State {\n    title?: ViewContainerTitleOptions;\n    parts: ViewContainerPart.State[]\n  }\n\n  export function getOrientation(node: HTMLElement): 'horizontal' | 'vertical' {\n    if (node.closest(`#${MAIN_AREA_ID}`) || node.closest(`#${BOTTOM_AREA_ID}`)) {\n      return 'horizontal';\n    }\n    return 'vertical';\n  }\n}\n\n/**\n * Wrapper around a widget held by a view container. Adds a header to display the\n * title, toolbar, and collapse / expand handle.\n */\nexport class ViewContainerPart extends BaseWidget {\n\n  /**\n   * @deprecated since 0.11.0, use `onDidChangeVisibility` instead\n   */\n  readonly onVisibilityChanged = this.onDidChangeVisibility;\n  uncollapsedSize: number | undefined;\n  animatedSize: number | undefined;\n  protected readonly header: HTMLElement;\n  protected readonly body: HTMLElement;\n  protected readonly collapsedEmitter = new Emitter<boolean>();\n  protected readonly contextMenuEmitter = new Emitter<MouseEvent>();\n  protected readonly onTitleChangedEmitter = new Emitter<void>();\n  readonly onTitleChanged = this.onTitleChangedEmitter.event;\n  protected readonly onDidFocusEmitter = new Emitter<this>();\n  readonly onDidFocus = this.onDidFocusEmitter.event;\n  protected readonly onPartMovedEmitter = new Emitter<ViewContainer>();\n  readonly onDidMove = this.onPartMovedEmitter.event;\n  protected readonly onDidChangeDescriptionEmitter = new Emitter<void>();\n  readonly onDidChangeDescription = this.onDidChangeDescriptionEmitter.event;\n  protected readonly toolbar: TabBarToolbar;\n  protected readonly toNoDisposeWrapped: Disposable;\n  protected readonly toShowHeader = new DisposableCollection();\n\n  constructor(\n      readonly wrapped: Widget,\n      readonly partId: string,\n      protected currentContainerId: string,\n      readonly originalContainerId: string,\n      readonly originalContainerTitle: ViewContainerTitleOptions | undefined,\n      protected readonly toolbarRegistry: TabBarToolbarRegistry,\n      protected readonly toolbarFactory: TabBarToolbarFactory,\n      readonly options: ViewContainer.Factory.WidgetOptions = {}\n  ) {\n    super();\n    wrapped.parent = this;\n    wrapped.disposed.connect(() => this.dispose());\n    this.id = `${originalContainerId}--${wrapped.id}`;\n    this.addClass('part');\n\n    const fireTitleChanged = () => this.onTitleChangedEmitter.fire(undefined);\n    this.wrapped.title.changed.connect(fireTitleChanged);\n    this.toDispose.push(Disposable.create(() => this.wrapped.title.changed.disconnect(fireTitleChanged)));\n\n    if (DescriptionWidget.is(this.wrapped)) {\n      const fireDescriptionChanged = () => this.onDidChangeDescriptionEmitter.fire(undefined);\n      this.toDispose.push(this.wrapped?.onDidChangeDescription.event(fireDescriptionChanged));\n    }\n\n    const {header, body, disposable} = this.createContent();\n    this.header = header;\n    this.body = body;\n\n    this.toNoDisposeWrapped = this.toDispose.push(wrapped);\n    this.toolbar = this.toolbarFactory();\n    this.toolbar.addClass('tart-view-container-part-title');\n\n    this.toolbar.updateTarget(this.wrapped);\n\n    this.toDispose.pushAll([\n      disposable,\n      this.toolbar,\n      this.toolbar.onExecuteCommand(() => this.toolbar.updateTarget(this.wrapped)),\n      this.toolbarRegistry.onDidChange(() => this.toolbar.updateTarget(this.wrapped)),\n      this.collapsedEmitter,\n      this.contextMenuEmitter,\n      this.onTitleChangedEmitter,\n      this.onDidChangeDescriptionEmitter,\n      this.registerContextMenu(),\n      this.onDidFocusEmitter,\n      // focus event does not bubble, capture it\n      addEventListener(this.node, 'focus', () => this.onDidFocusEmitter.fire(this), true)\n    ])\n    ;\n    this.scrollOptions = {\n      suppressScrollX: true,\n      minScrollbarLength: 35\n    };\n    this.collapsed = !!options.initiallyCollapsed;\n    if (options.initiallyHidden && this.canHide) {\n      this.hide();\n    }\n  }\n\n  protected _collapsed: boolean;\n\n  get collapsed(): boolean {\n    return this._collapsed;\n  }\n\n  set collapsed(collapsed: boolean) {\n    // Cannot collapse/expand if the orientation of the container is `horizontal`.\n    const orientation = ViewContainer.getOrientation(this.node);\n    if (this._collapsed === collapsed || orientation === 'horizontal' && collapsed) {\n      return;\n    }\n    this._collapsed = collapsed;\n    this.node.classList.toggle('collapsed', collapsed);\n    if (collapsed && this.wrapped.node.contains(document.activeElement)) {\n      this.header.focus();\n    }\n    this.wrapped.setHidden(collapsed);\n    const toggleIcon = this.header.querySelector(`span.${EXPANSION_TOGGLE_CLASS}`);\n    if (toggleIcon) {\n      if (collapsed) {\n        toggleIcon.classList.add(COLLAPSED_CLASS);\n      } else {\n        toggleIcon.classList.remove(COLLAPSED_CLASS);\n      }\n    }\n    this.update();\n    this.collapsedEmitter.fire(collapsed);\n  }\n\n  get viewContainer(): ViewContainer | undefined {\n    return this.parent ? this.parent.parent as ViewContainer : undefined;\n  }\n\n  get currentViewContainerId(): string {\n    return this.currentContainerId;\n  }\n\n  get headerElement(): HTMLElement {\n    return this.header;\n  }\n\n  get canHide(): boolean {\n    return this.options.canHide === undefined || this.options.canHide;\n  }\n\n  get onCollapsed(): CommonEvent<boolean> {\n    return this.collapsedEmitter.event;\n  }\n\n  get onContextMenu(): CommonEvent<MouseEvent> {\n    return this.contextMenuEmitter.event;\n  }\n\n  get minSize(): number {\n    const style = getComputedStyle(this.body);\n    if (ViewContainer.getOrientation(this.node) === 'horizontal') {\n      return parseCssMagnitude(style.minWidth, 0);\n    } else {\n      return parseCssMagnitude(style.minHeight, 0);\n    }\n  }\n\n  get titleHidden(): boolean {\n    return !this.toShowHeader.disposed || this.collapsed;\n  }\n\n  onPartMoved(newContainer: ViewContainer): void {\n    this.currentContainerId = newContainer.id;\n    this.onPartMovedEmitter.fire(newContainer);\n  }\n\n  setHidden(hidden: boolean): void {\n    if (!this.canHide) {\n      return;\n    }\n    super.setHidden(hidden);\n  }\n\n  showTitle(): void {\n    this.toShowHeader.dispose();\n  }\n\n  hideTitle(): void {\n    if (this.titleHidden) {\n      return;\n    }\n    const display = this.header.style.display;\n    const height = this.body.style.height;\n    this.body.style.height = '100%';\n    this.header.style.display = 'none';\n    this.toShowHeader.push(Disposable.create(() => {\n      this.header.style.display = display;\n      this.body.style.height = height;\n    }));\n  }\n\n  protected getScrollContainer(): HTMLElement {\n    return this.body;\n  }\n\n  protected registerContextMenu(): Disposable {\n    return new DisposableCollection(\n        addEventListener(this.header, 'contextmenu', event => {\n          this.contextMenuEmitter.fire(event);\n        })\n    );\n  }\n\n  protected createContent(): { header: HTMLElement, body: HTMLElement, disposable: Disposable } {\n    const disposable = new DisposableCollection();\n    const {header, disposable: headerDisposable} = this.createHeader();\n    const body = document.createElement('div');\n    body.classList.add('body');\n    this.node.appendChild(header);\n    this.node.appendChild(body);\n    disposable.push(headerDisposable);\n    return {\n      header,\n      body,\n      disposable,\n    };\n  }\n\n  protected createHeader(): { header: HTMLElement, disposable: Disposable } {\n    const disposable = new DisposableCollection();\n    const header = document.createElement('div');\n    header.tabIndex = 0;\n    header.classList.add('tart-header', 'header', 'tart-view-container-part-header');\n    disposable.push(addEventListener(header, 'click', event => {\n      if (this.toolbar && this.toolbar.shouldHandleMouseEvent(event)) {\n        return;\n      }\n      this.collapsed = !this.collapsed;\n    }));\n    disposable.push(addKeyListener(header, Key.ARROW_LEFT, () => this.collapsed = true));\n    disposable.push(addKeyListener(header, Key.ARROW_RIGHT, () => this.collapsed = false));\n    disposable.push(addKeyListener(header, Key.ENTER, () => this.collapsed = !this.collapsed));\n\n    const toggleIcon = document.createElement('span');\n    toggleIcon.classList.add(EXPANSION_TOGGLE_CLASS, ...CODICON_TREE_ITEM_CLASSES);\n    if (this.collapsed) {\n      toggleIcon.classList.add(COLLAPSED_CLASS);\n    }\n    header.appendChild(toggleIcon);\n\n    const title = document.createElement('span');\n    title.classList.add('label', 'noselect');\n\n    const description = document.createElement('span');\n    description.classList.add('description');\n\n    const updateTitle = () => {\n      if (this.currentContainerId !== this.originalContainerId && this.originalContainerTitle?.label) {\n        // Creating a title in format: <original_container_title>: <part_title>.\n        title.innerText = this.originalContainerTitle.label + ': ' + this.wrapped.title.label;\n      } else {\n        title.innerText = this.wrapped.title.label;\n      }\n    };\n    const updateCaption = () => title.title = this.wrapped.title.caption || this.wrapped.title.label;\n    const updateDescription = () => {\n      description.innerText = DescriptionWidget.is(this.wrapped) && !this.collapsed && this.wrapped.description || '';\n    };\n\n    updateTitle();\n    updateCaption();\n    updateDescription();\n\n    disposable.pushAll([\n      this.onTitleChanged(updateTitle),\n      this.onTitleChanged(updateCaption),\n      this.onDidMove(updateTitle),\n      this.onDidChangeDescription(updateDescription),\n      this.onCollapsed(updateDescription)\n    ]);\n    header.appendChild(title);\n    header.appendChild(description);\n\n    return {\n      header,\n      disposable\n    };\n  }\n\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, Widget.ResizeMessage.UnknownSize);\n    }\n    super.onResize(msg);\n  }\n\n  protected onUpdateRequest(msg: Message): void {\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, msg);\n    }\n    super.onUpdateRequest(msg);\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    if (!this.wrapped.isAttached) {\n      UnsafeWidgetUtilities.attach(this.wrapped, this.body);\n    }\n    UnsafeWidgetUtilities.attach(this.toolbar, this.header);\n    super.onAfterAttach(msg);\n  }\n\n  protected onBeforeDetach(msg: Message): void {\n    super.onBeforeDetach(msg);\n    if (this.toolbar.isAttached) {\n      Widget.detach(this.toolbar);\n    }\n    if (this.wrapped.isAttached) {\n      UnsafeWidgetUtilities.detach(this.wrapped);\n    }\n  }\n\n  protected onBeforeShow(msg: Message): void {\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, msg);\n    }\n    super.onBeforeShow(msg);\n  }\n\n  protected onAfterShow(msg: Message): void {\n    super.onAfterShow(msg);\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, msg);\n    }\n  }\n\n  protected onBeforeHide(msg: Message): void {\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, msg);\n    }\n    super.onBeforeShow(msg);\n  }\n\n  protected onAfterHide(msg: Message): void {\n    super.onAfterHide(msg);\n    if (this.wrapped.isAttached && !this.collapsed) {\n      MessageLoop.sendMessage(this.wrapped, msg);\n    }\n  }\n\n  protected onChildRemoved(msg: Widget.ChildMessage): void {\n    super.onChildRemoved(msg);\n    // if wrapped is not disposed, but detached then we should not dispose it, but only get rid of this part\n    this.toNoDisposeWrapped.dispose();\n    this.dispose();\n  }\n\n  protected onActivateRequest(msg: Message): void {\n    super.onActivateRequest(msg);\n    if (this.collapsed) {\n      this.header.focus();\n    } else {\n      this.wrapped.activate();\n    }\n  }\n\n}\n\nexport namespace ViewContainerPart {\n\n  /**\n   * Make sure to adjust the `line-height` of the `.tart-view-container .part > .header` CSS class when modifying this, and vice versa.\n   */\n  export const HEADER_HEIGHT = 22;\n\n  export interface State {\n    widget?: Widget\n    partId: string;\n    collapsed: boolean;\n    hidden: boolean;\n    relativeSize?: number;\n    description?: string;\n    /** The original container to which this part belongs */\n    originalContainerId: string;\n    originalContainerTitle?: ViewContainerTitleOptions;\n  }\n\n  export function closestPart(element: Element | EventTarget | null, selector: string = 'div.part'): Element | undefined {\n    if (element instanceof Element) {\n      const part = element.closest(selector);\n      if (part instanceof Element) {\n        return part;\n      }\n    }\n    return undefined;\n  }\n}\n\nexport class ViewContainerLayout extends SplitLayout {\n\n  constructor(protected options: ViewContainerLayout.Options, protected readonly splitPositionHandler: SplitPositionHandler) {\n    super(options);\n  }\n\n  get widget(): ViewContainerPart[] {\n    return toArray(this.iter());\n  }\n\n  protected get items(): ReadonlyArray<LayoutItem & ViewContainerLayout.Item> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this as any)._items as Array<LayoutItem & ViewContainerLayout.Item>;\n  }\n\n  iter(): IIterator<ViewContainerPart> {\n    return map(this.items, item => item.widget);\n  }\n\n  attachWidget(index: number, widget: ViewContainerPart): void {\n    super.attachWidget(index, widget);\n    if (index > -1 && this.parent && this.parent.node.contains(this.widget[index + 1]?.node)) {\n      // Set the correct attach index to the DOM elements.\n      const ref = this.widget[index + 1].node;\n      this.parent.node.insertBefore(widget.node, ref);\n      this.parent.node.insertBefore(this.handles[index], ref);\n      this.parent.fit();\n    }\n  }\n\n  moveWidget(fromIndex: number, toIndex: number, widget: Widget): void {\n    const ref = this.widget[toIndex < fromIndex ? toIndex : toIndex + 1];\n    super.moveWidget(fromIndex, toIndex, widget);\n    // Keep the order of `_widget` array just as done before (by `super`) for the `_items` array -\n    // to prevent later bugs relying on index.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ArrayExt.move((this as any)._widget, fromIndex, toIndex);\n    if (ref) {\n      this.parent!.node.insertBefore(this.handles[toIndex], ref.node);\n    } else {\n      this.parent!.node.appendChild(this.handles[toIndex]);\n    }\n    UnsafeWidgetUtilities.detach(widget);\n    UnsafeWidgetUtilities.attach(widget, this.parent!.node, this.handles[toIndex]);\n  }\n\n  getPartSize(part: ViewContainerPart): number | undefined {\n    if (part.collapsed || part.isHidden) {\n      return part.uncollapsedSize;\n    }\n    if (this.orientation === 'horizontal') {\n      return part.node.offsetWidth;\n    } else {\n      return part.node.offsetHeight;\n    }\n  }\n\n  /**\n   * Set the sizes of the view container parts according to the given weights\n   * by moving the split handles. This is similar to `setRelativeSizes` defined\n   * in `SplitLayout`, but here we properly consider the collapsed / expanded state.\n   */\n  setPartSizes(weights: (number | undefined)[]): void {\n    const parts = this.widget;\n    const availableSize = this.getAvailableSize();\n\n    // Sum up the weights of visible parts\n    let totalWeight = 0;\n    let weightCount = 0;\n    for (let index = 0; index < weights.length && index < parts.length; index++) {\n      const part = parts[index];\n      const weight = weights[index];\n      if (weight && !part.isHidden && !part.collapsed) {\n        totalWeight += weight;\n        weightCount++;\n      }\n    }\n    if (weightCount === 0 || availableSize === 0) {\n      return;\n    }\n\n    // Add the average weight for visible parts without weight\n    const averageWeight = totalWeight / weightCount;\n    for (let index = 0; index < weights.length && index < parts.length; index++) {\n      const part = parts[index];\n      const weight = weights[index];\n      if (!weight && !part.isHidden && !part.collapsed) {\n        totalWeight += averageWeight;\n      }\n    }\n\n    // Apply the weights to compute actual sizes\n    let position = 0;\n    for (let index = 0; index < weights.length && index < parts.length - 1; index++) {\n      const part = parts[index];\n      if (!part.isHidden) {\n        if (this.orientation === 'vertical') {\n          position += this.options.headerSize;\n        }\n        const weight = weights[index];\n        if (part.collapsed) {\n          if (weight) {\n            part.uncollapsedSize = weight / totalWeight * availableSize;\n          }\n        } else {\n          let contentSize = (weight || averageWeight) / totalWeight * availableSize;\n          const minSize = part.minSize;\n          if (contentSize < minSize) {\n            contentSize = minSize;\n          }\n          position += contentSize;\n        }\n        this.setHandlePosition(index, position);\n        position += this.spacing;\n      }\n    }\n  }\n\n  /**\n   * Determine the size of the split panel area that is available for widget content,\n   * i.e. excluding part headers and split handles.\n   */\n  getAvailableSize(): number {\n    if (!this.parent || !this.parent.isAttached) {\n      return 0;\n    }\n    const parts = this.widget;\n    const visiblePartCount = parts.filter(part => !part.isHidden).length;\n    let availableSize: number;\n    if (this.orientation === 'horizontal') {\n      availableSize = this.parent.node.offsetWidth;\n    } else {\n      availableSize = this.parent.node.offsetHeight;\n      availableSize -= visiblePartCount * this.options.headerSize;\n    }\n    availableSize -= (visiblePartCount - 1) * this.spacing;\n    if (availableSize < 0) {\n      return 0;\n    }\n    return availableSize;\n  }\n\n  /**\n   * Update a view container part that has been collapsed or expanded. The transition\n   * to the new state is animated.\n   */\n  updateCollapsed(part: ViewContainerPart, enableAnimation: boolean): void {\n    const index = this.items.findIndex(item => item.widget === part);\n    if (index < 0 || !this.parent || part.isHidden) {\n      return;\n    }\n\n    // Do not store the height of the \"stretched item\". Otherwise, we mess up the \"hint height\".\n    // Store the height only if there are other expanded items.\n    const currentSize = this.orientation === 'horizontal' ? part.node.offsetWidth : part.node.offsetHeight;\n    if (part.collapsed && this.items.some(item => !item.widget.collapsed && !item.widget.isHidden)) {\n      part.uncollapsedSize = currentSize;\n    }\n\n    if (!enableAnimation || this.options.animationDuration <= 0) {\n      MessageLoop.postMessage(this.parent, Widget.Msg.FitRequest);\n      return;\n    }\n    let startTime: number | undefined = undefined;\n    const duration = this.options.animationDuration;\n    const direction = part.collapsed ? 'collapse' : 'expand';\n    let fullSize: number;\n    if (direction === 'collapse') {\n      fullSize = currentSize - this.options.headerSize;\n    } else {\n      fullSize = Math.max((part.uncollapsedSize || 0) - this.options.headerSize, part.minSize);\n      if (this.items.filter(item => !item.widget.collapsed && !item.widget.isHidden).length === 1) {\n        // Expand to full available size\n        fullSize = Math.max(fullSize, this.getAvailableSize());\n      }\n    }\n\n    // The update function is called on every animation frame until the predefined duration has elapsed.\n    const updateFunc = (time: number) => {\n      if (!this.parent) {\n        part.animatedSize = undefined;\n        return;\n      }\n      if (startTime === undefined) {\n        startTime = time;\n      }\n      if (time - startTime < duration) {\n        // Render an intermediate state for the animation\n        const t = this.tween((time - startTime) / duration);\n        if (direction === 'collapse') {\n          part.animatedSize = (1 - t) * fullSize;\n        } else {\n          part.animatedSize = t * fullSize;\n        }\n        requestAnimationFrame(updateFunc);\n      } else {\n        // The animation is finished\n        if (direction === 'collapse') {\n          part.animatedSize = undefined;\n        } else {\n          part.animatedSize = fullSize;\n          // Request another frame to reset the part to variable size\n          requestAnimationFrame(() => {\n            part.animatedSize = undefined;\n            if (this.parent) {\n              MessageLoop.sendMessage(this.parent, Widget.Msg.FitRequest);\n            }\n          });\n        }\n      }\n      MessageLoop.sendMessage(this.parent, Widget.Msg.FitRequest);\n    };\n    requestAnimationFrame(updateFunc);\n  }\n\n  setHandlePosition(index: number, position: number): Promise<void> {\n    const options: SplitPositionOptions = {\n      referenceWidget: this.widget[index],\n      duration: 0\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this.splitPositionHandler.setSplitHandlePosition(this.parent as SplitPanel, index, position, options) as Promise<any>;\n  }\n\n  protected onFitRequest(msg: Message): void {\n    for (const part of this.widget) {\n      const style = part.node.style;\n      if (part.animatedSize !== undefined) {\n        // The part size has been fixed for animating the transition to collapsed / expanded state\n        const fixedSize = `${this.options.headerSize + part.animatedSize}px`;\n        style.minHeight = fixedSize;\n        style.maxHeight = fixedSize;\n      } else if (part.collapsed) {\n        // The part size is fixed to the header size\n        const fixedSize = `${this.options.headerSize}px`;\n        style.minHeight = fixedSize;\n        style.maxHeight = fixedSize;\n      } else {\n        const minSize = `${this.options.headerSize + part.minSize}px`;\n        style.minHeight = minSize;\n        style.maxHeight = '';\n      }\n    }\n    super.onFitRequest(msg);\n  }\n\n  /**\n   * Sinusoidal tween function for smooth animation.\n   */\n  protected tween(t: number): number {\n    return 0.5 * (1 - Math.cos(Math.PI * t));\n  }\n\n}\n\nexport namespace ViewContainerLayout {\n\n  export interface Options extends SplitLayout.IOptions {\n    headerSize: number;\n    animationDuration: number;\n  }\n\n  export interface Item {\n    readonly widget: ViewContainerPart;\n  }\n\n}\n"]}