{"version":3,"sources":["browser/label-provider.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAGlF,OAAO,GAAG,MAAM,eAAe,CAAC;AAChC,OAAO,EAAC,oBAAoB,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,EAAuB,MAAM,WAAW,CAAC;AACjG,OAAO,EAAC,+BAA+B,EAAC,MAAM,wBAAwB,CAAC;AACvE,OAAO,EAAC,sBAAsB,EAAE,uBAAuB,EAAC,MAAM,0BAA0B,CAAC;AAazF;;;;GAIG;AACH,eAAO,MAAM,WAAW,QAAsB,CAAC;AAC/C;;;;GAIG;AACH,eAAO,MAAM,SAAS,QAAoB,CAAC;AAE3C,eAAO,MAAM,yBAAyB,eAAsC,CAAC;AAE7E;;;;;;;;GAQG;AACH,MAAM,WAAW,yBAAyB;IAExC;;;OAGG;IACH,QAAQ,CAAC,WAAW,CAAC,EAAE,KAAK,CAAC,mBAAmB,CAAC,CAAC;IAElD;;;;OAIG;IACH,SAAS,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,CAAC;IAEnC;;OAEG;IACH,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;IAE9C;;OAEG;IACH,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;IAE9C;;OAEG;IACH,WAAW,CAAC,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC;IAElD;;;;OAIG;IACH,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,mBAAmB,GAAG,OAAO,CAAC;CAEhE;AAED,MAAM,WAAW,mBAAmB;IAClC,OAAO,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC;CACnC;AAED,MAAM,WAAW,gBAAgB;IAC/B,IAAI,EAAE,kBAAkB,CAAC;IACzB,EAAE,EAAE,MAAM,GAAG,QAAQ,CAAC;IACtB,GAAG,CAAC,EAAE,GAAG,CAAA;CACV;AAED,yBAAiB,gBAAgB,CAAC;IAEhC,SAAgB,EAAE,CAAC,OAAO,EAAE,GAAG,GAAG,SAAS,GAAG,OAAO,IAAI,gBAAgB,CAExE;IAED,SAAgB,MAAM,CAAC,EAAE,EAAE,gBAAgB,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,gBAAgB,CAE9E;CACF;AAED,qBACa,mCAAoC,YAAW,yBAAyB;IAEnF,SAAS,CAAC,UAAU,EAAE,sBAAsB,EAAE,CAAM;IACpD,SAAS,CAAC,QAAQ,CAAC,kBAAkB,+BAAsC;IAC3E,SAAS,CAAC,QAAQ,EAAE,MAAM,GAAG,SAAS,CAAC;IAKvC,OAAO,CAAC,QAAQ,CAAC,mBAAmB,CAAwC;IAE5E,IAAI,iBAAiB,IAAI,MAAM,CAE9B;IAED,IAAI,eAAe,IAAI,MAAM,CAE5B;IAED,IAAI,WAAW,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAE5C;IAGD,IAAI,IAAI,IAAI;IAOZ,SAAS,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM;IAOlC,OAAO,CAAC,OAAO,EAAE,GAAG,GAAG,gBAAgB,GAAG,MAAM;IAYhD,OAAO,CAAC,OAAO,EAAE,GAAG,GAAG,gBAAgB,GAAG,MAAM,GAAG,SAAS;IAK5D,WAAW,CAAC,OAAO,EAAE,GAAG,GAAG,gBAAgB,GAAG,MAAM,GAAG,SAAS;IAWhE,iBAAiB,CAAC,SAAS,EAAE,sBAAsB,GAAG,UAAU;IAShE,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,GAAG,MAAM,GAAG,SAAS;IAQnD,SAAS,CAAC,MAAM,CAAC,OAAO,EAAE,GAAG,GAAG,gBAAgB,GAAG,GAAG,GAAG,SAAS;IAMlE,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,UAAU,EAAE,uBAAuB,GAAG,MAAM;IA+B/E,SAAS,CAAC,cAAc,CAAC,QAAQ,EAAE,GAAG,GAAG,uBAAuB,GAAG,SAAS;IAwB5E,OAAO,CAAC,eAAe;IAMvB,OAAO,CAAC,cAAc;CAGvB;AAED;;;;;;;;;GASG;AACH,qBACa,aAAc,YAAW,+BAA+B;IAEnE,SAAS,CAAC,QAAQ,CAAC,kBAAkB,+BAAsC;IAG3E,SAAS,CAAC,QAAQ,CAAC,oBAAoB,EAAE,oBAAoB,CAAC,yBAAyB,CAAC,CAAC;IAEzF,IAAI,WAAW,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAE5C;IAED;;OAEG;IACH,IAAI,QAAQ,IAAI,MAAM,CAErB;IAED;;OAEG;IACH,IAAI,UAAU,IAAI,MAAM,CAEvB;IAED;;;;;OAKG;IACH,UAAU,IAAI,IAAI;IAclB;;;OAGG;IACH,OAAO,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM;IAYhC;;;OAGG;IACH,OAAO,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM;IAYhC;;;OAGG;IACH,WAAW,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM;IAYpC,SAAS,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,mBAAmB,GAAG,OAAO;IAYvE,SAAS,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,GAAG,yBAAyB,EAAE;CAMzE","file":"../../src/browser/label-provider.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named, postConstruct} from 'inversify';\nimport URI from '../common/uri';\nimport {ContributionProvider, Disposable, Emitter, Event, Path, Prioritizeable} from '../common';\nimport {FrontendApplicationContribution} from './frontend-application';\nimport {ResourceLabelFormatter, ResourceLabelFormatting} from '../common/label-protocol';\nimport {codicon} from './widgets';\nimport * as fileIcons from 'file-icons-js';\n\n/**\n * @internal don't export it, use `LabelProvider.folderIcon` instead.\n */\nconst DEFAULT_FOLDER_ICON = `${codicon('folder')} default-folder-icon`;\n/**\n * @internal don't export it, use `LabelProvider.fileIcon` instead.\n */\nconst DEFAULT_FILE_ICON = `${codicon('file')} default-file-icon`;\n\n/**\n * Internal folder icon class for the default (File Icons) theme.\n *\n * @deprecated Use `LabelProvider.folderIcon` to get a folder icon class for the current icon theme.\n */\nexport const FOLDER_ICON = DEFAULT_FOLDER_ICON;\n/**\n * Internal file icon class for the default (File Icons) theme.\n *\n * @deprecated Use `LabelProvider.fileIcon` to get a file icon class for the current icon theme.\n */\nexport const FILE_ICON = DEFAULT_FILE_ICON;\n\nexport const LabelProviderContribution = Symbol('LabelProviderContribution');\n\n/**\n * A {@link LabelProviderContribution} determines how specific elements/nodes are displayed in the workbench.\n * Tart views use a common {@link LabelProvider} to determine the label and/or an icon for elements shown in the UI. This includes elements in lists\n * and trees, but also view specific locations like headers. The common {@link LabelProvider} collects all {@links LabelProviderContribution} and delegates\n * to the contribution with the highest priority. This is determined via calling the {@link LabelProviderContribution.canHandle} function, so contributions\n * define which elements they are responsible for.\n * As arbitrary views can consume LabelProviderContributions, they must be generic for the covered element type, not view specific. Label providers and\n * contributions can be used for arbitrary element and node types, e.g. for markers or domain-specific elements.\n */\nexport interface LabelProviderContribution {\n\n  /**\n   * Emit when something has changed that may result in this label provider returning a different\n   * value for one or more properties (name, icon etc).\n   */\n  readonly onDidChange?: Event<DidChangeLabelEvent>;\n\n  /**\n   * Determines whether this contribution can handle the given element and with what priority.\n   * All contributions are ordered by the returned number if greater than zero. The highest number wins.\n   * If two or more contributions return the same positive number one of those will be used. It is undefined which one.\n   */\n  canHandle(element: object): number;\n\n  /**\n   * returns an icon class for the given element.\n   */\n  getIcon?(element: object): string | undefined;\n\n  /**\n   * returns a short name for the given element.\n   */\n  getName?(element: object): string | undefined;\n\n  /**\n   * returns a long name for the given element.\n   */\n  getLongName?(element: object): string | undefined;\n\n  /**\n   * Checks whether the given element is affected by the given change event.\n   * Contributions delegating to the label provider can use this hook\n   * to perform a recursive check.\n   */\n  affects?(element: object, event: DidChangeLabelEvent): boolean;\n\n}\n\nexport interface DidChangeLabelEvent {\n  affects(element: object): boolean;\n}\n\nexport interface URIIconReference {\n  kind: 'uriIconReference';\n  id: 'file' | 'folder';\n  uri?: URI\n}\n\nexport namespace URIIconReference {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is(element: any | undefined): element is URIIconReference {\n    return !!element && typeof element === 'object' && 'kind' in element && element['kind'] === 'uriIconReference';\n  }\n\n  export function create(id: URIIconReference['id'], uri?: URI): URIIconReference {\n    return {kind: 'uriIconReference', id, uri};\n  }\n}\n\n@injectable()\nexport class DefaultUriLabelProviderContribution implements LabelProviderContribution {\n\n  protected formatters: ResourceLabelFormatter[] = [];\n  protected readonly onDidChangeEmitter = new Emitter<DidChangeLabelEvent>();\n  protected homePath: string | undefined;\n  /*---------------------------------------------------------------------------------------------\n  *  Copyright (c) Microsoft Corporation. All rights reserved.\n  *  Licensed under the MIT License. See License.txt in the project root for license information.\n  *--------------------------------------------------------------------------------------------*/\n  private readonly labelMatchingRegexp = /\\${(scheme|authority|path|query)}/g;\n\n  get defaultFolderIcon(): string {\n    return DEFAULT_FOLDER_ICON;\n  }\n\n  get defaultFileIcon(): string {\n    return DEFAULT_FILE_ICON;\n  }\n\n  get onDidChange(): Event<DidChangeLabelEvent> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  @postConstruct()\n  init(): void {\n    // this.envVariablesServer.getHomeDirUri().then(result => {\n    //     this.homePath = result;\n    //     this.fireOnDidChange();\n    // });\n  }\n\n  canHandle(element: object): number {\n    if (element instanceof URI || URIIconReference.is(element)) {\n      return 1;\n    }\n    return 0;\n  }\n\n  getIcon(element: URI | URIIconReference): string {\n    if (URIIconReference.is(element) && element.id === 'folder') {\n      return this.defaultFolderIcon;\n    }\n    const uri = URIIconReference.is(element) ? element.uri : element;\n    if (uri) {\n      const iconClass = uri && this.getFileIcon(uri);\n      return iconClass || this.defaultFileIcon;\n    }\n    return '';\n  }\n\n  getName(element: URI | URIIconReference): string | undefined {\n    const uri = this.getUri(element);\n    return uri && uri.displayName;\n  }\n\n  getLongName(element: URI | URIIconReference): string | undefined {\n    const uri = this.getUri(element);\n    if (uri) {\n      const formatting = this.findFormatting(uri);\n      if (formatting) {\n        return this.formatUri(uri, formatting);\n      }\n    }\n    return uri && uri.path.toString();\n  }\n\n  registerFormatter(formatter: ResourceLabelFormatter): Disposable {\n    this.formatters.push(formatter);\n    this.fireOnDidChange();\n    return Disposable.create(() => {\n      this.formatters = this.formatters.filter(f => f !== formatter);\n      this.fireOnDidChange();\n    });\n  }\n\n  protected getFileIcon(uri: URI): string | undefined {\n    const fileIcon = fileIcons.getClassWithColor(uri.displayName);\n    if (!fileIcon) {\n      return undefined;\n    }\n    return fileIcon + ' tart-file-icons-js';\n  }\n\n  protected getUri(element: URI | URIIconReference): URI | undefined {\n    return URIIconReference.is(element) ? element.uri : element;\n  }\n\n  // copied and modified from https://github.com/microsoft/vscode/blob/1.44.2/src/vs/workbench/services/label/common/labelService.ts\n\n  protected formatUri(resource: URI, formatting: ResourceLabelFormatting): string {\n    let label = formatting.label.replace(this.labelMatchingRegexp, (match, token) => {\n      switch (token) {\n        case 'scheme':\n          return resource.scheme;\n        case 'authority':\n          return resource.authority;\n        case 'path':\n          return resource.path.toString();\n        case 'query':\n          return resource.query;\n        default:\n          return '';\n      }\n    });\n\n    // convert \\c:\\something => C:\\something\n    if (formatting.normalizeDriveLetter && this.hasDriveLetter(label)) {\n      label = label.charAt(1).toUpperCase() + label.substr(2);\n    }\n\n    if (formatting.tildify) {\n      label = Path.tildify(label, this.homePath ? this.homePath : '');\n    }\n    if (formatting.authorityPrefix && resource.authority) {\n      label = formatting.authorityPrefix + label;\n    }\n\n    return label.replace(/\\//g, formatting.separator);\n  }\n\n  protected findFormatting(resource: URI): ResourceLabelFormatting | undefined {\n    let bestResult: ResourceLabelFormatter | undefined;\n\n    this.formatters.forEach(formatter => {\n      if (formatter.scheme === resource.scheme) {\n        if (!bestResult && !formatter.authority) {\n          bestResult = formatter;\n          return;\n        }\n        if (!formatter.authority) {\n          return;\n        }\n\n        if ((formatter.authority.toLowerCase() === resource.authority.toLowerCase()) &&\n            (!bestResult || !bestResult.authority || formatter.authority.length > bestResult.authority.length ||\n                ((formatter.authority.length === bestResult.authority.length) && formatter.priority))) {\n          bestResult = formatter;\n        }\n      }\n    });\n\n    return bestResult ? bestResult.formatting : undefined;\n  }\n\n  private fireOnDidChange(): void {\n    this.onDidChangeEmitter.fire({\n      affects: (element: URI) => this.canHandle(element) > 0\n    });\n  }\n\n  private hasDriveLetter(path: string): boolean {\n    return !!(path && path[2] === ':');\n  }\n}\n\n/**\n * The {@link LabelProvider} determines how elements/nodes are displayed in the workbench. For any element, it can determine a short label, a long label\n * and an icon. The {@link LabelProvider} is to be used in lists, trees and tables, but also view specific locations like headers.\n * The common {@link LabelProvider} can be extended/adapted via {@link LabelProviderContribution}s. For every element, the {@links LabelProvider} will determine the\n * {@link LabelProviderContribution} with the hightest priority and delegate to it. Tart registers default {@link LabelProviderContribution} for common types, e.g.\n * the {@link DefaultUriLabelProviderContribution} for elements that have a URI.\n * Using the {@link LabelProvider} across the workbench ensures a common look and feel for elements across multiple views. To adapt the way how specific\n * elements/nodes are rendered, use a {@link LabelProviderContribution} rather than adapting or sub classing the {@link LabelProvider}. This way, your adaptation\n * is applied to all views in Tart that use the {@link LabelProvider}\n */\n@injectable()\nexport class LabelProvider implements FrontendApplicationContribution {\n\n  protected readonly onDidChangeEmitter = new Emitter<DidChangeLabelEvent>();\n\n  @inject(ContributionProvider) @named(LabelProviderContribution)\n  protected readonly contributionProvider: ContributionProvider<LabelProviderContribution>;\n\n  get onDidChange(): Event<DidChangeLabelEvent> {\n    return this.onDidChangeEmitter.event;\n  }\n\n  /**\n   * Return a default file icon for the current icon theme.\n   */\n  get fileIcon(): string {\n    return this.getIcon(URIIconReference.create('file'));\n  }\n\n  /**\n   * Return a default folder icon for the current icon theme.\n   */\n  get folderIcon(): string {\n    return this.getIcon(URIIconReference.create('folder'));\n  }\n\n  /**\n   * Start listening to contributions.\n   *\n   * Don't call this method directly!\n   * It's called by the frontend application during initialization.\n   */\n  initialize(): void {\n    const contributions = this.contributionProvider.getContributions();\n    for (const eventContribution of contributions) {\n      if (eventContribution.onDidChange) {\n        eventContribution.onDidChange(event => {\n          this.onDidChangeEmitter.fire({\n            // TODO check eventContribution.canHandle as well\n            affects: element => this.affects(element, event)\n          });\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the icon class from the list of available {@link LabelProviderContribution} for the given element.\n   * @return the icon class\n   */\n  getIcon(element: object): string {\n    const contributions = this.findContribution(element);\n    for (const contribution of contributions) {\n      const value = contribution.getIcon && contribution.getIcon(element);\n      if (value === undefined) {\n        continue;\n      }\n      return value;\n    }\n    return '';\n  }\n\n  /**\n   * Get a short name from the list of available {@link LabelProviderContribution} for the given element.\n   * @return the short name\n   */\n  getName(element: object): string {\n    const contributions = this.findContribution(element);\n    for (const contribution of contributions) {\n      const value = contribution.getName && contribution.getName(element);\n      if (value === undefined) {\n        continue;\n      }\n      return value;\n    }\n    return '<unknown>';\n  }\n\n  /**\n   * Get a long name from the list of available {@link LabelProviderContribution} for the given element.\n   * @return the long name\n   */\n  getLongName(element: object): string {\n    const contributions = this.findContribution(element);\n    for (const contribution of contributions) {\n      const value = contribution.getLongName && contribution.getLongName(element);\n      if (value === undefined) {\n        continue;\n      }\n      return value;\n    }\n    return '';\n  }\n\n  protected affects(element: object, event: DidChangeLabelEvent): boolean {\n    if (event.affects(element)) {\n      return true;\n    }\n    for (const contribution of this.findContribution(element)) {\n      if (contribution.affects && contribution.affects(element, event)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected findContribution(element: object): LabelProviderContribution[] {\n    const prioritized = Prioritizeable.prioritizeAllSync(this.contributionProvider.getContributions(), contrib =>\n        contrib.canHandle(element)\n    );\n    return prioritized.map(c => c.value);\n  }\n}\n"]}