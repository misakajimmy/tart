{"version":3,"sources":["browser/frontend-application.ts"],"names":[],"mappings":"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","file":"../../src/browser/frontend-application.d.ts","sourcesContent":["import {inject, injectable, named} from 'inversify';\nimport {ApplicationShell} from './shell';\nimport {Widget} from '@lumino/widgets';\nimport {CommandRegistry, ContributionProvider, MaybePromise, MenuModelRegistry,} from '../common';\nimport {KeybindingRegistry} from './keybinding';\nimport {ApplicationShellLayoutMigrationError, ShellLayoutRestorer} from './shell/shell-layout-restorer';\nimport {FrontendApplicationStateService} from './frontend-application-state';\nimport {WindowService} from './window/window-service';\n\n/**\n * Clients can implement to get a callback for contributing widgets to a shell on start.\n */\nexport const FrontendApplicationContribution = Symbol('FrontendApplicationContribution');\n\nexport interface FrontendApplicationContribution {\n\n  /**\n   * Called on application startup before configure is called.\n   */\n  initialize?(): void;\n\n  /**\n   * Called before commands, key bindings and menus are initialized.\n   * Should return a promise if it runs asynchronously.\n   */\n  configure?(app: FrontendApplication): MaybePromise<void>;\n\n  /**\n   * Called when the application is started. The application shell is not attached yet when this method runs.\n   * Should return a promise if it runs asynchronously.\n   */\n  onStart?(app: FrontendApplication): MaybePromise<void>;\n\n  /**\n   * Called on `beforeunload` event, right before the window closes.\n   * Return `true` in order to prevent exit.\n   * Note: No async code allowed, this function has to run on one tick.\n   */\n  onWillStop?(app: FrontendApplication): boolean | void;\n\n  /**\n   * Called when an application is stopped or unloaded.\n   *\n   * Note that this is implemented using `window.beforeunload` which doesn't allow any asynchronous code anymore.\n   * I.e. this is the last tick.\n   */\n  onStop?(app: FrontendApplication): void;\n\n  /**\n   * Called after the application shell has been attached in case there is no previous workbench layout state.\n   * Should return a promise if it runs asynchronously.\n   */\n  initializeLayout?(app: FrontendApplication): MaybePromise<void>;\n\n  /**\n   * An event is emitted when a layout is initialized, but before the shell is attached.\n   */\n  onDidInitializeLayout?(app: FrontendApplication): MaybePromise<void>;\n}\n\nconst TIMER_WARNING_THRESHOLD = 100;\n\nexport interface IFrontendApplicationStartProps {\n  host: HTMLElement;\n}\n\n@injectable()\nexport class FrontendApplication {\n\n  @inject(WindowService)\n  protected readonly windowsService: WindowService;\n  protected inComposition = false;\n\n  constructor(\n      @inject(CommandRegistry) protected readonly commands: CommandRegistry,\n      @inject(MenuModelRegistry) protected readonly menus: MenuModelRegistry,\n      @inject(KeybindingRegistry) protected readonly keybindings: KeybindingRegistry,\n      @inject(ShellLayoutRestorer) protected readonly layoutRestorer: ShellLayoutRestorer,\n      @inject(ContributionProvider) @named(FrontendApplicationContribution)\n      protected readonly contributions: ContributionProvider<FrontendApplicationContribution>,\n      @inject(ApplicationShell) protected readonly _shell: ApplicationShell,\n      @inject(FrontendApplicationStateService) protected readonly stateService: FrontendApplicationStateService,\n  ) {\n  }\n\n  get shell(): ApplicationShell {\n    return this._shell;\n  }\n\n  /**\n   * Start the frontend application.\n   *\n   * Start up consists of the following steps:\n   * - start frontend contributions\n   * - attach the application shell to the host element\n   * - initialize the application shell layout\n   * - reveal the application shell if it was hidden by a startup indicator\n   */\n  async start(props: IFrontendApplicationStartProps): Promise<void> {\n    await this.startContributions();\n    this.stateService.state = 'started_contributions';\n\n    const {host} = props;\n    this.attachShell(host);\n    this.stateService.state = 'attached_shell';\n\n    await this.initializeLayout();\n    this.stateService.state = 'initialized_layout';\n    await this.fireOnDidInitializeLayout();\n\n    this.registerEventListeners();\n    this.stateService.state = 'ready';\n  }\n\n  /**\n   * Attach the application shell to the host element. If a startup indicator is present, the shell is\n   * inserted before that indicator so it is not visible yet.\n   */\n  protected attachShell(host: HTMLElement): void {\n    Widget.attach(this.shell, host);\n  }\n\n  /**\n   * Initialize the shell layout either using the layout restorer service or, if no layout has\n   * been stored, by creating the default layout.\n   */\n  protected async initializeLayout(): Promise<void> {\n    if (!await this.restoreLayout()) {\n      // Fallback: Create the default shell layout\n      await this.createDefaultLayout();\n    }\n    await this.shell.pendingUpdates;\n  }\n\n  /**\n   * Let the frontend application contributions initialize the shell layout. Override this\n   * method in order to create an application-specific custom layout.\n   */\n  protected async createDefaultLayout(): Promise<void> {\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.initializeLayout) {\n        await this.measure(contribution.constructor.name + '.initializeLayout',\n            () => contribution.initializeLayout!(this)\n        );\n      }\n    }\n  }\n\n  /**\n   * Try to restore the shell layout from the storage service. Resolves to `true` if successful.\n   */\n  protected async restoreLayout(): Promise<boolean> {\n    try {\n      return await this.layoutRestorer.restoreLayout(this);\n    } catch (error) {\n      if (ApplicationShellLayoutMigrationError.is(error)) {\n        console.warn(error.message);\n        console.info('Initializing the default layout instead...');\n      } else {\n        console.error('Could not restore layout', error);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Initialize and start the frontend application contributions.\n   */\n  protected async startContributions(): Promise<void> {\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.initialize) {\n        try {\n          await this.measure(contribution.constructor.name + '.initialize',\n              () => contribution.initialize!()\n          );\n        } catch (error) {\n          console.error('Could not initialize contribution', error);\n        }\n      }\n    }\n\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.configure) {\n        try {\n          await this.measure(contribution.constructor.name + '.configure',\n              () => contribution.configure!(this)\n          );\n        } catch (error) {\n          console.error('Could not configure contribution', error);\n        }\n      }\n    }\n\n    /**\n     * FIXME:\n     * - decouple commands & menus\n     * - consider treat commands, keybindings and menus as frontend application contributions\n     */\n    await this.measure('commands.onStart',\n        () => this.commands.onStart()\n    );\n    await this.measure('keybindings.onStart',\n        () => this.keybindings.onStart()\n    );\n    await this.measure('menus.onStart',\n        () => this.menus.onStart()\n    );\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.onStart) {\n        try {\n          await this.measure(contribution.constructor.name + '.onStart',\n              () => contribution.onStart!(this)\n          );\n        } catch (error) {\n          console.error('Could not start contribution', error);\n        }\n      }\n    }\n  }\n\n  protected async measure<T>(name: string, fn: () => MaybePromise<T>): Promise<T> {\n    const startMark = name + '-start';\n    const endMark = name + '-end';\n    performance.mark(startMark);\n    const result = await fn();\n    performance.mark(endMark);\n    performance.measure(name, startMark, endMark);\n    for (const item of performance.getEntriesByName(name)) {\n      const contribution = `Frontend ${item.name}`;\n      if (item.duration > TIMER_WARNING_THRESHOLD) {\n        console.warn(`${contribution} is slow, took: ${item.duration.toFixed(1)} ms`);\n      } else {\n        console.debug(`${contribution} took: ${item.duration.toFixed(1)} ms`);\n      }\n    }\n    performance.clearMeasures(name);\n    return result;\n  }\n\n  protected async fireOnDidInitializeLayout(): Promise<void> {\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.onDidInitializeLayout) {\n        await this.measure(contribution.constructor.name + '.onDidInitializeLayout',\n            () => contribution.onDidInitializeLayout!(this)\n        );\n      }\n    }\n  }\n\n  /**\n   * Stop the frontend application contributions. This is called when the window is unloaded.\n   */\n  protected stopContributions(): void {\n    console.info('>>> Stopping frontend contributions...');\n    for (const contribution of this.contributions.getContributions()) {\n      if (contribution.onStop) {\n        try {\n          contribution.onStop(this);\n        } catch (error) {\n          console.error('Could not stop contribution', error);\n        }\n      }\n    }\n    console.info('<<< All frontend contributions have been stopped.');\n  }\n\n  /**\n   * Register global event listeners.\n   */\n  protected registerEventListeners(): void {\n    // console.log(this.windowsService);\n    this.windowsService.onUnload(() => {\n      this.stateService.state = 'closing_window';\n      this.layoutRestorer.storeLayout(this);\n      this.stopContributions();\n    });\n    window.addEventListener('resize', () => this.shell.update());\n    document.addEventListener('keydown', event => {\n      if (this.inComposition !== true) {\n        this.keybindings.run(event);\n      }\n    }, true);\n  }\n}\n\nexport default FrontendApplication;\n"]}