{"version":3,"sources":["browser/path.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAElF;;;;;;;;;;;;;;;;GAgBG;AACH,qBAAa,IAAI;IACf,MAAM,CAAC,SAAS,EAAE,GAAG,CAAO;IAC5B,QAAQ,CAAC,UAAU,EAAE,OAAO,CAAC;IAC7B,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC;IACzB,QAAQ,CAAC,IAAI,EAAE,IAAI,GAAG,SAAS,CAAC;IAChC,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,GAAG,EAAE,MAAM,CAAC;IACrB,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAS;IAE7B;;OAEG;gBAEC,GAAG,EAAE,MAAM;IAgBf,OAAO,CAAC,IAAI,CAAO;IAEnB;;OAEG;IACH,IAAI,GAAG,IAAI,IAAI,CAKd;IAED;;;;;OAKG;IACH,IAAI,MAAM,IAAI,OAAO,CAEpB;IAED,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO;IAIxC;;;;OAIG;IACH,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM;IAmB3C;;;;OAIG;IACH,MAAM,CAAC,sBAAsB,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM;IAInD;;;;;;OAMG;IACH,MAAM,CAAC,OAAO,CAAC,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAG,MAAM;IAW1D;;;;;;OAMG;IACH,MAAM,CAAC,SAAS,CAAC,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAG,MAAM;IAY5D,IAAI,CAAC,GAAG,KAAK,EAAE,MAAM,EAAE,GAAG,IAAI;IAW9B,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,IAAI,GAAG,IAAI,GAAG,SAAS;IAetC,eAAe,CAAC,IAAI,EAAE,IAAI,GAAG,OAAO;IAIpC,UAAU,CAAC,IAAI,EAAE,IAAI,GAAG,MAAM;IAe9B,SAAS,IAAI,IAAI;IA4BjB,SAAS,CAAC,WAAW,IAAI,IAAI,GAAG,SAAS;IAoBzC,SAAS,CAAC,UAAU,IAAI,IAAI;CAa7B","file":"../../src/browser/path.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/**\n * On POSIX:\n * ┌──────────────────────┬────────────┐\n * │          dir         │    base    │\n * ├──────┬               ├──────┬─────┤\n * │ root │               │ name │ ext │\n * \"  /     home/user/dir / file  .txt \"\n * └──────┴───────────────┴──────┴─────┘\n *\n * On Windows:\n * ┌──────────────────────┬────────────┐\n * │           dir        │    base    │\n * ├──────┬               ├──────┬─────┤\n * │ root │               │ name │ ext │\n * \"  /c: / home/user/dir / file  .txt \"\n * └──────┴───────────────┴──────┴─────┘\n */\nexport class Path {\n  static separator: '/' = '/';\n  readonly isAbsolute: boolean;\n  readonly isRoot: boolean;\n  readonly root: Path | undefined;\n  readonly base: string;\n  readonly name: string;\n  readonly ext: string;\n  private readonly raw: string;\n\n  /**\n   * The raw should be normalized, meaning that only '/' is allowed as a path separator.\n   */\n  constructor(\n      raw: string\n  ) {\n    raw = Path.normalizePathSeparator(raw);\n    this.raw = Path.normalizeDrive(raw);\n    const firstIndex = this.raw.indexOf(Path.separator);\n    const lastIndex = this.raw.lastIndexOf(Path.separator);\n    this.isAbsolute = firstIndex === 0;\n    this.base = lastIndex === -1 ? this.raw : this.raw.substr(lastIndex + 1);\n    this.isRoot = this.isAbsolute && firstIndex === lastIndex && (!this.base || Path.isDrive(this.base));\n    this.root = this.computeRoot();\n\n    const extIndex = this.base.lastIndexOf('.');\n    this.name = extIndex === -1 ? this.base : this.base.substr(0, extIndex);\n    this.ext = extIndex === -1 ? '' : this.base.substr(extIndex);\n  }\n\n  private _dir: Path;\n\n  /**\n   * Returns the parent directory if it exists (`hasDir === true`) or `this` otherwise.\n   */\n  get dir(): Path {\n    if (this._dir === undefined) {\n      this._dir = this.computeDir();\n    }\n    return this._dir;\n  }\n\n  /**\n   * Returns `true` if this has a parent directory, `false` otherwise.\n   *\n   * _This implementation returns `true` if and only if this is not the root dir and\n   * there is a path separator in the raw path._\n   */\n  get hasDir(): boolean {\n    return !this.isRoot && this.raw.lastIndexOf(Path.separator) !== -1;\n  }\n\n  static isDrive(segment: string): boolean {\n    return segment.endsWith(':');\n  }\n\n  /**\n   * vscode-uri always normalizes drive letters to lower case:\n   * https://github.com/Microsoft/vscode-uri/blob/b1d3221579f97f28a839b6f996d76fc45e9964d8/src/index.ts#L1025\n   * tart path should be adjusted to this.\n   */\n  static normalizeDrive(path: string): string {\n    // lower-case windows drive letters in /C:/fff or C:/fff\n    if (path.length >= 3 && path.charCodeAt(0) === 47 /* '/' */ && path.charCodeAt(2) === 58 /* ':' */) {\n      const code = path.charCodeAt(1);\n      if (code >= 65 /* A */ && code <= 90 /* Z */) {\n        path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n      }\n    } else if (path.length >= 2 && path.charCodeAt(1) === 58 /* ':' */) {\n      const code = path.charCodeAt(0);\n      if (code >= 65 /* A */ && code <= 90 /* Z */) {\n        path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"c:\".length === 2\n      }\n      if (path.charCodeAt(0) !== 47 /* '/' */) {\n        path = `${String.fromCharCode(47)}${path}`;\n      }\n    }\n    return path;\n  }\n\n  /**\n   * Normalize path separator to use Path.separator\n   * @param Path candidate to normalize\n   * @returns Normalized string path\n   */\n  static normalizePathSeparator(path: string): string {\n    return path.split(/[\\\\]/).join(Path.separator);\n  }\n\n  /**\n   * Tildify path, replacing `home` with `~` if user's `home` is present at the beginning of the path.\n   * This is a non-operation for Windows.\n   *\n   * @param resourcePath\n   * @param home\n   */\n  static tildify(resourcePath: string, home: string): string {\n    const path = new Path(resourcePath);\n    const isWindows = path.root && Path.isDrive(path.root.base);\n\n    if (!isWindows && home && resourcePath.indexOf(`${home}/`) === 0) {\n      return resourcePath.replace(`${home}/`, '~/');\n    }\n\n    return resourcePath;\n  }\n\n  /**\n   * Untildify path, replacing `~` with `home` if `~` present at the beginning of the path.\n   * This is a non-operation for Windows.\n   *\n   * @param resourcePath\n   * @param home\n   */\n  static untildify(resourcePath: string, home: string): string {\n    if (resourcePath.startsWith('~')) {\n      const untildifiedResource = resourcePath.replace(/^~/, home);\n      const untildifiedPath = new Path(untildifiedResource);\n      const isWindows = untildifiedPath.root && Path.isDrive(untildifiedPath.root.base);\n      if (!isWindows && home && untildifiedResource.startsWith(`${home}`)) {\n        return untildifiedResource;\n      }\n    }\n    return resourcePath;\n  }\n\n  join(...paths: string[]): Path {\n    const relativePath = paths.filter(s => !!s).join(Path.separator);\n    if (!relativePath) {\n      return this;\n    }\n    if (this.raw.endsWith(Path.separator)) {\n      return new Path(this.raw + relativePath);\n    }\n    return new Path(this.raw + Path.separator + relativePath);\n  }\n\n  toString(): string {\n    return this.raw;\n  }\n\n  relative(path: Path): Path | undefined {\n    if (this.raw === path.raw) {\n      return new Path('');\n    }\n    if (!this.raw || !path.raw) {\n      return undefined;\n    }\n    const raw = this.base ? this.raw + Path.separator : this.raw;\n    if (!path.raw.startsWith(raw)) {\n      return undefined;\n    }\n    const relativePath = path.raw.substr(raw.length);\n    return new Path(relativePath);\n  }\n\n  isEqualOrParent(path: Path): boolean {\n    return !!this.relative(path);\n  }\n\n  relativity(path: Path): number {\n    const relative = this.relative(path);\n    if (relative) {\n      const relativeStr = relative.toString();\n      if (relativeStr === '') {\n        return 0;\n      }\n      return relativeStr.split(Path.separator).length;\n    }\n    return -1;\n  }\n\n  /*\n   * return a normalized Path, resolving '..' and '.' segments\n   */\n  normalize(): Path {\n    const trailingSlash = this.raw.endsWith('/');\n    const pathArray = this.toString().split('/');\n    const resultArray: string[] = [];\n    pathArray.forEach((value, index) => {\n      if (!value || value === '.') {\n        return;\n      }\n      if (value === '..') {\n        if (resultArray.length && resultArray[resultArray.length - 1] !== '..') {\n          resultArray.pop();\n        } else if (!this.isAbsolute) {\n          resultArray.push('..');\n        }\n      } else {\n        resultArray.push(value);\n      }\n    });\n    if (resultArray.length === 0) {\n      if (this.isRoot) {\n        return new Path('/');\n      } else {\n        return new Path('.');\n      }\n    }\n    return new Path((this.isAbsolute ? '/' : '') + resultArray.join('/') + (trailingSlash ? '/' : ''));\n  }\n\n  protected computeRoot(): Path | undefined {\n    // '/' -> '/'\n    // '/c:' -> '/c:'\n    if (this.isRoot) {\n      return this;\n    }\n    // 'foo/bar' -> `undefined`\n    if (!this.isAbsolute) {\n      return undefined;\n    }\n    const index = this.raw.indexOf(Path.separator, Path.separator.length);\n    if (index === -1) {\n      // '/foo/bar' -> '/'\n      return new Path(Path.separator);\n    }\n    // '/c:/foo/bar' -> '/c:'\n    // '/foo/bar' -> '/'\n    return new Path(this.raw.substr(0, index)).root;\n  }\n\n  protected computeDir(): Path {\n    if (!this.hasDir) {\n      return this;\n    }\n    const lastIndex = this.raw.lastIndexOf(Path.separator);\n    if (this.isAbsolute) {\n      const firstIndex = this.raw.indexOf(Path.separator);\n      if (firstIndex === lastIndex) {\n        return new Path(this.raw.substr(0, firstIndex + 1));\n      }\n    }\n    return new Path(this.raw.substr(0, lastIndex));\n  }\n}\n"]}