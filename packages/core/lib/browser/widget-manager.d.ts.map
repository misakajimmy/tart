{"version":3,"sources":["browser/widget-manager.ts"],"names":[],"mappings":"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","file":"../../src/browser/widget-manager.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {Widget} from '@lumino/widgets';\nimport {ContributionProvider, Emitter, Event, MaybePromise, WaitUntilEvent} from '../common';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const WidgetFactory = Symbol('WidgetFactory');\n\n/**\n * A {@link WidgetFactory} is used to create new widgets. Factory-specific information (options) can be passed as serializable JSON data.\n * The common {@link WidgetManager} collects  `WidgetFactory` contributions and delegates to the corresponding factory when\n * a widget should be created or restored. To identify widgets the `WidgetManager` uses a description composed of the factory id and the options.\n * The `WidgetFactory` does support both, synchronous and asynchronous widget creation.\n *\n * ### Example usage\n *\n * ```typescript\n * export class MyWidget extends BaseWidget {\n * }\n *\n * @injectable()\n * export class MyWidgetFactory implements WidgetFactory {\n *     id = 'myWidgetFactory';\n *\n *     createWidget(): MaybePromise<Widget> {\n *         return new MyWidget();\n *    }\n * }\n * ```\n */\nexport interface WidgetFactory {\n\n  /**\n   * The factory id.\n   */\n  readonly id: string;\n\n  /**\n   * Creates a widget using the given options.\n   * @param options factory specific information as serializable JSON data.\n   *\n   * @returns the newly created widget or a promise of the widget\n   */\n  createWidget(options?: any): MaybePromise<Widget>;\n}\n\n/**\n * Representation of the `WidgetConstructionOptions`.\n * Defines a serializable description to create widgets.\n */\nexport interface WidgetConstructionOptions {\n  /**\n   * The id of the widget factory to use.\n   */\n  factoryId: string,\n\n  /**\n   * The widget factory specific information.\n   */\n  options?: any\n}\n\n/**\n * Representation of a `willCreateWidgetEvent`.\n */\nexport interface WillCreateWidgetEvent extends WaitUntilEvent {\n  /**\n   * The widget which will be created.\n   */\n  readonly widget: Widget;\n  /**\n   * The widget factory id.\n   */\n  readonly factoryId: string;\n}\n\n/**\n * Representation of a `didCreateWidgetEvent`.\n */\nexport interface DidCreateWidgetEvent {\n  /**\n   * The widget which was created.\n   */\n  readonly widget: Widget;\n  /**\n   * The widget factory id.\n   */\n  readonly factoryId: string;\n}\n\n/**\n * The {@link WidgetManager} is the common component responsible for creating and managing widgets. Additional widget factories\n * can be registered by using the {@link WidgetFactory} contribution point. To identify a widget, created by a factory, the factory id and\n * the creation options are used. This key is commonly referred to as `description` of the widget.\n */\n@injectable()\nexport class WidgetManager {\n\n  protected _cachedFactories: Map<string, WidgetFactory>;\n  protected readonly widgets = new Map<string, Widget>();\n  protected readonly widgetPromises = new Map<string, MaybePromise<Widget>>();\n  protected readonly pendingWidgetPromises = new Map<string, MaybePromise<Widget>>();\n\n  @inject(ContributionProvider) @named(WidgetFactory)\n  protected readonly factoryProvider: ContributionProvider<WidgetFactory>;\n\n  protected readonly onWillCreateWidgetEmitter = new Emitter<WillCreateWidgetEvent>();\n  /**\n   * An event can be used to participate in the widget creation.\n   * Listeners may not dispose the given widget.\n   */\n  readonly onWillCreateWidget: Event<WillCreateWidgetEvent> = this.onWillCreateWidgetEmitter.event;\n\n  protected readonly onDidCreateWidgetEmitter = new Emitter<DidCreateWidgetEvent>();\n\n  readonly onDidCreateWidget: Event<DidCreateWidgetEvent> = this.onDidCreateWidgetEmitter.event;\n\n  protected get factories(): Map<string, WidgetFactory> {\n    if (!this._cachedFactories) {\n      this._cachedFactories = new Map();\n      for (const factory of this.factoryProvider.getContributions()) {\n        if (factory.id) {\n          this._cachedFactories.set(factory.id, factory);\n        } else {\n          // this.logger.error('Invalid ID for factory: ' + factory + \". ID was: '\" + factory.id + \"'.\");\n        }\n      }\n    }\n    return this._cachedFactories;\n  }\n\n  /**\n   * Get the list of widgets created by the given widget factory.\n   * @param factoryId the widget factory id.\n   *\n   * @returns the list of widgets created by the factory with the given id.\n   */\n  getWidgets(factoryId: string): Widget[] {\n    const result: Widget[] = [];\n    for (const [key, widget] of this.widgets.entries()) {\n      if (this.fromKey(key).factoryId === factoryId) {\n        result.push(widget);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Try to get the existing widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns the widget if available, else `undefined`.\n   */\n  tryGetWidget<T extends Widget>(factoryId: string, options?: any): T | undefined {\n    const key = this.toKey({factoryId, options});\n    const existing = this.widgetPromises.get(key);\n    if (existing instanceof Widget) {\n      return existing as T;\n    }\n    return undefined;\n  }\n\n  /**\n   * Try to get the existing widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns A promise that resolves to the widget, if any exists. The promise may be pending, so be cautious when assuming that it will not reject.\n   */\n  tryGetPendingWidget<T extends Widget>(factoryId: string, options?: any): MaybePromise<T> | undefined {\n    const key = this.toKey({factoryId, options});\n    return this.doGetWidget(key);\n  }\n\n  /**\n   * Get the widget for the given description.\n   * @param factoryId The widget factory id.\n   * @param options The widget factory specific information.\n   *\n   * @returns a promise resolving to the widget if available, else `undefined`.\n   */\n  async getWidget<T extends Widget>(factoryId: string, options?: any): Promise<T | undefined> {\n    const key = this.toKey({factoryId, options});\n    const pendingWidget = this.doGetWidget<T>(key);\n    const widget = pendingWidget && await pendingWidget;\n    return widget;\n  }\n\n  /**\n   * Creates a new widget or returns the existing widget for the given description.\n   * @param factoryId the widget factory id.\n   * @param options the widget factory specific information.\n   *\n   * @returns a promise resolving to the widget.\n   */\n  async getOrCreateWidget<T extends Widget>(factoryId: string, options?: any): Promise<T> {\n    const key = this.toKey({factoryId, options});\n    const existingWidget = this.doGetWidget<T>(key);\n    if (existingWidget) {\n      return existingWidget;\n    }\n    const factory = this.factories.get(factoryId);\n    if (!factory) {\n      throw Error(\"No widget factory '\" + factoryId + \"' has been registered.\");\n    }\n    try {\n      const widgetPromise = factory.createWidget(options);\n      this.pendingWidgetPromises.set(key, widgetPromise);\n      const widget = await widgetPromise;\n      await WaitUntilEvent.fire(this.onWillCreateWidgetEmitter, {factoryId, widget});\n      this.widgetPromises.set(key, widgetPromise);\n      this.widgets.set(key, widget);\n      widget.disposed.connect(() => {\n        this.widgets.delete(key);\n        this.widgetPromises.delete(key);\n      });\n      this.onDidCreateWidgetEmitter.fire({factoryId, widget});\n      return widget as T;\n    } finally {\n      this.pendingWidgetPromises.delete(key);\n    }\n  }\n\n  /**\n   * Get the widget construction options.\n   * @param widget the widget.\n   *\n   * @returns the widget construction options if the widget was created through the manager, else `undefined`.\n   */\n  getDescription(widget: Widget): WidgetConstructionOptions | undefined {\n    for (const [key, aWidget] of this.widgets.entries()) {\n      if (aWidget === widget) {\n        return this.fromKey(key);\n      }\n    }\n    return undefined;\n  }\n\n  protected doGetWidget<T extends Widget>(key: string): MaybePromise<T> | undefined {\n    const pendingWidget = this.widgetPromises.get(key) ?? this.pendingWidgetPromises.get(key);\n    if (pendingWidget) {\n      return pendingWidget as MaybePromise<T>;\n    }\n    return undefined;\n  }\n\n  /**\n   * Convert the widget construction options to string.\n   * @param options the widget construction options.\n   *\n   * @returns the widget construction options represented as a string.\n   */\n  protected toKey(options: WidgetConstructionOptions): string {\n    return JSON.stringify(options);\n  }\n\n  /**\n   * Convert the key into the widget construction options object.\n   * @param key the key.\n   *\n   * @returns the widget construction options object.\n   */\n  protected fromKey(key: string): WidgetConstructionOptions {\n    return JSON.parse(key);\n  }\n\n}\n"]}