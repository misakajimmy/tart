{"version":3,"sources":["browser/keybinding.ts"],"names":[],"mappings":"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","file":"../../src/browser/keybinding.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {isOSX} from '../common/os';\nimport {Emitter, Event} from '../common';\nimport {Command, CommandRegistry} from '../common/command';\nimport {Disposable, DisposableCollection} from '../common/disposable';\nimport {Key, KeyCode, KeySequence} from './keyboard/keys';\nimport {KeyboardLayoutService} from './keyboard/keyboard-layout-service';\nimport {ContributionProvider} from '../common/contribution-provider';\nimport {StatusBar, StatusBarAlignment} from './status-bar/status-bar';\nimport {ContextKeyService} from './context-key-service';\nimport * as common from '../common/keybinding';\n\nexport enum KeybindingScope {\n  DEFAULT,\n  USER,\n  WORKSPACE,\n  END\n}\n\nexport namespace KeybindingScope {\n  export const length = KeybindingScope.END - KeybindingScope.DEFAULT;\n}\n\n/**\n * @deprecated import from `@tart/core/lib/common/keybinding` instead\n */\nexport type Keybinding = common.Keybinding;\nexport const Keybinding = common.Keybinding;\n\nexport interface ResolvedKeybinding extends common.Keybinding {\n  /**\n   * The KeyboardLayoutService may transform the `keybinding` depending on the\n   * user's keyboard layout. This property holds the transformed keybinding that\n   * should be used in the UI. The value is undefined if the KeyboardLayoutService\n   * has not been called yet to resolve the keybinding.\n   */\n  resolved?: KeyCode[];\n}\n\nexport interface ScopedKeybinding extends common.Keybinding {\n  /** Current keybinding scope */\n  scope: KeybindingScope;\n}\n\nexport const KeybindingContribution = Symbol('KeybindingContribution');\n\n/**\n * Allows extensions to contribute {@link common.Keybinding}s\n */\nexport interface KeybindingContribution {\n  /**\n   * Registers keybindings.\n   * @param keybindings the keybinding registry.\n   */\n  registerKeybindings(keybindings: KeybindingRegistry): void;\n}\n\nexport const KeybindingContext = Symbol('KeybindingContext');\n\nexport interface KeybindingContext {\n  /**\n   * The unique ID of the current context.\n   */\n  readonly id: string;\n\n  isEnabled(arg: common.Keybinding): boolean;\n}\n\nexport namespace KeybindingContexts {\n\n  export const NOOP_CONTEXT: KeybindingContext = {\n    id: 'noop.keybinding.context',\n    isEnabled: () => true\n  };\n\n  export const DEFAULT_CONTEXT: KeybindingContext = {\n    id: 'default.keybinding.context',\n    isEnabled: () => false\n  };\n}\n\n@injectable()\nexport class KeybindingRegistry {\n\n  static readonly PASSTHROUGH_PSEUDO_COMMAND = 'passthrough';\n  protected keySequence: KeySequence = [];\n\n  protected readonly contexts: { [id: string]: KeybindingContext } = {};\n  protected readonly keymaps: ScopedKeybinding[][] = [...Array(KeybindingScope.length)].map(() => []);\n\n  @inject(KeyboardLayoutService)\n  protected readonly keyboardLayoutService: KeyboardLayoutService;\n\n  @inject(ContributionProvider) @named(KeybindingContext)\n  protected readonly contextProvider: ContributionProvider<KeybindingContext>;\n\n  @inject(CommandRegistry)\n  protected readonly commandRegistry: CommandRegistry;\n\n  @inject(ContributionProvider) @named(KeybindingContribution)\n  protected readonly contributions: ContributionProvider<KeybindingContribution>;\n\n  @inject(StatusBar)\n  protected readonly statusBar: StatusBar;\n\n  @inject(ContextKeyService)\n  protected readonly whenContextService: ContextKeyService;\n  protected keybindingsChanged = new Emitter<void>();\n  protected readonly toResetKeymap = new Map<KeybindingScope, Disposable>();\n\n  /**\n   * Event that is fired when the resolved keybindings change due to a different keyboard layout\n   * or when a new keymap is being set\n   */\n  get onKeybindingsChanged(): Event<void> {\n    return this.keybindingsChanged.event;\n  }\n\n  async onStart(): Promise<void> {\n    await this.keyboardLayoutService.initialize();\n    this.keyboardLayoutService.onKeyboardLayoutChanged(newLayout => {\n      this.clearResolvedKeybindings();\n      this.keybindingsChanged.fire(undefined);\n    });\n    this.registerContext(KeybindingContexts.NOOP_CONTEXT);\n    this.registerContext(KeybindingContexts.DEFAULT_CONTEXT);\n    this.registerContext(...this.contextProvider.getContributions());\n    for (const contribution of this.contributions.getContributions()) {\n      contribution.registerKeybindings(this);\n    }\n  }\n\n  /**\n   * Register a default keybinding to the registry.\n   *\n   * Keybindings registered later have higher priority during evaluation.\n   *\n   * @param binding the keybinding to be registered\n   */\n  registerKeybinding(binding: common.Keybinding): Disposable {\n    return this.doRegisterKeybinding(binding);\n  }\n\n  /**\n   * Register multiple default keybindings to the registry\n   *\n   * @param bindings An array of keybinding to be registered\n   */\n  registerKeybindings(...bindings: common.Keybinding[]): Disposable {\n    return this.doRegisterKeybindings(bindings, KeybindingScope.DEFAULT);\n  }\n\n  /**\n   * Unregister all keybindings from the registry that are bound to the key of the given keybinding\n   *\n   * @param binding a keybinding specifying the key to be unregistered\n   */\n  unregisterKeybinding(binding: common.Keybinding): void;\n  /**\n   * Unregister all keybindings with the given key from the registry\n   *\n   * @param key a key to be unregistered\n   */\n  unregisterKeybinding(key: string): void;\n  /**\n   * Unregister all existing keybindings for the given command\n   * @param command the command to unregister all keybindings for\n   */\n  unregisterKeybinding(command: Command): void;\n\n  unregisterKeybinding(arg: common.Keybinding | string | Command): void {\n    const keymap = this.keymaps[KeybindingScope.DEFAULT];\n    const filter = Command.is(arg)\n        ? ({command}: common.Keybinding) => command === arg.id\n        : ({keybinding}: common.Keybinding) => Keybinding.is(arg)\n            ? keybinding === arg.keybinding\n            : keybinding === arg;\n    for (const binding of keymap.filter(filter)) {\n      const idx = keymap.indexOf(binding);\n      if (idx !== -1) {\n        keymap.splice(idx, 1);\n      }\n    }\n  }\n\n  /**\n   * Ensure that the `resolved` property of the given binding is set by calling the KeyboardLayoutService.\n   */\n  resolveKeybinding(binding: ResolvedKeybinding): KeyCode[] {\n    if (!binding.resolved) {\n      const sequence = KeySequence.parse(binding.keybinding);\n      binding.resolved = sequence.map(code => this.keyboardLayoutService.resolveKeyCode(code));\n    }\n    return binding.resolved;\n  }\n\n  /**\n   * Checks whether a colliding {@link common.Keybinding} exists in a specific scope.\n   * @param binding the keybinding to check\n   * @param scope the keybinding scope to check\n   * @returns true if there is a colliding keybinding\n   */\n  containsKeybindingInScope(binding: common.Keybinding, scope = KeybindingScope.USER): boolean {\n    const bindingKeySequence = this.resolveKeybinding(binding);\n    const collisions = this.getKeySequenceCollisions(this.getUsableBindings(this.keymaps[scope]), bindingKeySequence)\n        .filter(b => b.context === binding.context && !b.when && !binding.when);\n    if (collisions.full.length > 0) {\n      return true;\n    }\n    if (collisions.partial.length > 0) {\n      return true;\n    }\n    if (collisions.shadow.length > 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get a user visible representation of a {@link common.Keybinding}.\n   * @returns an array of strings representing all elements of the {@link KeySequence} defined by the {@link common.Keybinding}\n   * @param keybinding the keybinding\n   * @param separator the separator to be used to stringify {@link KeyCode}s that are part of the {@link KeySequence}\n   */\n  acceleratorFor(keybinding: common.Keybinding, separator: string = ' '): string[] {\n    const bindingKeySequence = this.resolveKeybinding(keybinding);\n    return this.acceleratorForSequence(bindingKeySequence, separator);\n  }\n\n  /**\n   * Get a user visible representation of a {@link KeySequence}.\n   * @returns an array of strings representing all elements of the {@link KeySequence}\n   * @param keySequence the keysequence\n   * @param separator the separator to be used to stringify {@link KeyCode}s that are part of the {@link KeySequence}\n   */\n  acceleratorForSequence(keySequence: KeySequence, separator: string = ' '): string[] {\n    return keySequence.map(keyCode => this.acceleratorForKeyCode(keyCode, separator));\n  }\n\n  /**\n   * Get a user visible representation of a key code (a key with modifiers).\n   * @returns a string representing the {@link KeyCode}\n   * @param keyCode the keycode\n   * @param separator the separator used to separate keys (key and modifiers) in the returning string\n   */\n  acceleratorForKeyCode(keyCode: KeyCode, separator: string = ' '): string {\n    const keyCodeResult = [];\n    if (keyCode.meta && isOSX) {\n      keyCodeResult.push('Cmd');\n    }\n    if (keyCode.ctrl) {\n      keyCodeResult.push('Ctrl');\n    }\n    if (keyCode.alt) {\n      keyCodeResult.push('Alt');\n    }\n    if (keyCode.shift) {\n      keyCodeResult.push('Shift');\n    }\n    if (keyCode.key) {\n      keyCodeResult.push(this.acceleratorForKey(keyCode.key));\n    }\n    return keyCodeResult.join(separator);\n  }\n\n  /**\n   * Return a user visible representation of a single key.\n   */\n  acceleratorForKey(key: Key): string {\n    if (isOSX) {\n      if (key === Key.ARROW_LEFT) {\n        return '←';\n      }\n      if (key === Key.ARROW_RIGHT) {\n        return '→';\n      }\n      if (key === Key.ARROW_UP) {\n        return '↑';\n      }\n      if (key === Key.ARROW_DOWN) {\n        return '↓';\n      }\n    }\n    const keyString = this.keyboardLayoutService.getKeyboardCharacter(key);\n    if (key.keyCode >= Key.KEY_A.keyCode && key.keyCode <= Key.KEY_Z.keyCode ||\n        key.keyCode >= Key.F1.keyCode && key.keyCode <= Key.F24.keyCode) {\n      return keyString.toUpperCase();\n    } else if (keyString.length > 1) {\n      return keyString.charAt(0).toUpperCase() + keyString.slice(1);\n    } else {\n      return keyString;\n    }\n  }\n\n  /**\n   * Get all keybindings associated to a commandId.\n   *\n   * @param commandId The ID of the command for which we are looking for keybindings.\n   * @returns an array of {@link ScopedKeybinding}\n   */\n  getKeybindingsForCommand(commandId: string): ScopedKeybinding[] {\n    const result: ScopedKeybinding[] = [];\n\n    for (let scope = KeybindingScope.END - 1; scope >= KeybindingScope.DEFAULT; scope--) {\n      this.keymaps[scope].forEach(binding => {\n        const command = this.commandRegistry.getCommand(binding.command);\n        if (command) {\n          if (command.id === commandId) {\n            result.push({...binding, scope});\n          }\n        }\n      });\n\n      if (result.length > 0) {\n        return result;\n      }\n    }\n    return result;\n  }\n\n  dispatchCommand(id: string, target?: EventTarget): void {\n    const keybindings = this.getKeybindingsForCommand(id);\n    if (keybindings.length) {\n      for (const keyCode of this.resolveKeybinding(keybindings[0])) {\n        this.dispatchKeyDown(keyCode, target);\n      }\n    }\n  }\n\n  dispatchKeyDown(input: KeyboardEventInit | KeyCode | string, target: EventTarget = document.activeElement || window): void {\n    const eventInit = this.asKeyboardEventInit(input);\n    const emulatedKeyboardEvent = new KeyboardEvent('keydown', eventInit);\n    target.dispatchEvent(emulatedKeyboardEvent);\n  }\n\n  /**\n   * Run the command matching to the given keyboard event.\n   */\n  run(event: KeyboardEvent): void {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    const eventDispatch = 'code';\n    const keyCode = KeyCode.createKeyCode(event, eventDispatch);\n    /* Keycode is only a modifier, next keycode will be modifier + key.\n       Ignore this one.  */\n    // if (keyCode.isModifierOnly()) {\n    //     return;\n    // }\n    //\n    this.keyboardLayoutService.validateKeyCode(keyCode);\n    this.keySequence.push(keyCode);\n    const match = this.matchKeybinding(this.keySequence, event);\n\n    if (match && match.kind === 'partial') {\n      /* Accumulate the keysequence */\n      event.preventDefault();\n      event.stopPropagation();\n\n      this.statusBar.setElement('keybinding-status', {\n        text: `(${this.acceleratorForSequence(this.keySequence, '+')}) was pressed, waiting for more keys`,\n        alignment: StatusBarAlignment.LEFT,\n        priority: 2\n      });\n    } else {\n      if (match && match.kind === 'full') {\n        this.executeKeyBinding(match.binding, event);\n      }\n      this.keySequence = [];\n      this.statusBar.removeElement('keybinding-status');\n    }\n  }\n\n  /**\n   * Match first binding in the current context.\n   * Keybindings ordered by a scope and by a registration order within the scope.\n   *\n   * FIXME:\n   * This method should run very fast since it happens on each keystroke. We should reconsider how keybindings are stored.\n   * It should be possible to look up full and partial keybinding for given key sequence for constant time using some kind of tree.\n   * Such tree should not contain disabled keybindings and be invalidated whenever the registry is changed.\n   */\n  matchKeybinding(keySequence: KeySequence, event?: KeyboardEvent): KeybindingRegistry.Match {\n    let disabled: Set<string> | undefined;\n    const isEnabled = (binding: ScopedKeybinding) => {\n      if (event && !this.isEnabled(binding, event)) {\n        return false;\n      }\n      const {command, context, when, keybinding} = binding;\n      if (!this.isUsable(binding)) {\n        disabled = disabled || new Set<string>();\n        disabled.add(JSON.stringify({command: command.substr(1), context, when, keybinding}));\n        return false;\n      }\n      return !disabled?.has(JSON.stringify({command, context, when, keybinding}));\n    };\n\n    for (let scope = KeybindingScope.END; --scope >= KeybindingScope.DEFAULT;) {\n      for (const binding of this.keymaps[scope]) {\n        const resolved = this.resolveKeybinding(binding);\n        const compareResult = KeySequence.compare(keySequence, resolved);\n        if (compareResult === KeySequence.CompareResult.FULL && isEnabled(binding)) {\n          return {kind: 'full', binding};\n        }\n        if (compareResult === KeySequence.CompareResult.PARTIAL && isEnabled(binding)) {\n          return {kind: 'partial', binding};\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Return true of string a pseudo-command id, in other words a command id\n   * that has a special meaning and that we won't find in the command\n   * registry.\n   *\n   * @param commandId commandId to test\n   */\n  isPseudoCommand(commandId: string): boolean {\n    return commandId === KeybindingRegistry.PASSTHROUGH_PSEUDO_COMMAND;\n  }\n\n  /**\n   * Sets a new keymap replacing all existing {@link common.Keybinding}s in the given scope.\n   * @param scope the keybinding scope\n   * @param bindings an array containing the new {@link common.Keybinding}s\n   */\n  setKeymap(scope: KeybindingScope, bindings: common.Keybinding[]): void {\n    this.resetKeybindingsForScope(scope);\n    this.toResetKeymap.set(scope, this.doRegisterKeybindings(bindings, scope));\n    this.keybindingsChanged.fire(undefined);\n  }\n\n  /**\n   * Reset keybindings for a specific scope\n   * @param scope scope to reset the keybindings for\n   */\n  resetKeybindingsForScope(scope: KeybindingScope): void {\n    const toReset = this.toResetKeymap.get(scope);\n    if (toReset) {\n      toReset.dispose();\n    }\n  }\n\n  /**\n   * Reset keybindings for all scopes(only leaves the default keybindings mapped)\n   */\n  resetKeybindings(): void {\n    for (let i = KeybindingScope.DEFAULT + 1; i < KeybindingScope.END; i++) {\n      this.keymaps[i] = [];\n    }\n  }\n\n  /**\n   * Get all {@link common.Keybinding}s for a {@link KeybindingScope}.\n   * @returns an array of {@link common.ScopedKeybinding}\n   * @param scope the keybinding scope to retrieve the {@link common.Keybinding}s for.\n   */\n  getKeybindingsByScope(scope: KeybindingScope): ScopedKeybinding[] {\n    return this.keymaps[scope];\n  }\n\n  /**\n   * Registers the keybinding context arguments into the application. Fails when an already registered\n   * context is being registered.\n   *\n   * @param contexts the keybinding contexts to register into the application.\n   */\n  protected registerContext(...contexts: KeybindingContext[]): void {\n    for (const context of contexts) {\n      const {id} = context;\n      if (this.contexts[id]) {\n        // this.logger.error(`A keybinding context with ID ${id} is already registered.`);\n      } else {\n        this.contexts[id] = context;\n      }\n    }\n  }\n\n  protected doRegisterKeybindings(bindings: common.Keybinding[], scope: KeybindingScope = KeybindingScope.DEFAULT): Disposable {\n    const toDispose = new DisposableCollection();\n    for (const binding of bindings) {\n      toDispose.push(this.doRegisterKeybinding(binding, scope));\n    }\n    return toDispose;\n  }\n\n  protected doRegisterKeybinding(binding: common.Keybinding, scope: KeybindingScope = KeybindingScope.DEFAULT): Disposable {\n    try {\n      this.resolveKeybinding(binding);\n      const scoped = Object.assign(binding, {scope});\n      this.insertBindingIntoScope(scoped, scope);\n      return Disposable.create(() => {\n        const index = this.keymaps[scope].indexOf(scoped);\n        if (index !== -1) {\n          this.keymaps[scope].splice(index, 1);\n        }\n      });\n    } catch (error) {\n      console.log('Could not register keybinding');\n      // this.logger.warn(`Could not register keybinding:\\n  ${common.Keybinding.stringify(binding)}\\n${error}`);\n      return Disposable.NULL;\n    }\n  }\n\n  /**\n   * Ensures that keybindings are inserted in order of increasing length of binding to ensure that if a\n   * user triggers a short keybinding (e.g. ctrl+k), the UI won't wait for a longer one (e.g. ctrl+k enter)\n   */\n  protected insertBindingIntoScope(item: common.Keybinding & { scope: KeybindingScope; }, scope: KeybindingScope): void {\n    const scopedKeymap = this.keymaps[scope];\n    const getNumberOfKeystrokes = (binding: common.Keybinding): number => (binding.keybinding.trim().match(/\\s/g)?.length ?? 0) + 1;\n    const numberOfKeystrokesInBinding = getNumberOfKeystrokes(item);\n    const indexOfFirstItemWithEqualStrokes = scopedKeymap.findIndex(existingBinding => getNumberOfKeystrokes(existingBinding) === numberOfKeystrokesInBinding);\n    if (indexOfFirstItemWithEqualStrokes > -1) {\n      scopedKeymap.splice(indexOfFirstItemWithEqualStrokes, 0, item);\n    } else {\n      scopedKeymap.push(item);\n    }\n  }\n\n  /**\n   * Clear all `resolved` properties of registered keybindings so the KeyboardLayoutService is called\n   * again to resolve them. This is necessary when the user's keyboard layout has changed.\n   */\n  protected clearResolvedKeybindings(): void {\n    for (let i = KeybindingScope.DEFAULT; i < KeybindingScope.END; i++) {\n      const bindings = this.keymaps[i];\n      for (let j = 0; j < bindings.length; j++) {\n        const binding = bindings[j] as ResolvedKeybinding;\n        binding.resolved = undefined;\n      }\n    }\n  }\n\n  /**\n   * Finds collisions for a key sequence inside a list of bindings (error-free)\n   *\n   * @param bindings the reference bindings\n   * @param candidate the sequence to match\n   */\n  protected getKeySequenceCollisions(bindings: ScopedKeybinding[], candidate: KeySequence): KeybindingRegistry.KeybindingsResult {\n    const result = new KeybindingRegistry.KeybindingsResult();\n    for (const binding of bindings) {\n      try {\n        const bindingKeySequence = this.resolveKeybinding(binding);\n        const compareResult = KeySequence.compare(candidate, bindingKeySequence);\n        switch (compareResult) {\n          case KeySequence.CompareResult.FULL: {\n            result.full.push(binding);\n            break;\n          }\n          case KeySequence.CompareResult.PARTIAL: {\n            result.partial.push(binding);\n            break;\n          }\n          case KeySequence.CompareResult.SHADOW: {\n            result.shadow.push(binding);\n            break;\n          }\n        }\n      } catch (error) {\n        // this.logger.warn(error);\n      }\n    }\n    return result;\n  }\n\n  protected isActive(binding: common.Keybinding): boolean {\n    /* Pseudo commands like \"passthrough\" are always active (and not found\n       in the command registry).  */\n    if (this.isPseudoCommand(binding.command)) {\n      return true;\n    }\n\n    const command = this.commandRegistry.getCommand(binding.command);\n    return !!command && !!this.commandRegistry.getActiveHandler(command.id);\n  }\n\n  /**\n   * Tries to execute a keybinding.\n   *\n   * @param binding to execute\n   * @param event keyboard event.\n   */\n  protected executeKeyBinding(binding: common.Keybinding, event: KeyboardEvent): void {\n    if (this.isPseudoCommand(binding.command)) {\n      /* Don't do anything, let the event propagate.  */\n    } else {\n      const command = this.commandRegistry.getCommand(binding.command);\n      if (command) {\n        if (this.commandRegistry.isEnabled(binding.command, binding.args)) {\n          this.commandRegistry.executeCommand(binding.command, binding.args)\n              .catch(e => console.error('Failed to execute command:', e));\n        }\n\n        /* Note that if a keybinding is in context but the command is\n           not active we still stop the processing here.  */\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  }\n\n  /**\n   * Only execute if it has no context (global context) or if we're in that context.\n   */\n  protected isEnabled(binding: common.Keybinding, event: KeyboardEvent): boolean {\n    const context = binding.context && this.contexts[binding.context];\n    if (context && !context.isEnabled(binding)) {\n      return false;\n    }\n    if (binding.when && !this.whenContextService.match(binding.when, <HTMLElement>event.target)) {\n      return false;\n    }\n    return true;\n  }\n\n  protected asKeyboardEventInit(input: KeyboardEventInit | KeyCode | string): KeyboardEventInit & Partial<{ keyCode: number }> {\n    if (typeof input === 'string') {\n      return this.asKeyboardEventInit(KeyCode.createKeyCode(input));\n    }\n    if (input instanceof KeyCode) {\n      return {\n        metaKey: input.meta,\n        shiftKey: input.shift,\n        altKey: input.alt,\n        ctrlKey: input.ctrl,\n        code: input.key && input.key.code,\n        key: (input && input.character) || (input.key && input.key.code),\n        keyCode: input.key && input.key.keyCode\n      };\n    }\n    return input;\n  }\n\n  /**\n   * Returns true if the binding is usable\n   * @param binding Binding to be checked\n   */\n  protected isUsable(binding: common.Keybinding): boolean {\n    return binding.command.charAt(0) !== '-';\n  }\n\n  /**\n   * Return a new filtered array containing only the usable bindings among the input bindings\n   * @param bindings Bindings to filter\n   */\n  protected getUsableBindings<T extends common.Keybinding>(bindings: T[]): T[] {\n    return bindings.filter(binding => this.isUsable(binding));\n  }\n}\n\nexport namespace KeybindingRegistry {\n  export type Match = {\n    kind: 'full' | 'partial'\n    binding: ScopedKeybinding\n  } | undefined;\n\n  export class KeybindingsResult {\n    full: ScopedKeybinding[] = [];\n    partial: ScopedKeybinding[] = [];\n    shadow: ScopedKeybinding[] = [];\n\n    /**\n     * Merge two results together inside `this`\n     *\n     * @param other the other KeybindingsResult to merge with\n     * @return this\n     */\n    merge(other: KeybindingsResult): KeybindingsResult {\n      this.full.push(...other.full);\n      this.partial.push(...other.partial);\n      this.shadow.push(...other.shadow);\n      return this;\n    }\n\n    /**\n     * Returns a new filtered KeybindingsResult\n     *\n     * @param fn callback filter on the results\n     * @return filtered new result\n     */\n    filter(fn: (binding: common.Keybinding) => boolean): KeybindingsResult {\n      const result = new KeybindingsResult();\n      result.full = this.full.filter(fn);\n      result.partial = this.partial.filter(fn);\n      result.shadow = this.shadow.filter(fn);\n      return result;\n    }\n  }\n}\n"]}