{"version":3,"sources":["browser/widgets/widget.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAKlF,OAAO,EAAC,MAAM,EAAC,MAAM,iBAAiB,CAAC;AACvC,OAAO,EAAC,OAAO,EAAc,MAAM,mBAAmB,CAAC;AACvD,OAAO,EAAC,UAAU,EAAE,oBAAoB,EAAE,OAAO,EAAE,KAAK,EAAE,YAAY,EAAC,MAAM,cAAc,CAAC;AAC5F,OAAO,EAAC,OAAO,EAAE,cAAc,EAAC,MAAM,aAAa,CAAC;AAEpD,OAAO,gBAAgB,MAAM,mBAAmB,CAAC;AAKjD,cAAc,iBAAiB,CAAC;AAChC,cAAc,mBAAmB,CAAC;AAElC,eAAO,MAAM,WAAW,gBAAgB,CAAC;AAEzC,wBAAgB,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,UAAU,UAAQ,GAAG,MAAM,EAAE,CAMvE;AAED,wBAAgB,OAAO,CAAC,IAAI,EAAE,MAAM,EAAE,UAAU,UAAQ,GAAG,MAAM,CAEhE;AAED,eAAO,MAAM,cAAc,sBAAsB,CAAC;AAClD,eAAO,MAAM,sBAAsB,yBAAyB,CAAC;AAC7D,eAAO,MAAM,yBAAyB,UAA+B,CAAC;AACtE,eAAO,MAAM,eAAe,uBAAuB,CAAC;AACpD,eAAO,MAAM,UAAU,kBAAkB,CAAC;AAC1C,eAAO,MAAM,uBAAuB,UAA0B,CAAC;AAC/D,eAAO,MAAM,cAAc,sBAAsB,CAAC;AAClD,eAAO,MAAM,WAAW,mBAAmB,CAAC;AAC5C,eAAO,MAAM,sBAAsB,EAAE,gBAAgB,CAAC,OAGrD,CAAC;AAEF;;;;;GAKG;AACH,yBAAiB,qBAAqB,CAAC;IACrC;;;;OAIG;IACH,SAAgB,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAI3C;IAED;;;;;;;OAOG;IAEH,SAAgB,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,GAAE,WAAW,GAAG,IAAW,GAAG,IAAI,CAI9F;CACF;AAED,qBACa,UAAW,SAAQ,MAAM;IAEpC,QAAQ,CAAC,wBAAwB,gBAAuB;IACxD,iBAAiB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAuC;IACrE,SAAS,CAAC,QAAQ,CAAC,iBAAiB,gBAAuB;IAC3D,QAAQ,CAAC,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,CAAgC;IAChE,SAAS,CAAC,QAAQ,CAAC,4BAA4B,mBAA0B;IACzE,QAAQ,CAAC,qBAAqB,iBAA2C;IACzE,SAAS,CAAC,QAAQ,CAAC,mBAAmB,gBAAuB;IAC7D,QAAQ,CAAC,YAAY,cAAkC;IAEvD,SAAS,CAAC,QAAQ,CAAC,SAAS,uBAM1B;IACF,SAAS,CAAC,QAAQ,CAAC,iBAAiB,uBAA8B;IAClE,SAAS,CAAC,SAAS,CAAC,EAAE,gBAAgB,CAAC;IACvC,SAAS,CAAC,aAAa,CAAC,EAAE,gBAAgB,CAAC,OAAO,CAAC;IAEnD,OAAO,IAAI,IAAI;IAQf,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI;IAOhC,SAAS,CAAC,IAAI,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI;IAOlC,SAAS,CAAC,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAK5C,SAAS,CAAC,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAO5C,SAAS,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAO3C,SAAS,CAAC,cAAc,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAK5C,SAAS,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAyB3C,SAAS,CAAC,kBAAkB,IAAI,YAAY,CAAC,WAAW,CAAC;IAIzD,SAAS,CAAC,qBAAqB,CAAC,eAAe,EAAE,WAAW,GAAG,IAAI;IAWnE,SAAS,CAAC,eAAe,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAO7C,SAAS,CAAC,iBAAiB,CAAC,CAAC,SAAS,MAAM,mBAAmB,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO,GAAG,IAAI;IAO3H,SAAS,CAAC,gBAAgB,CAAC,CAAC,SAAS,MAAM,mBAAmB,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,kCAAkC,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO,GAAG,IAAI;IAI3K,SAAS,CAAC,cAAc,CAAC,CAAC,SAAS,MAAM,mBAAmB,EACxD,OAAO,EAAE,WAAW,EACpB,cAAc,EAAE,OAAO,CAAC,SAAS,GAAG,cAAc,EAClD,MAAM,EAAE,CAAC,KAAK,EAAE,aAAa,KAAK,OAAO,GAAG,IAAI,GAAG,MAAM,EAAE,GAAG,oBAAoB,EAAE,CAAC,EAAE,GAAG,IAAI;IAIlG,SAAS,CAAC,oBAAoB,CAAC,CAAC,SAAS,KAAK,GAAG,MAAM,GAAG,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,kCAAkC,CAAC,CAAC,CAAC,GAAG,IAAI;CAGzJ;AAED,wBAAgB,UAAU,CAAC,OAAO,EAAE,WAAW,EAAE,OAAO,EAAE,OAAO,GAAG,IAAI,CAGvE;AAED,wBAAgB,gBAAgB,CAAC,GAAG,UAAU,EAAE,MAAM,EAAE,GAAG,eAAe,CAOzE;AAGD,oBAAY,aAAa,CAAC,CAAC,SAAS,MAAM,mBAAmB,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,mBAAmB,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC;AAE3H,MAAM,WAAW,mBAAmB,CAAC,CAAC,SAAS,MAAM,mBAAmB;IACtE,WAAW,CAAC,GAAG,EAAE,mBAAmB,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;CAChD;AAED,yBAAiB,mBAAmB,CAAC;IAEnC,SAAgB,EAAE,CAAC,CAAC,SAAS,MAAM,mBAAmB,EAAE,QAAQ,EAAE,GAAG,GAAG,SAAS,GAAG,QAAQ,IAAI,mBAAmB,CAAC,CAAC,CAAC,CAErH;CACF;AACD,oBAAY,kCAAkC,CAAC,CAAC,SAAS,MAAM,mBAAmB,IAC9E,aAAa,CAAC,CAAC,CAAC,GACd,mBAAmB,CAAC,CAAC,CAAC,CAAC;AAE7B,wBAAgB,gBAAgB,CAAC,CAAC,SAAS,MAAM,mBAAmB,EAChE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,kCAAkC,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,OAAO,GACrG,UAAU,CAKZ;AAED,wBAAgB,cAAc,CAAC,CAAC,SAAS,MAAM,mBAAmB,EAC9D,OAAO,EAAE,WAAW,EACpB,cAAc,EAAE,OAAO,CAAC,SAAS,GAAG,cAAc,EAClD,MAAM,EAAE,CAAC,KAAK,EAAE,aAAa,KAAK,OAAO,GAAG,IAAI,GAAG,MAAM,EAAE,GAAG,oBAAoB,EAAE,CAAC,EAAE,GAAG,UAAU,CAgCvG;AAED,wBAAgB,oBAAoB,CAAC,CAAC,SAAS,KAAK,GAAG,MAAM,GAAG,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,EAAE,kCAAkC,CAAC,CAAC,CAAC,GAAG,UAAU,CAenK;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAE3D;AAED;;GAEG;AACH,wBAAgB,eAAe,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAE7D;AAED;;GAEG;AACH,wBAAgB,aAAa,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAE3D","file":"../../../src/browser/widgets/widget.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {decorate, injectable, unmanaged} from 'inversify';\nimport {Widget} from '@lumino/widgets';\nimport {Message, MessageLoop} from '@lumino/messaging';\nimport {Disposable, DisposableCollection, Emitter, Event, MaybePromise} from '../../common';\nimport {KeyCode, KeysOrKeyCodes} from '../keyboard';\n\nimport PerfectScrollbar from 'perfect-scrollbar';\n\ndecorate(injectable(), Widget);\ndecorate(unmanaged(), Widget, 0);\n\nexport * from '@lumino/widgets';\nexport * from '@lumino/messaging';\n\nexport const ACTION_ITEM = 'action-item';\n\nexport function codiconArray(name: string, actionItem = false): string[] {\n  const array = ['codicon', `codicon-${name}`];\n  if (actionItem) {\n    array.push(ACTION_ITEM);\n  }\n  return array;\n}\n\nexport function codicon(name: string, actionItem = false): string {\n  return `codicon codicon-${name}${actionItem ? ` ${ACTION_ITEM}` : ''}`;\n}\n\nexport const DISABLED_CLASS = 'tart-mod-disabled';\nexport const EXPANSION_TOGGLE_CLASS = 'tart-ExpansionToggle';\nexport const CODICON_TREE_ITEM_CLASSES = codiconArray('chevron-down');\nexport const COLLAPSED_CLASS = 'tart-mod-collapsed';\nexport const BUSY_CLASS = 'tart-mod-busy';\nexport const CODICON_LOADING_CLASSES = codiconArray('loading');\nexport const SELECTED_CLASS = 'tart-mod-selected';\nexport const FOCUS_CLASS = 'tart-mod-focus';\nexport const DEFAULT_SCROLL_OPTIONS: PerfectScrollbar.Options = {\n  suppressScrollX: true,\n  minScrollbarLength: 35,\n};\n\n/**\n * At a number of places in the code, we have effectively reimplemented Phosphor's Widget.attach and Widget.detach,\n * but omitted the checks that Phosphor expects to be performed for those operations. That is a bad idea, because it\n * means that we are telling widgets that they are attached or detached when not all the conditions that should apply\n * do apply. We should explicitly mark those locations so that we know where we should go fix them later.\n */\nexport namespace UnsafeWidgetUtilities {\n  /**\n   * Ordinarily, the following checks should be performed before detaching a widget:\n   * It should not be the child of another widget\n   * It should be attached and it should be a child of document.body\n   */\n  export function detach(widget: Widget): void {\n    MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n    widget.node.remove();\n    MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n  }\n\n  /**\n   * @param ref The child of the host element to insert the widget before.\n   * Ordinarily the following checks should be performed:\n   * The widget should have no parent\n   * The widget should not be attached, and its node should not be a child of document.body\n   * The host should be a child of document.body\n   * We often violate the last condition.\n   */\n  // eslint-disable-next-line no-null/no-null\n  export function attach(widget: Widget, host: HTMLElement, ref: HTMLElement | null = null): void {\n    MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n    host.insertBefore(widget.node, ref);\n    MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n  }\n}\n\n@injectable()\nexport class BaseWidget extends Widget {\n\n  readonly onScrollYReachEndEmitter = new Emitter<void>();\n  onScrollYReachEnd: Event<void> = this.onScrollYReachEndEmitter.event;\n  protected readonly onScrollUpEmitter = new Emitter<void>();\n  readonly onScrollUp: Event<void> = this.onScrollUpEmitter.event;\n  protected readonly onDidChangeVisibilityEmitter = new Emitter<boolean>();\n  readonly onDidChangeVisibility = this.onDidChangeVisibilityEmitter.event;\n  protected readonly onDidDisposeEmitter = new Emitter<void>();\n  readonly onDidDispose = this.onDidDisposeEmitter.event;\n\n  protected readonly toDispose = new DisposableCollection(\n      this.onDidDisposeEmitter,\n      Disposable.create(() => this.onDidDisposeEmitter.fire()),\n      this.onScrollYReachEndEmitter,\n      this.onScrollUpEmitter,\n      this.onDidChangeVisibilityEmitter\n  );\n  protected readonly toDisposeOnDetach = new DisposableCollection();\n  protected scrollBar?: PerfectScrollbar;\n  protected scrollOptions?: PerfectScrollbar.Options;\n\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    super.dispose();\n    this.toDispose.dispose();\n  }\n\n  setFlag(flag: Widget.Flag): void {\n    super.setFlag(flag);\n    if (flag === Widget.Flag.IsVisible) {\n      this.onDidChangeVisibilityEmitter.fire(this.isVisible);\n    }\n  }\n\n  clearFlag(flag: Widget.Flag): void {\n    super.clearFlag(flag);\n    if (flag === Widget.Flag.IsVisible) {\n      this.onDidChangeVisibilityEmitter.fire(this.isVisible);\n    }\n  }\n\n  protected onCloseRequest(msg: Message): void {\n    super.onCloseRequest(msg);\n    this.dispose();\n  }\n\n  protected onBeforeAttach(msg: Message): void {\n    if (this.title.iconClass === '') {\n      this.title.iconClass = 'no-icon';\n    }\n    super.onBeforeAttach(msg);\n  }\n\n  protected onAfterDetach(msg: Message): void {\n    if (this.title.iconClass === 'no-icon') {\n      this.title.iconClass = '';\n    }\n    super.onAfterDetach(msg);\n  }\n\n  protected onBeforeDetach(msg: Message): void {\n    this.toDisposeOnDetach.dispose();\n    super.onBeforeDetach(msg);\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    super.onAfterAttach(msg);\n    if (this.scrollOptions) {\n      (async () => {\n        const container = await this.getScrollContainer();\n        container.style.overflow = 'hidden';\n        this.scrollBar = new PerfectScrollbar(container, this.scrollOptions);\n        this.disableScrollBarFocus(container);\n        this.toDisposeOnDetach.push(addEventListener(container, <any>'ps-y-reach-end', () => {\n          this.onScrollYReachEndEmitter.fire(undefined);\n        }));\n        this.toDisposeOnDetach.push(addEventListener(container, <any>'ps-scroll-up', () => {\n          this.onScrollUpEmitter.fire(undefined);\n        }));\n        this.toDisposeOnDetach.push(Disposable.create(() => {\n          if (this.scrollBar) {\n            this.scrollBar.destroy();\n            this.scrollBar = undefined;\n          }\n          container.style.overflow = 'initial';\n        }));\n      })();\n    }\n  }\n\n  protected getScrollContainer(): MaybePromise<HTMLElement> {\n    return this.node;\n  }\n\n  protected disableScrollBarFocus(scrollContainer: HTMLElement): void {\n    for (const thumbs of [scrollContainer.getElementsByClassName('ps__thumb-x'), scrollContainer.getElementsByClassName('ps__thumb-y')]) {\n      for (let i = 0; i < thumbs.length; i++) {\n        const element = thumbs.item(i);\n        if (element) {\n          element.removeAttribute('tabIndex');\n        }\n      }\n    }\n  }\n\n  protected onUpdateRequest(msg: Message): void {\n    super.onUpdateRequest(msg);\n    if (this.scrollBar) {\n      this.scrollBar.update();\n    }\n  }\n\n  protected addUpdateListener<K extends keyof HTMLElementEventMap>(element: HTMLElement, type: K, useCapture?: boolean): void {\n    this.addEventListener(element, type, e => {\n      this.update();\n      e.preventDefault();\n    }, useCapture);\n  }\n\n  protected addEventListener<K extends keyof HTMLElementEventMap>(element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject<K>, useCapture?: boolean): void {\n    this.toDisposeOnDetach.push(addEventListener(element, type, listener, useCapture));\n  }\n\n  protected addKeyListener<K extends keyof HTMLElementEventMap>(\n      element: HTMLElement,\n      keysOrKeyCodes: KeyCode.Predicate | KeysOrKeyCodes,\n      action: (event: KeyboardEvent) => boolean | void | Object, ...additionalEventTypes: K[]): void {\n    this.toDisposeOnDetach.push(addKeyListener(element, keysOrKeyCodes, action, ...additionalEventTypes));\n  }\n\n  protected addClipboardListener<K extends 'cut' | 'copy' | 'paste'>(element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject<K>): void {\n    this.toDisposeOnDetach.push(addClipboardListener(element, type, listener));\n  }\n}\n\nexport function setEnabled(element: HTMLElement, enabled: boolean): void {\n  element.classList.toggle(DISABLED_CLASS, !enabled);\n  element.tabIndex = enabled ? 0 : -1;\n}\n\nexport function createIconButton(...classNames: string[]): HTMLSpanElement {\n  const icon = document.createElement('i');\n  icon.classList.add(...classNames);\n  const button = document.createElement('span');\n  button.tabIndex = 0;\n  button.appendChild(icon);\n  return button;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type EventListener<K extends keyof HTMLElementEventMap> = (this: HTMLElement, event: HTMLElementEventMap[K]) => any;\n\nexport interface EventListenerObject<K extends keyof HTMLElementEventMap> {\n  handleEvent(evt: HTMLElementEventMap[K]): void;\n}\n\nexport namespace EventListenerObject {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is<K extends keyof HTMLElementEventMap>(listener: any | undefined): listener is EventListenerObject<K> {\n    return !!listener && 'handleEvent' in listener;\n  }\n}\nexport type EventListenerOrEventListenerObject<K extends keyof HTMLElementEventMap> =\n    EventListener<K>\n    | EventListenerObject<K>;\n\nexport function addEventListener<K extends keyof HTMLElementEventMap>(\n    element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject<K>, useCapture?: boolean\n): Disposable {\n  element.addEventListener(type, listener, useCapture);\n  return Disposable.create(() =>\n      element.removeEventListener(type, listener, useCapture)\n  );\n}\n\nexport function addKeyListener<K extends keyof HTMLElementEventMap>(\n    element: HTMLElement,\n    keysOrKeyCodes: KeyCode.Predicate | KeysOrKeyCodes,\n    action: (event: KeyboardEvent) => boolean | void | Object, ...additionalEventTypes: K[]): Disposable {\n\n  const toDispose = new DisposableCollection();\n  const keyCodePredicate = (() => {\n    if (typeof keysOrKeyCodes === 'function') {\n      return keysOrKeyCodes;\n    } else {\n      return (actual: KeyCode) => KeysOrKeyCodes.toKeyCodes(keysOrKeyCodes).some(k => k.equals(actual));\n    }\n  })();\n  toDispose.push(addEventListener(element, 'keydown', e => {\n    const kc = KeyCode.createKeyCode(e);\n    if (keyCodePredicate(kc)) {\n      const result = action(e);\n      if (typeof result !== 'boolean' || result) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  }));\n  for (const type of additionalEventTypes) {\n    toDispose.push(addEventListener(element, type, e => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const event = (type as any)['keydown'];\n      const result = action(event);\n      if (typeof result !== 'boolean' || result) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }));\n  }\n  return toDispose;\n}\n\nexport function addClipboardListener<K extends 'cut' | 'copy' | 'paste'>(element: HTMLElement, type: K, listener: EventListenerOrEventListenerObject<K>): Disposable {\n  const documentListener = (e: ClipboardEvent) => {\n    const activeElement = document.activeElement;\n    if (activeElement && element.contains(activeElement)) {\n      if (EventListenerObject.is(listener)) {\n        listener.handleEvent(e);\n      } else {\n        listener.bind(element)(e);\n      }\n    }\n  };\n  document.addEventListener(type, documentListener);\n  return Disposable.create(() =>\n      document.removeEventListener(type, documentListener)\n  );\n}\n\n/**\n * Resolves when the given widget is detached and hidden.\n */\nexport function waitForClosed(widget: Widget): Promise<void> {\n  return waitForVisible(widget, false, false);\n}\n\n/**\n * Resolves when the given widget is attached and visible.\n */\nexport function waitForRevealed(widget: Widget): Promise<void> {\n  return waitForVisible(widget, true, true);\n}\n\n/**\n * Resolves when the given widget is hidden regardless of attachment.\n */\nexport function waitForHidden(widget: Widget): Promise<void> {\n  return waitForVisible(widget, true);\n}\n\nfunction waitForVisible(widget: Widget, visible: boolean, attached?: boolean): Promise<void> {\n  if ((typeof attached !== 'boolean' || widget.isAttached === attached) &&\n      (widget.isVisible === visible || (widget.node.style.visibility !== 'hidden') === visible)\n  ) {\n    return new Promise(resolve => window.requestAnimationFrame(() => resolve()));\n  }\n  return new Promise(resolve => {\n    const waitFor = () => window.requestAnimationFrame(() => {\n      if ((typeof attached !== 'boolean' || widget.isAttached === attached) &&\n          (widget.isVisible === visible || (widget.node.style.visibility !== 'hidden') === visible)) {\n        window.requestAnimationFrame(() => resolve());\n      } else {\n        waitFor();\n      }\n    });\n    waitFor();\n  });\n}\n"]}