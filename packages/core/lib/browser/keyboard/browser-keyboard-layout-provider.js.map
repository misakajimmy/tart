{"version":3,"sources":["browser/keyboard/browser-keyboard-layout-provider.ts"],"names":[],"mappings":"AAAA,oFAAoF;AACpF,4CAA4C;AAC5C,KAAK;AACL,8EAA8E;AAC9E,sEAAsE;AACtE,2CAA2C;AAC3C,KAAK;AACL,+EAA+E;AAC/E,iFAAiF;AACjF,gFAAgF;AAChF,4DAA4D;AAC5D,0DAA0D;AAC1D,KAAK;AACL,8EAA8E;AAC9E,qFAAqF;AACrF,EAAE;AACF,+DAA+D;AAC/D,yCAAyC;AACzC,+CAA+C;AAC/C,kDAAkD;AAClD,sDAAsD;AACtD,WAAW;AACX,mHAAmH;AACnH,2DAA2D;AAC3D,0DAA0D;AAC1D,EAAE;AACF,4FAA4F;AAC5F,EAAE;AACF,gBAAgB;AAChB,6HAA6H;AAC7H,EAAE;AACF,0BAA0B;AAC1B,6CAA6C;AAC7C,EAAE;AACF,mCAAmC;AACnC,8DAA8D;AAC9D,EAAE;AACF,uDAAuD;AACvD,oFAAoF;AACpF,EAAE;AACF,mEAAmE;AACnE,iDAAiD;AACjD,QAAQ;AACR,EAAE;AACF,wEAAwE;AACxE,+DAA+D;AAC/D,yEAAyE;AACzE,EAAE;AACF,kDAAkD;AAClD,iDAAiD;AACjD,QAAQ;AACR,EAAE;AACF,oDAAoD;AACpD,qCAAqC;AACrC,QAAQ;AACR,EAAE;AACF,wDAAwD;AACxD,8BAA8B;AAC9B,QAAQ;AACR,EAAE;AACF,uBAAuB;AACvB,oDAAoD;AACpD,kCAAkC;AAClC,uEAAuE;AACvE,uDAAuD;AACvD,sEAAsE;AACtE,kEAAkE;AAClE,4DAA4D;AAC5D,kBAAkB;AAClB,YAAY;AACZ,sCAAsC;AACtC,QAAQ;AACR,EAAE;AACF,+DAA+D;AAC/D,0CAA0C;AAC1C,+CAA+C;AAC/C,6CAA6C;AAC7C,YAAY;AACZ,4DAA4D;AAC5D,2CAA2C;AAC3C,6BAA6B;AAC7B,QAAQ;AACR,EAAE;AACF,UAAU;AACV,+CAA+C;AAC/C,UAAU;AACV,oGAAoG;AACpG,yCAAyC;AACzC,mDAAmD;AACnD,uEAAuE;AACvE,sDAAsD;AACtD,gEAAgE;AAChE,oCAAoC;AACpC,gBAAgB;AAChB,yCAAyC;AACzC,mBAAmB;AACnB,oFAAoF;AACpF,0DAA0D;AAC1D,6DAA6D;AAC7D,gBAAgB;AAChB,6BAA6B;AAC7B,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,UAAU;AACV,uFAAuF;AACvF,oFAAoF;AACpF,wFAAwF;AACxF,gCAAgC;AAChC,UAAU;AACV,uDAAuD;AACvD,gDAAgD;AAChD,sBAAsB;AACtB,YAAY;AACZ,8DAA8D;AAC9D,2BAA2B;AAC3B,sBAAsB;AACtB,YAAY;AACZ,8CAA8C;AAC9C,iFAAiF;AACjF,uDAAuD;AACvD,yDAAyD;AACzD,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,6FAA6F;AAC7F,uCAAuC;AACvC,gCAAgC;AAChC,4BAA4B;AAC5B,0GAA0G;AAC1G,uFAAuF;AACvF,yEAAyE;AACzE,0GAA0G;AAC1G,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,0FAA0F;AAC1F,uEAAuE;AACvE,mDAAmD;AACnD,oBAAoB;AACpB,mEAAmE;AACnE,iDAAiD;AACjD,sEAAsE;AACtE,gCAAgC;AAChC,uFAAuF;AACvF,gBAAgB;AAChB,YAAY;AACZ,wDAAwD;AACxD,QAAQ;AACR,EAAE;AACF,UAAU;AACV,kGAAkG;AAClG,UAAU;AACV,oEAAoE;AACpE,+BAA+B;AAC/B,2DAA2D;AAC3D,gEAAgE;AAChE,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,UAAU;AACV,oFAAoF;AACpF,iDAAiD;AACjD,UAAU;AACV,qDAAqD;AACrD,qDAAqD;AACrD,6CAA6C;AAC7C,iDAAiD;AACjD,+CAA+C;AAC/C,mCAAmC;AACnC,mCAAmC;AACnC,wDAAwD;AACxD,4CAA4C;AAC5C,mDAAmD;AACnD,uDAAuD;AACvD,iFAAiF;AACjF,4CAA4C;AAC5C,wBAAwB;AACxB,yCAAyC;AACzC,oBAAoB;AACpB,qCAAqC;AACrC,gBAAgB;AAChB,YAAY;AACZ,sCAAsC;AACtC,kGAAkG;AAClG,YAAY;AACZ,sCAAsC;AACtC,yEAAyE;AACzE,YAAY;AACZ,sCAAsC;AACtC,QAAQ;AACR,EAAE;AACF,6CAA6C;AAC7C,8CAA8C;AAC9C,8CAA8C;AAC9C,mCAAmC;AACnC,sHAAsH;AACtH,aAAa;AACb,gEAAgE;AAChE,QAAQ;AACR,EAAE;AACF,mDAAmD;AACnD,2FAA2F;AAC3F,sBAAsB;AACtB,uDAAuD;AACvD,2DAA2D;AAC3D,wCAAwC;AACxC,0GAA0G;AAC1G,gCAAgC;AAChC,mDAAmD;AACnD,oBAAoB;AACpB,uBAAuB;AACvB,4DAA4D;AAC5D,gBAAgB;AAChB,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,IAAI;AACJ,EAAE;AACF,wCAAwC;AACxC,oBAAoB;AACpB,8BAA8B;AAC9B,wBAAwB;AACxB,iCAAiC;AACjC,IAAI;AACJ,EAAE;AACF,wDAAwD;AACxD,6DAA6D;AAC7D,IAAI;AACJ,EAAE;AACF,MAAM;AACN,8EAA8E;AAC9E,2FAA2F;AAC3F,MAAM;AACN,2DAA2D;AAC3D,kBAAkB;AAClB,sCAAsC;AACtC,sBAAsB;AACtB,aAAa;AACb,yEAAyE;AACzE,2BAA2B;AAC3B,sBAAsB;AACtB,QAAQ;AACR,KAAK;AACL,EAAE;AACF,yCAAyC;AACzC,oCAAoC;AACpC,qCAAqC;AACrC,8BAA8B;AAC9B,IAAI;AACJ,EAAE;AACF,yCAAyC;AACzC,yCAAyC;AACzC,yBAAyB;AACzB,+CAA+C;AAC/C,IAAI;AACJ,EAAE;AACF,MAAM;AACN,2EAA2E;AAC3E,yEAAyE;AACzE,0BAA0B;AAC1B,MAAM;AACN,gCAAgC;AAChC,EAAE;AACF,iCAAiC;AACjC,4BAA4B;AAC5B,EAAE;AACF,iEAAiE;AACjE,EAAE;AACF,iCAAiC;AACjC,yCAAyC;AACzC,QAAQ;AACR,EAAE;AACF,+DAA+D;AAC/D,sDAAsD;AACtD,QAAQ;AACR,EAAE;AACF,sBAAsB;AACtB,yDAAyD;AACzD,kCAAkC;AAClC,YAAY;AACZ,6BAA6B;AAC7B,qCAAqC;AACrC,QAAQ;AACR,EAAE;AACF,yDAAyD;AACzD,gFAAgF;AAChF,gDAAgD;AAChD,2CAA2C;AAC3C,uCAAuC;AACvC,sCAAsC;AACtC,qCAAqC;AACrC,sCAAsC;AACtC,mBAAmB;AACnB,kCAAkC;AAClC,YAAY;AACZ,wDAAwD;AACxD,iDAAiD;AACjD,yEAAyE;AACzE,gCAAgC;AAChC,uBAAuB;AACvB,8EAA8E;AAC9E,sFAAsF;AACtF,gCAAgC;AAChC,gBAAgB;AAChB,YAAY;AACZ,EAAE;AACF,sCAAsC;AACtC,6DAA6D;AAC7D,oFAAoF;AACpF,+CAA+C;AAC/C,6CAA6C;AAC7C,gBAAgB;AAChB,YAAY;AACZ,4DAA4D;AAC5D,uBAAuB;AACvB,QAAQ;AACR,EAAE;AACF,wFAAwF;AACxF,0GAA0G;AAC1G,gEAAgE;AAChE,oDAAoD;AACpD,uEAAuE;AACvE,mBAAmB;AACnB,wBAAwB;AACxB,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,wCAAwC;AACxC,uDAAuD;AACvD,yDAAyD;AACzD,wEAAwE;AACxE,YAAY;AACZ,8DAA8D;AAC9D,wEAAwE;AACxE,6CAA6C;AAC7C,YAAY;AACZ,mBAAmB;AACnB,sBAAsB;AACtB,uCAAuC;AACvC,2BAA2B;AAC3B,aAAa;AACb,QAAQ;AACR,EAAE;AACF,mDAAmD;AACnD,wBAAwB;AACxB,8BAA8B;AAC9B,kEAAkE;AAClE,+CAA+C;AAC/C,yDAAyD;AACzD,2DAA2D;AAC3D,uCAAuC;AACvC,iEAAiE;AACjE,wBAAwB;AACxB,oBAAoB;AACpB,gBAAgB;AAChB,YAAY;AACZ,gCAAgC;AAChC,8CAA8C;AAC9C,YAAY;AACZ,oCAAoC;AACpC,sDAAsD;AACtD,gEAAgE;AAChE,2EAA2E;AAC3E,oBAAoB;AACpB,gBAAgB;AAChB,YAAY;AACZ,QAAQ;AACR,EAAE;AACF,IAAI;AACJ,EAAE;AACF,MAAM;AACN,2DAA2D;AAC3D,MAAM;AACN,mDAAmD;AACnD,0BAA0B;AAC1B,IAAI;AACJ,EAAE;AACF,uBAAuB;AACvB,kDAAkD;AAClD,EAAE;AACF,kGAAkG;AAClG,IAAI;AACJ,EAAE;AACF,gDAAgD;AAChD,EAAE;AACF,6DAA6D;AAC7D,uFAAuF;AACvF,IAAI;AACJ,EAAE;AACF,MAAM;AACN,2EAA2E;AAC3E,uCAAuC;AACvC,KAAK;AACL,8DAA8D;AAC9D,wEAAwE;AACxE,iCAAiC;AACjC,MAAM;AACN,iEAAiE;AACjE,iEAAiE;AACjE,kBAAkB;AAClB,2CAA2C;AAC3C,iDAAiD;AACjD,uBAAuB;AACvB,2HAA2H;AAC3H,mEAAmE;AACnE,wFAAwF;AACxF,YAAY;AACZ,OAAO;AACP,EAAE;AACF,oDAAoD;AACpD,mFAAmF;AACnF,6DAA6D;AAC7D,oFAAoF;AACpF,qFAAqF;AACrF,gEAAgE;AAChE,iBAAiB;AACjB,IAAI","file":"../../../src/browser/keyboard/browser-keyboard-layout-provider.js","sourcesContent":["// /********************************************************************************\n//  * Copyright (C) 2019 TypeFox and others.\n//  *\n//  * This program and the accompanying materials are made available under the\n//  * terms of the Eclipse Public License v. 2.0 which is available at\n//  * http://www.eclipse.org/legal/epl-2.0.\n//  *\n//  * This Source Code may also be made available under the following Secondary\n//  * Licenses when the conditions for such availability set forth in the Eclipse\n//  * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n//  * with the GNU Classpath Exception which is available at\n//  * https://www.gnu.org/software/classpath/license.html.\n//  *\n//  * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n//  ********************************************************************************/\n//\n// import {injectable, postConstruct, inject} from 'inversify';\n// import {isOSX} from '../../common/os';\n// import {Emitter, Event} from '../../common';\n// // import {ILogger} from '../../common/logger';\n// import {Deferred} from '../../common/promise-util';\n// import {\n//     NativeKeyboardLayout, KeyboardLayoutProvider, KeyboardLayoutChangeNotifier, KeyValidator, KeyValidationInput\n// } from '../../common/keyboard/keyboard-layout-provider';\n// import {LocalStorageService} from '../storage-service';\n//\n// export type KeyboardLayoutSource = 'navigator.keyboard' | 'user-choice' | 'pressed-keys';\n//\n// @injectable()\n// export class BrowserKeyboardLayoutProvider implements KeyboardLayoutProvider, KeyboardLayoutChangeNotifier, KeyValidator {\n//\n//     // @inject(ILogger)\n//     // protected readonly logger: ILogger;\n//\n//     @inject(LocalStorageService)\n//     protected readonly storageService: LocalStorageService;\n//\n//     protected readonly initialized = new Deferred();\n//     protected readonly nativeLayoutChanged = new Emitter<NativeKeyboardLayout>();\n//\n//     get onDidChangeNativeLayout(): Event<NativeKeyboardLayout> {\n//         return this.nativeLayoutChanged.event;\n//     }\n//\n//     protected readonly tester = new KeyboardTester(loadAllLayouts());\n//     protected source: KeyboardLayoutSource = 'pressed-keys';\n//     protected currentLayout: KeyboardLayoutData = DEFAULT_LAYOUT_DATA;\n//\n//     get allLayoutData(): KeyboardLayoutData[] {\n//         return this.tester.candidates.slice();\n//     }\n//\n//     get currentLayoutData(): KeyboardLayoutData {\n//         return this.currentLayout;\n//     }\n//\n//     get currentLayoutSource(): KeyboardLayoutSource {\n//         return this.source;\n//     }\n//\n//     @postConstruct()\n//     protected async initialize(): Promise<void> {\n//         await this.loadState();\n//         const keyboard = (navigator as NavigatorExtension).keyboard;\n//         if (keyboard && keyboard.addEventListener) {\n//             keyboard.addEventListener('layoutchange', async () => {\n//                 const newLayout = await this.getNativeLayout();\n//                 this.nativeLayoutChanged.fire(newLayout);\n//             });\n//         }\n//         this.initialized.resolve();\n//     }\n//\n//     async getNativeLayout(): Promise<NativeKeyboardLayout> {\n//         await this.initialized.promise;\n//         if (this.source === 'user-choice') {\n//             return this.currentLayout.raw;\n//         }\n//         const [layout, source] = await this.autodetect();\n//         this.setCurrent(layout, source);\n//         return layout.raw;\n//     }\n//\n//     /**\n//      * Set user-chosen keyboard layout data.\n//      */\n//     async setLayoutData(layout: KeyboardLayoutData | 'autodetect'): Promise<KeyboardLayoutData> {\n//         if (layout === 'autodetect') {\n//             if (this.source === 'user-choice') {\n//                 const [newLayout, source] = await this.autodetect();\n//                 this.setCurrent(newLayout, source);\n//                 this.nativeLayoutChanged.fire(newLayout.raw);\n//                 return newLayout;\n//             }\n//             return this.currentLayout;\n//         } else {\n//             if (this.source !== 'user-choice' || layout !== this.currentLayout) {\n//                 this.setCurrent(layout, 'user-choice');\n//                 this.nativeLayoutChanged.fire(layout.raw);\n//             }\n//             return layout;\n//         }\n//     }\n//\n//     /**\n//      * Test all known keyboard layouts with the given combination of pressed key and\n//      * produced character. Matching layouts have their score increased (see class\n//      * KeyboardTester). If this leads to a change of the top-scoring layout, a layout\n//      * change event is fired.\n//      */\n//     validateKey(keyCode: KeyValidationInput): void {\n//         if (this.source !== 'pressed-keys') {\n//             return;\n//         }\n//         const accepted = this.tester.updateScores(keyCode);\n//         if (!accepted) {\n//             return;\n//         }\n//         const layout = this.selectLayout();\n//         if (layout !== this.currentLayout && layout !== DEFAULT_LAYOUT_DATA) {\n//             this.setCurrent(layout, 'pressed-keys');\n//             this.nativeLayoutChanged.fire(layout.raw);\n//         }\n//     }\n//\n//     protected setCurrent(layout: KeyboardLayoutData, source: KeyboardLayoutSource): void {\n//         this.currentLayout = layout;\n//         this.source = source;\n//         this.saveState();\n//         if (this.tester.inputCount && (source === 'pressed-keys' || source === 'navigator.keyboard')) {\n//             const from = source === 'pressed-keys' ? 'pressed keys' : 'browser API';\n//             const hardware = layout.hardware === 'mac' ? 'Mac' : 'PC';\n//             // this.logger.info(`Detected keyboard layout from ${from}: ${layout.name} (${hardware})`);\n//         }\n//     }\n//\n//     protected async autodetect(): Promise<[KeyboardLayoutData, KeyboardLayoutSource]> {\n//         const keyboard = (navigator as NavigatorExtension).keyboard;\n//         if (keyboard && keyboard.getLayoutMap) {\n//             try {\n//                 const layoutMap = await keyboard.getLayoutMap();\n//                 this.testLayoutMap(layoutMap);\n//                 return [this.selectLayout(), 'navigator.keyboard'];\n//             } catch (error) {\n//                 // this.logger.warn('Failed to obtain keyboard layout map.', error);\n//             }\n//         }\n//         return [this.selectLayout(), 'pressed-keys'];\n//     }\n//\n//     /**\n//      * @param layoutMap a keyboard layout map according to https://wicg.github.io/keyboard-map/\n//      */\n//     protected testLayoutMap(layoutMap: KeyboardLayoutMap): void {\n//         this.tester.reset();\n//         for (const [code, key] of layoutMap.entries()) {\n//             this.tester.updateScores({code, character: key});\n//         }\n//     }\n//\n//     /**\n//      * Select a layout based on the current tester state and the operating system\n//      * and language detected from the browser.\n//      */\n//     protected selectLayout(): KeyboardLayoutData {\n//         const candidates = this.tester.candidates;\n//         const scores = this.tester.scores;\n//         const topScore = this.tester.topScore;\n//         const language = navigator.language;\n//         let matchingOScount = 0;\n//         let topScoringCount = 0;\n//         for (let i = 0; i < candidates.length; i++) {\n//             if (scores[i] === topScore) {\n//                 const candidate = candidates[i];\n//                 if (osMatches(candidate.hardware)) {\n//                     if (language && language.startsWith(candidate.language)) {\n//                         return candidate;\n//                     }\n//                     matchingOScount++;\n//                 }\n//                 topScoringCount++;\n//             }\n//         }\n//         if (matchingOScount >= 1) {\n//             return candidates.find((c, i) => scores[i] === topScore && osMatches(c.hardware))!;\n//         }\n//         if (topScoringCount >= 1) {\n//             return candidates.find((_, i) => scores[i] === topScore)!;\n//         }\n//         return DEFAULT_LAYOUT_DATA;\n//     }\n//\n//     protected saveState(): Promise<void> {\n//         const data: LayoutProviderState = {\n//             tester: this.tester.getState(),\n//             source: this.source,\n//             currentLayout: this.currentLayout !== DEFAULT_LAYOUT_DATA ? getLayoutId(this.currentLayout) : undefined\n//         };\n//         return this.storageService.setData('keyboard', data);\n//     }\n//\n//     protected async loadState(): Promise<void> {\n//         const data = await this.storageService.getData<LayoutProviderState>('keyboard');\n//         if (data) {\n//             this.tester.setState(data.tester || {});\n//             this.source = data.source || 'pressed-keys';\n//             if (data.currentLayout) {\n//                 const layout = this.tester.candidates.find(c => getLayoutId(c) === data.currentLayout);\n//                 if (layout) {\n//                     this.currentLayout = layout;\n//                 }\n//             } else {\n//                 this.currentLayout = DEFAULT_LAYOUT_DATA;\n//             }\n//         }\n//     }\n//\n// }\n//\n// export interface KeyboardLayoutData {\n//     name: string;\n//     hardware: 'pc' | 'mac';\n//     language: string;\n//     raw: NativeKeyboardLayout;\n// }\n//\n// function osMatches(hardware: 'pc' | 'mac'): boolean {\n//     return isOSX ? hardware === 'mac' : hardware === 'pc';\n// }\n//\n// /**\n//  * This is the fallback keyboard layout selected when nothing else matches.\n//  * It has an empty mapping, so user inputs are handled like with a standard US keyboard.\n//  */\n// export const DEFAULT_LAYOUT_DATA: KeyboardLayoutData = {\n//     name: 'US',\n//     hardware: isOSX ? 'mac' : 'pc',\n//     language: 'en',\n//     raw: {\n//         // eslint-disable-next-line @typescript-eslint/no-explicit-any\n//         info: {} as any,\n//         mapping: {}\n//     }\n// };\n//\n// export interface LayoutProviderState {\n//     tester?: KeyboardTesterState;\n//     source?: KeyboardLayoutSource;\n//     currentLayout?: string;\n// }\n//\n// export interface KeyboardTesterState {\n//     scores?: { [id: string]: number };\n//     topScore?: number;\n//     testedInputs?: { [key: string]: string }\n// }\n//\n// /**\n//  * Holds score values for all known keyboard layouts. Scores are updated\n//  * by comparing key codes with the corresponding character produced by\n//  * the user's keyboard.\n//  */\n// export class KeyboardTester {\n//\n//     readonly scores: number[];\n//     topScore: number = 0;\n//\n//     private readonly testedInputs = new Map<string, string>();\n//\n//     get inputCount(): number {\n//         return this.testedInputs.size;\n//     }\n//\n//     constructor(readonly candidates: KeyboardLayoutData[]) {\n//         this.scores = this.candidates.map(() => 0);\n//     }\n//\n//     reset(): void {\n//         for (let i = 0; i < this.scores.length; i++) {\n//             this.scores[i] = 0;\n//         }\n//         this.topScore = 0;\n//         this.testedInputs.clear();\n//     }\n//\n//     updateScores(input: KeyValidationInput): boolean {\n//         let property: 'value' | 'withShift' | 'withAltGr' | 'withShiftAltGr';\n//         if (input.shiftKey && input.altKey) {\n//             property = 'withShiftAltGr';\n//         } else if (input.shiftKey) {\n//             property = 'withShift';\n//         } else if (input.altKey) {\n//             property = 'withAltGr';\n//         } else {\n//             property = 'value';\n//         }\n//         const inputKey = `${input.code}.${property}`;\n//         if (this.testedInputs.has(inputKey)) {\n//             if (this.testedInputs.get(inputKey) === input.character) {\n//                 return false;\n//             } else {\n//                 // The same input keystroke leads to a different character:\n//                 // probably a keyboard layout change, so forget all previous scores\n//                 this.reset();\n//             }\n//         }\n//\n//         const scores = this.scores;\n//         for (let i = 0; i < this.candidates.length; i++) {\n//             scores[i] += this.testCandidate(this.candidates[i], input, property);\n//             if (scores[i] > this.topScore) {\n//                 this.topScore = scores[i];\n//             }\n//         }\n//         this.testedInputs.set(inputKey, input.character);\n//         return true;\n//     }\n//\n//     protected testCandidate(candidate: KeyboardLayoutData, input: KeyValidationInput,\n//                             property: 'value' | 'withShift' | 'withAltGr' | 'withShiftAltGr'): number {\n//         const keyMapping = candidate.raw.mapping[input.code];\n//         if (keyMapping && keyMapping[property]) {\n//             return keyMapping[property] === input.character ? 1 : 0;\n//         } else {\n//             return 0;\n//         }\n//     }\n//\n//     getState(): KeyboardTesterState {\n//         const scores: { [id: string]: number } = {};\n//         for (let i = 0; i < this.scores.length; i++) {\n//             scores[getLayoutId(this.candidates[i])] = this.scores[i];\n//         }\n//         const testedInputs: { [key: string]: string } = {};\n//         for (const [key, character] of this.testedInputs.entries()) {\n//             testedInputs[key] = character;\n//         }\n//         return {\n//             scores,\n//             topScore: this.topScore,\n//             testedInputs\n//         };\n//     }\n//\n//     setState(state: KeyboardTesterState): void {\n//         this.reset();\n//         if (state.scores) {\n//             const layoutIds = this.candidates.map(getLayoutId);\n//             for (const id in state.scores) {\n//                 if (state.scores.hasOwnProperty(id)) {\n//                     const index = layoutIds.indexOf(id);\n//                     if (index > 0) {\n//                         this.scores[index] = state.scores[id];\n//                     }\n//                 }\n//             }\n//         }\n//         if (state.topScore) {\n//             this.topScore = state.topScore;\n//         }\n//         if (state.testedInputs) {\n//             for (const key in state.testedInputs) {\n//                 if (state.testedInputs.hasOwnProperty(key)) {\n//                     this.testedInputs.set(key, state.testedInputs[key]);\n//                 }\n//             }\n//         }\n//     }\n//\n// }\n//\n// /**\n//  * API specified by https://wicg.github.io/keyboard-map/\n//  */\n// interface NavigatorExtension extends Navigator {\n//     keyboard: Keyboard;\n// }\n//\n// interface Keyboard {\n//     getLayoutMap(): Promise<KeyboardLayoutMap>;\n//\n//     addEventListener(type: 'layoutchange', listener: EventListenerOrEventListenerObject): void;\n// }\n//\n// type KeyboardLayoutMap = Map<string, string>;\n//\n// function getLayoutId(layout: KeyboardLayoutData): string {\n//     return `${layout.language}-${layout.name.replace(' ', '_')}-${layout.hardware}`;\n// }\n//\n// /**\n//  * Keyboard layout files are expected to have the following name scheme:\n//  *     `language-name-hardware.json`\n//  *\n//  * - `language`: A language subtag according to IETF BCP 47\n//  * - `name`:     Display name of the keyboard layout (without dashes)\n//  * - `hardware`: `pc` or `mac`\n//  */\n// // function loadLayout(fileName: string): KeyboardLayoutData {\n// //     const [language, name, hardware] = fileName.split('-');\n// //     return {\n// //         name: name.replace('_', ' '),\n// //         hardware: hardware as 'pc' | 'mac',\n// //         language,\n// //         // Webpack knows what to do here and it should bundle all files under `../../../src/common/keyboard/layouts/`\n// //         // eslint-disable-next-line import/no-dynamic-require\n// //         raw: require('../../../src/common/keyboard/layouts/' + fileName + '.json')\n// //     };\n// // }\n//\n// function loadAllLayouts(): KeyboardLayoutData[] {\n//     // The order of keyboard layouts is relevant for autodetection. Layouts with\n//     // lower index have a higher chance of being selected.\n//     // The current ordering approach is to sort by estimated number of developers\n//     // in the respective country (taken from the Stack Overflow Developer Survey),\n//     // but keeping all layouts of the same language together.\n//     return [];\n// }\n"]}