{"version":3,"sources":["browser/keyboard/browser-keyboard-layout-provider.ts"],"names":[],"mappings":"","file":"../../../src/browser/keyboard/browser-keyboard-layout-provider.d.ts","sourcesContent":["// /********************************************************************************\n//  * Copyright (C) 2019 TypeFox and others.\n//  *\n//  * This program and the accompanying materials are made available under the\n//  * terms of the Eclipse Public License v. 2.0 which is available at\n//  * http://www.eclipse.org/legal/epl-2.0.\n//  *\n//  * This Source Code may also be made available under the following Secondary\n//  * Licenses when the conditions for such availability set forth in the Eclipse\n//  * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n//  * with the GNU Classpath Exception which is available at\n//  * https://www.gnu.org/software/classpath/license.html.\n//  *\n//  * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n//  ********************************************************************************/\n//\n// import {injectable, postConstruct, inject} from 'inversify';\n// import {isOSX} from '../../common/os';\n// import {Emitter, Event} from '../../common';\n// // import {ILogger} from '../../common/logger';\n// import {Deferred} from '../../common/promise-util';\n// import {\n//     NativeKeyboardLayout, KeyboardLayoutProvider, KeyboardLayoutChangeNotifier, KeyValidator, KeyValidationInput\n// } from '../../common/keyboard/keyboard-layout-provider';\n// import {LocalStorageService} from '../storage-service';\n//\n// export type KeyboardLayoutSource = 'navigator.keyboard' | 'user-choice' | 'pressed-keys';\n//\n// @injectable()\n// export class BrowserKeyboardLayoutProvider implements KeyboardLayoutProvider, KeyboardLayoutChangeNotifier, KeyValidator {\n//\n//     // @inject(ILogger)\n//     // protected readonly logger: ILogger;\n//\n//     @inject(LocalStorageService)\n//     protected readonly storageService: LocalStorageService;\n//\n//     protected readonly initialized = new Deferred();\n//     protected readonly nativeLayoutChanged = new Emitter<NativeKeyboardLayout>();\n//\n//     get onDidChangeNativeLayout(): Event<NativeKeyboardLayout> {\n//         return this.nativeLayoutChanged.event;\n//     }\n//\n//     protected readonly tester = new KeyboardTester(loadAllLayouts());\n//     protected source: KeyboardLayoutSource = 'pressed-keys';\n//     protected currentLayout: KeyboardLayoutData = DEFAULT_LAYOUT_DATA;\n//\n//     get allLayoutData(): KeyboardLayoutData[] {\n//         return this.tester.candidates.slice();\n//     }\n//\n//     get currentLayoutData(): KeyboardLayoutData {\n//         return this.currentLayout;\n//     }\n//\n//     get currentLayoutSource(): KeyboardLayoutSource {\n//         return this.source;\n//     }\n//\n//     @postConstruct()\n//     protected async initialize(): Promise<void> {\n//         await this.loadState();\n//         const keyboard = (navigator as NavigatorExtension).keyboard;\n//         if (keyboard && keyboard.addEventListener) {\n//             keyboard.addEventListener('layoutchange', async () => {\n//                 const newLayout = await this.getNativeLayout();\n//                 this.nativeLayoutChanged.fire(newLayout);\n//             });\n//         }\n//         this.initialized.resolve();\n//     }\n//\n//     async getNativeLayout(): Promise<NativeKeyboardLayout> {\n//         await this.initialized.promise;\n//         if (this.source === 'user-choice') {\n//             return this.currentLayout.raw;\n//         }\n//         const [layout, source] = await this.autodetect();\n//         this.setCurrent(layout, source);\n//         return layout.raw;\n//     }\n//\n//     /**\n//      * Set user-chosen keyboard layout data.\n//      */\n//     async setLayoutData(layout: KeyboardLayoutData | 'autodetect'): Promise<KeyboardLayoutData> {\n//         if (layout === 'autodetect') {\n//             if (this.source === 'user-choice') {\n//                 const [newLayout, source] = await this.autodetect();\n//                 this.setCurrent(newLayout, source);\n//                 this.nativeLayoutChanged.fire(newLayout.raw);\n//                 return newLayout;\n//             }\n//             return this.currentLayout;\n//         } else {\n//             if (this.source !== 'user-choice' || layout !== this.currentLayout) {\n//                 this.setCurrent(layout, 'user-choice');\n//                 this.nativeLayoutChanged.fire(layout.raw);\n//             }\n//             return layout;\n//         }\n//     }\n//\n//     /**\n//      * Test all known keyboard layouts with the given combination of pressed key and\n//      * produced character. Matching layouts have their score increased (see class\n//      * KeyboardTester). If this leads to a change of the top-scoring layout, a layout\n//      * change event is fired.\n//      */\n//     validateKey(keyCode: KeyValidationInput): void {\n//         if (this.source !== 'pressed-keys') {\n//             return;\n//         }\n//         const accepted = this.tester.updateScores(keyCode);\n//         if (!accepted) {\n//             return;\n//         }\n//         const layout = this.selectLayout();\n//         if (layout !== this.currentLayout && layout !== DEFAULT_LAYOUT_DATA) {\n//             this.setCurrent(layout, 'pressed-keys');\n//             this.nativeLayoutChanged.fire(layout.raw);\n//         }\n//     }\n//\n//     protected setCurrent(layout: KeyboardLayoutData, source: KeyboardLayoutSource): void {\n//         this.currentLayout = layout;\n//         this.source = source;\n//         this.saveState();\n//         if (this.tester.inputCount && (source === 'pressed-keys' || source === 'navigator.keyboard')) {\n//             const from = source === 'pressed-keys' ? 'pressed keys' : 'browser API';\n//             const hardware = layout.hardware === 'mac' ? 'Mac' : 'PC';\n//             // this.logger.info(`Detected keyboard layout from ${from}: ${layout.name} (${hardware})`);\n//         }\n//     }\n//\n//     protected async autodetect(): Promise<[KeyboardLayoutData, KeyboardLayoutSource]> {\n//         const keyboard = (navigator as NavigatorExtension).keyboard;\n//         if (keyboard && keyboard.getLayoutMap) {\n//             try {\n//                 const layoutMap = await keyboard.getLayoutMap();\n//                 this.testLayoutMap(layoutMap);\n//                 return [this.selectLayout(), 'navigator.keyboard'];\n//             } catch (error) {\n//                 // this.logger.warn('Failed to obtain keyboard layout map.', error);\n//             }\n//         }\n//         return [this.selectLayout(), 'pressed-keys'];\n//     }\n//\n//     /**\n//      * @param layoutMap a keyboard layout map according to https://wicg.github.io/keyboard-map/\n//      */\n//     protected testLayoutMap(layoutMap: KeyboardLayoutMap): void {\n//         this.tester.reset();\n//         for (const [code, key] of layoutMap.entries()) {\n//             this.tester.updateScores({code, character: key});\n//         }\n//     }\n//\n//     /**\n//      * Select a layout based on the current tester state and the operating system\n//      * and language detected from the browser.\n//      */\n//     protected selectLayout(): KeyboardLayoutData {\n//         const candidates = this.tester.candidates;\n//         const scores = this.tester.scores;\n//         const topScore = this.tester.topScore;\n//         const language = navigator.language;\n//         let matchingOScount = 0;\n//         let topScoringCount = 0;\n//         for (let i = 0; i < candidates.length; i++) {\n//             if (scores[i] === topScore) {\n//                 const candidate = candidates[i];\n//                 if (osMatches(candidate.hardware)) {\n//                     if (language && language.startsWith(candidate.language)) {\n//                         return candidate;\n//                     }\n//                     matchingOScount++;\n//                 }\n//                 topScoringCount++;\n//             }\n//         }\n//         if (matchingOScount >= 1) {\n//             return candidates.find((c, i) => scores[i] === topScore && osMatches(c.hardware))!;\n//         }\n//         if (topScoringCount >= 1) {\n//             return candidates.find((_, i) => scores[i] === topScore)!;\n//         }\n//         return DEFAULT_LAYOUT_DATA;\n//     }\n//\n//     protected saveState(): Promise<void> {\n//         const data: LayoutProviderState = {\n//             tester: this.tester.getState(),\n//             source: this.source,\n//             currentLayout: this.currentLayout !== DEFAULT_LAYOUT_DATA ? getLayoutId(this.currentLayout) : undefined\n//         };\n//         return this.storageService.setData('keyboard', data);\n//     }\n//\n//     protected async loadState(): Promise<void> {\n//         const data = await this.storageService.getData<LayoutProviderState>('keyboard');\n//         if (data) {\n//             this.tester.setState(data.tester || {});\n//             this.source = data.source || 'pressed-keys';\n//             if (data.currentLayout) {\n//                 const layout = this.tester.candidates.find(c => getLayoutId(c) === data.currentLayout);\n//                 if (layout) {\n//                     this.currentLayout = layout;\n//                 }\n//             } else {\n//                 this.currentLayout = DEFAULT_LAYOUT_DATA;\n//             }\n//         }\n//     }\n//\n// }\n//\n// export interface KeyboardLayoutData {\n//     name: string;\n//     hardware: 'pc' | 'mac';\n//     language: string;\n//     raw: NativeKeyboardLayout;\n// }\n//\n// function osMatches(hardware: 'pc' | 'mac'): boolean {\n//     return isOSX ? hardware === 'mac' : hardware === 'pc';\n// }\n//\n// /**\n//  * This is the fallback keyboard layout selected when nothing else matches.\n//  * It has an empty mapping, so user inputs are handled like with a standard US keyboard.\n//  */\n// export const DEFAULT_LAYOUT_DATA: KeyboardLayoutData = {\n//     name: 'US',\n//     hardware: isOSX ? 'mac' : 'pc',\n//     language: 'en',\n//     raw: {\n//         // eslint-disable-next-line @typescript-eslint/no-explicit-any\n//         info: {} as any,\n//         mapping: {}\n//     }\n// };\n//\n// export interface LayoutProviderState {\n//     tester?: KeyboardTesterState;\n//     source?: KeyboardLayoutSource;\n//     currentLayout?: string;\n// }\n//\n// export interface KeyboardTesterState {\n//     scores?: { [id: string]: number };\n//     topScore?: number;\n//     testedInputs?: { [key: string]: string }\n// }\n//\n// /**\n//  * Holds score values for all known keyboard layouts. Scores are updated\n//  * by comparing key codes with the corresponding character produced by\n//  * the user's keyboard.\n//  */\n// export class KeyboardTester {\n//\n//     readonly scores: number[];\n//     topScore: number = 0;\n//\n//     private readonly testedInputs = new Map<string, string>();\n//\n//     get inputCount(): number {\n//         return this.testedInputs.size;\n//     }\n//\n//     constructor(readonly candidates: KeyboardLayoutData[]) {\n//         this.scores = this.candidates.map(() => 0);\n//     }\n//\n//     reset(): void {\n//         for (let i = 0; i < this.scores.length; i++) {\n//             this.scores[i] = 0;\n//         }\n//         this.topScore = 0;\n//         this.testedInputs.clear();\n//     }\n//\n//     updateScores(input: KeyValidationInput): boolean {\n//         let property: 'value' | 'withShift' | 'withAltGr' | 'withShiftAltGr';\n//         if (input.shiftKey && input.altKey) {\n//             property = 'withShiftAltGr';\n//         } else if (input.shiftKey) {\n//             property = 'withShift';\n//         } else if (input.altKey) {\n//             property = 'withAltGr';\n//         } else {\n//             property = 'value';\n//         }\n//         const inputKey = `${input.code}.${property}`;\n//         if (this.testedInputs.has(inputKey)) {\n//             if (this.testedInputs.get(inputKey) === input.character) {\n//                 return false;\n//             } else {\n//                 // The same input keystroke leads to a different character:\n//                 // probably a keyboard layout change, so forget all previous scores\n//                 this.reset();\n//             }\n//         }\n//\n//         const scores = this.scores;\n//         for (let i = 0; i < this.candidates.length; i++) {\n//             scores[i] += this.testCandidate(this.candidates[i], input, property);\n//             if (scores[i] > this.topScore) {\n//                 this.topScore = scores[i];\n//             }\n//         }\n//         this.testedInputs.set(inputKey, input.character);\n//         return true;\n//     }\n//\n//     protected testCandidate(candidate: KeyboardLayoutData, input: KeyValidationInput,\n//                             property: 'value' | 'withShift' | 'withAltGr' | 'withShiftAltGr'): number {\n//         const keyMapping = candidate.raw.mapping[input.code];\n//         if (keyMapping && keyMapping[property]) {\n//             return keyMapping[property] === input.character ? 1 : 0;\n//         } else {\n//             return 0;\n//         }\n//     }\n//\n//     getState(): KeyboardTesterState {\n//         const scores: { [id: string]: number } = {};\n//         for (let i = 0; i < this.scores.length; i++) {\n//             scores[getLayoutId(this.candidates[i])] = this.scores[i];\n//         }\n//         const testedInputs: { [key: string]: string } = {};\n//         for (const [key, character] of this.testedInputs.entries()) {\n//             testedInputs[key] = character;\n//         }\n//         return {\n//             scores,\n//             topScore: this.topScore,\n//             testedInputs\n//         };\n//     }\n//\n//     setState(state: KeyboardTesterState): void {\n//         this.reset();\n//         if (state.scores) {\n//             const layoutIds = this.candidates.map(getLayoutId);\n//             for (const id in state.scores) {\n//                 if (state.scores.hasOwnProperty(id)) {\n//                     const index = layoutIds.indexOf(id);\n//                     if (index > 0) {\n//                         this.scores[index] = state.scores[id];\n//                     }\n//                 }\n//             }\n//         }\n//         if (state.topScore) {\n//             this.topScore = state.topScore;\n//         }\n//         if (state.testedInputs) {\n//             for (const key in state.testedInputs) {\n//                 if (state.testedInputs.hasOwnProperty(key)) {\n//                     this.testedInputs.set(key, state.testedInputs[key]);\n//                 }\n//             }\n//         }\n//     }\n//\n// }\n//\n// /**\n//  * API specified by https://wicg.github.io/keyboard-map/\n//  */\n// interface NavigatorExtension extends Navigator {\n//     keyboard: Keyboard;\n// }\n//\n// interface Keyboard {\n//     getLayoutMap(): Promise<KeyboardLayoutMap>;\n//\n//     addEventListener(type: 'layoutchange', listener: EventListenerOrEventListenerObject): void;\n// }\n//\n// type KeyboardLayoutMap = Map<string, string>;\n//\n// function getLayoutId(layout: KeyboardLayoutData): string {\n//     return `${layout.language}-${layout.name.replace(' ', '_')}-${layout.hardware}`;\n// }\n//\n// /**\n//  * Keyboard layout files are expected to have the following name scheme:\n//  *     `language-name-hardware.json`\n//  *\n//  * - `language`: A language subtag according to IETF BCP 47\n//  * - `name`:     Display name of the keyboard layout (without dashes)\n//  * - `hardware`: `pc` or `mac`\n//  */\n// // function loadLayout(fileName: string): KeyboardLayoutData {\n// //     const [language, name, hardware] = fileName.split('-');\n// //     return {\n// //         name: name.replace('_', ' '),\n// //         hardware: hardware as 'pc' | 'mac',\n// //         language,\n// //         // Webpack knows what to do here and it should bundle all files under `../../../src/common/keyboard/layouts/`\n// //         // eslint-disable-next-line import/no-dynamic-require\n// //         raw: require('../../../src/common/keyboard/layouts/' + fileName + '.json')\n// //     };\n// // }\n//\n// function loadAllLayouts(): KeyboardLayoutData[] {\n//     // The order of keyboard layouts is relevant for autodetection. Layouts with\n//     // lower index have a higher chance of being selected.\n//     // The current ordering approach is to sort by estimated number of developers\n//     // in the respective country (taken from the Stack Overflow Developer Survey),\n//     // but keeping all layouts of the same language together.\n//     return [];\n// }\n"]}