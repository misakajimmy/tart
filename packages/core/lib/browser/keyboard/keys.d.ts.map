{"version":3,"sources":["browser/keyboard/keys.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAIlF,oBAAY,WAAW,GAAG,OAAO,EAAE,CAAC;AACpC,yBAAiB,WAAW,CAAC;IAE3B,SAAgB,MAAM,CAAC,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,WAAW,GAAG,OAAO,CAW9D;IAED,KAAY,aAAa;QACvB,IAAI,IAAI;QACR,OAAO,IAAA;QACP,MAAM,IAAA;QACN,IAAI,IAAA;KACL;IAQD,SAAgB,OAAO,CAAC,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,WAAW,GAAG,aAAa,CAwBrE;IAED,SAAgB,KAAK,CAAC,UAAU,EAAE,MAAM,GAAG,WAAW,CAUrD;CACF;AAED;;;;;GAKG;AACH,MAAM,WAAW,SAAS;IACxB,QAAQ,CAAC,KAAK,CAAC,EAAE,GAAG,CAAC;IACrB,QAAQ,CAAC,SAAS,CAAC,EAAE,WAAW,EAAE,CAAC;CACpC;AAED,MAAM,WAAW,aAAa;IAC5B,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;IACnB,IAAI,CAAC,EAAE,OAAO,CAAC;IACf,KAAK,CAAC,EAAE,OAAO,CAAC;IAChB,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,IAAI,CAAC,EAAE,OAAO,CAAC;IACf,SAAS,CAAC,EAAE,MAAM,CAAC;CACpB;AAED;;GAEG;AACH,qBAAa,OAAO;IAElB,OAAO,CAAC,MAAM,CAAC,WAAW,CAAkC;IAC5D,SAAgB,GAAG,EAAE,GAAG,GAAG,SAAS,CAAC;IACrC,SAAgB,IAAI,EAAE,OAAO,CAAC;IAC9B,SAAgB,KAAK,EAAE,OAAO,CAAC;IAC/B,SAAgB,GAAG,EAAE,OAAO,CAAC;IAC7B,SAAgB,IAAI,EAAE,OAAO,CAAC;IAC9B,SAAgB,SAAS,EAAE,MAAM,GAAG,SAAS,CAAC;gBAE3B,MAAM,EAAE,aAAa;IAkBxC;;OAEG;WACW,aAAa,CAAC,KAAK,EAAE,aAAa,GAAG,SAAS,GAAG,aAAa,GAAG,MAAM,EAAE,aAAa,GAAE,MAAM,GAAG,SAAkB,GAAG,OAAO;WA2C7H,gBAAgB,IAAI,IAAI;IAItC;;;OAGG;WACW,KAAK,CAAC,UAAU,EAAE,MAAM,GAAG,OAAO;IAiEhD;;OAEG;IACI,cAAc,IAAI,OAAO;IAIhC;;OAEG;IACH,MAAM,CAAC,KAAK,EAAE,OAAO,GAAG,OAAO;IAU/B,QAAQ,IAAI,MAAM;CAoBnB;AAED,yBAAiB,OAAO,CAAC;IAEvB;;OAEG;IACH,KAAY,SAAS,GAAG,CAAC,OAAO,EAAE,OAAO,KAAK,OAAO,CAAC;IAKtD,SAAgB,gBAAgB,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAKrD;IAED;;;;;;;;OAQG;IACH,SAAgB,eAAe,CAAC,KAAK,EAAE,MAAM,GAAG;QAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,CAAA;KAAE,GAAG,KAAK,IAAI,aAAa,CAYlG;IAED;;;;;;OAMG;IACH,SAAgB,KAAK,CAAC,KAAK,EAAE,aAAa,EAAE,QAAQ,GAAE,MAAM,GAAG,SAAkB,GAAG,GAAG,CA4CtF;IAED;;;;OAIG;IACH,SAAgB,WAAW,CAAC,KAAK,EAAE,aAAa,GAAG,MAAM,GAAG,SAAS,CAYpE;CAEF;AAED,oBAAY,WAAW;IACrB;;OAEG;IACH,OAAO,OAAO;IACd;;OAEG;IACH,KAAK,OAAO;IACZ;;OAEG;IACH,GAAG,OAAO;IACV;;OAEG;IACH,OAAO,OAAO;CACf;AAED,yBAAiB,WAAW,CAAC;IAC3B;;;OAGG;IACI,MAAM,IAAI,EAAE,WAAW,CAAC,OAAO,GAAG,WAAW,CAAC,OAA2D,CAAC;IACjH;;OAEG;IACI,MAAM,KAAK,EAAE,WAAW,CAAC,KAAyB,CAAC;IAE1D;;OAEG;IACH,SAAgB,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,GAAG,OAAO,CAa3D;CACF;AAED,MAAM,WAAW,GAAG;IAClB,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC;IACzB,QAAQ,CAAC,UAAU,EAAE,MAAM,CAAC;CAC7B;AAmBD,yBAAiB,YAAY,CAAC;IACrB,MAAM,IAAI,SAAS,CAAC;IACpB,MAAM,OAAO,YAAY,CAAC;CAClC;AAED,yBAAiB,GAAG,CAAC;IAGnB,SAAgB,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,IAAI,GAAG,CAE1C;IAED,SAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,GAAG,GAAG,SAAS,CAM5D;IAED,SAAgB,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,GAAG,OAAO,CAKxD;IAED,SAAgB,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,GAAG,OAAO,CAE1D;IAEM,MAAM,SAAS,EAAE,GAA8D,CAAC;IAChF,MAAM,GAAG,EAAE,GAAkD,CAAC;IAC9D,MAAM,KAAK,EAAE,GAAuD,CAAC;IACrE,MAAM,MAAM,EAAE,GAAyD,CAAC;IACxE,MAAM,KAAK,EAAE,GAAuD,CAAC;IACrE,MAAM,OAAO,EAAE,GAAyD,CAAC;IACzE,MAAM,SAAS,EAAE,GAA6D,CAAC;IAC/E,MAAM,GAAG,EAAE,GAAmD,CAAC;IAC/D,MAAM,IAAI,EAAE,GAAqD,CAAC;IAClE,MAAM,UAAU,EAAE,GAA0D,CAAC;IAC7E,MAAM,QAAQ,EAAE,GAAsD,CAAC;IACvE,MAAM,WAAW,EAAE,GAA4D,CAAC;IAChF,MAAM,UAAU,EAAE,GAA0D,CAAC;IAC7E,MAAM,MAAM,EAAE,GAAyD,CAAC;IACxE,MAAM,MAAM,EAAE,GAAyD,CAAC;IAExE,MAAM,UAAU,EAAE,GAA2D,CAAC;IAC9E,MAAM,WAAW,EAAE,GAA4D,CAAC;IAChF,MAAM,YAAY,EAAE,GAA4D,CAAC;IACjF,MAAM,aAAa,EAAE,GAA6D,CAAC;IACnF,MAAM,QAAQ,EAAE,GAAuD,CAAC;IACxE,MAAM,SAAS,EAAE,GAAwD,CAAC;IAC1E,MAAM,SAAS,EAAE,GAA6D,CAAC;IAC/E,MAAM,OAAO,EAAE,GAAwD,CAAC;IACxE,MAAM,QAAQ,EAAE,GAAyD,CAAC;IAE1E,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IACnE,MAAM,MAAM,EAAE,GAAoD,CAAC;IAEnE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAChE,MAAM,KAAK,EAAE,GAAkD,CAAC;IAEhE,MAAM,QAAQ,EAAE,GAAoE,CAAC;IACrF,MAAM,GAAG,EAAE,GAA0D,CAAC;IACtE,MAAM,OAAO,EAAE,GAAkE,CAAC;IAClF,MAAM,QAAQ,EAAE,GAAoE,CAAC;IACrF,MAAM,MAAM,EAAE,GAAgE,CAAC;IAE/E,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,EAAE,EAAE,GAAkD,CAAC;IAC7D,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAChE,MAAM,GAAG,EAAE,GAAoD,CAAC;IAEhE,MAAM,QAAQ,EAAE,GAA4D,CAAC;IAC7E,MAAM,SAAS,EAAE,GAAwD,CAAC;IAC1E,MAAM,KAAK,EAAE,GAAoD,CAAC;IAClE,MAAM,KAAK,EAAE,GAAoD,CAAC;IAClE,MAAM,KAAK,EAAE,GAAoD,CAAC;IAClE,MAAM,MAAM,EAAE,GAAqD,CAAC;IACpE,MAAM,KAAK,EAAE,GAAoD,CAAC;IAClE,MAAM,SAAS,EAAE,GAAwD,CAAC;IAC1E,MAAM,OAAO,EAAE,GAA0D,CAAC;IAC1E,MAAM,YAAY,EAAE,GAA0D,CAAC;IAC/E,MAAM,SAAS,EAAE,GAAyD,CAAC;IAC3E,MAAM,aAAa,EAAE,GAA2D,CAAC;IACjF,MAAM,KAAK,EAAE,GAAqD,CAAC;IACnE,MAAM,cAAc,EAAE,GAAwE,CAAC;IAC/F,MAAM,QAAQ,EAAE,GAA4D,CAAC;IAE7E,MAAM,YAAY,QAAmB,CAAC;CAE9C;AAkDD,oBAAY,cAAc,GAAG,GAAG,GAAG,OAAO,GAAG,CAAC,GAAG,GAAG,OAAO,CAAC,EAAE,CAAC;AAC/D,yBAAiB,cAAc,CAAC;IAEvB,MAAM,SAAS,iBAAkB,GAAG,GAAG,OAAO,YAC4C,CAAC;IAE3F,MAAM,UAAU,mBAAoB,cAAc,cAOxD,CAAC;CAEH","file":"../../../src/browser/keyboard/keys.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017-2019 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {isOSX} from '../../common/os';\n\nexport type KeySequence = KeyCode[];\nexport namespace KeySequence {\n\n  export function equals(a: KeySequence, b: KeySequence): boolean {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!a[i].equals(b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  export enum CompareResult {\n    NONE = 0,\n    PARTIAL,\n    SHADOW,\n    FULL\n  }\n\n  /* Compares two KeySequences, returns:\n   * FULL if the KeySequences are the same.\n   * PARTIAL if the KeySequence a part of b.\n   * SHADOW if the KeySequence b part of a.\n   * NONE if the KeySequences are not the same at all.\n   */\n  export function compare(a: KeySequence, b: KeySequence): CompareResult {\n    let first = a;\n    let second = b;\n    let shadow = false;\n\n    if (b.length < a.length) {\n      first = b;\n      second = a;\n      shadow = true;\n    }\n\n    for (let i = 0; i < first.length; i++) {\n      if (first[i].equals(second[i]) === false) {\n        return KeySequence.CompareResult.NONE;\n      }\n    }\n    if (first.length < second.length) {\n      if (shadow === false) {\n        return KeySequence.CompareResult.PARTIAL;\n      } else {\n        return KeySequence.CompareResult.SHADOW;\n      }\n    }\n    return KeySequence.CompareResult.FULL;\n  }\n\n  export function parse(keybinding: string): KeySequence {\n    const keyCodes = [];\n    const rawKeyCodes = keybinding.trim().split(/\\s+/g);\n    for (const rawKeyCode of rawKeyCodes) {\n      const keyCode = KeyCode.parse(rawKeyCode);\n      if (keyCode !== undefined) {\n        keyCodes.push(keyCode);\n      }\n    }\n    return keyCodes;\n  }\n}\n\n/**\n * The key sequence for this binding. This key sequence should consist of one or more key strokes. Key strokes\n * consist of one or more keys held down at the same time. This should be zero or more modifier keys, and zero or one other key.\n * Since `M2+M3+<Key>` (Alt+Shift+<Key>) is reserved on MacOS X for writing special characters, such bindings are commonly\n * undefined for platform MacOS X and redefined as `M1+M3+<Key>`. The rule applies on the `M3+M2+<Key>` sequence.\n */\nexport interface Keystroke {\n  readonly first?: Key;\n  readonly modifiers?: KeyModifier[];\n}\n\nexport interface KeyCodeSchema {\n  key?: Partial<Key>;\n  ctrl?: boolean;\n  shift?: boolean;\n  alt?: boolean;\n  meta?: boolean;\n  character?: string;\n}\n\n/**\n * Representation of a pressed key combined with key modifiers.\n */\nexport class KeyCode {\n\n  private static keybindings: { [key: string]: KeyCode } = {};\n  public readonly key: Key | undefined;\n  public readonly ctrl: boolean;\n  public readonly shift: boolean;\n  public readonly alt: boolean;\n  public readonly meta: boolean;\n  public readonly character: string | undefined;\n\n  public constructor(schema: KeyCodeSchema) {\n    const key = schema.key;\n    if (key) {\n      if (key.code && key.keyCode && key.easyString) {\n        this.key = key as Key;\n      } else if (key.code) {\n        this.key = Key.getKey(key.code);\n      } else if (key.keyCode) {\n        this.key = Key.getKey(key.keyCode);\n      }\n    }\n    this.ctrl = !!schema.ctrl;\n    this.shift = !!schema.shift;\n    this.alt = !!schema.alt;\n    this.meta = !!schema.meta;\n    this.character = schema.character;\n  }\n\n  /**\n   * Create a KeyCode from one of several input types.\n   */\n  public static createKeyCode(input: KeyboardEvent | Keystroke | KeyCodeSchema | string, eventDispatch: 'code' | 'keyCode' = 'code'): KeyCode {\n    if (typeof input === 'string') {\n      const parts = input.split('+');\n      if (!KeyCode.isModifierString(parts[0])) {\n        return KeyCode.createKeyCode({\n          first: Key.getKey(parts[0]),\n          modifiers: parts.slice(1) as KeyModifier[]\n        });\n      }\n      return KeyCode.createKeyCode({modifiers: parts as KeyModifier[]});\n    } else if (KeyCode.isKeyboardEvent(input)) {\n      const key = KeyCode.toKey(input, eventDispatch);\n      return new KeyCode({\n        key: Key.isModifier(key.code) ? undefined : key,\n        meta: isOSX && input.metaKey,\n        shift: input.shiftKey,\n        alt: input.altKey,\n        ctrl: input.ctrlKey,\n        character: KeyCode.toCharacter(input)\n      });\n    } else if ((input as Keystroke).first || (input as Keystroke).modifiers) {\n      const keystroke = input as Keystroke;\n      const schema: KeyCodeSchema = {\n        key: keystroke.first\n      };\n      if (keystroke.modifiers) {\n        if (isOSX) {\n          schema.meta = keystroke.modifiers.some(mod => mod === KeyModifier.CtrlCmd);\n          schema.ctrl = keystroke.modifiers.some(mod => mod === KeyModifier.MacCtrl);\n        } else {\n          schema.meta = false;\n          schema.ctrl = keystroke.modifiers.some(mod => mod === KeyModifier.CtrlCmd);\n        }\n        schema.shift = keystroke.modifiers.some(mod => mod === KeyModifier.Shift);\n        schema.alt = keystroke.modifiers.some(mod => mod === KeyModifier.Alt);\n      }\n      return new KeyCode(schema);\n    } else {\n      return new KeyCode(input as KeyCodeSchema);\n    }\n  }\n\n  /* Reset the key hashmap, this is for testing purposes.  */\n  public static resetKeyBindings(): void {\n    KeyCode.keybindings = {};\n  }\n\n  /**\n   * Parses a string and returns a KeyCode object.\n   * @param keybinding String representation of a keybinding\n   */\n  public static parse(keybinding: string): KeyCode {\n    if (KeyCode.keybindings[keybinding]) {\n      return KeyCode.keybindings[keybinding];\n    }\n\n    const schema: KeyCodeSchema = {};\n    const keys = [];\n    let currentKey = '';\n    for (const character of keybinding.trim().toLowerCase()) {\n      if (currentKey && (character === '-' || character === '+')) {\n        keys.push(currentKey);\n        currentKey = '';\n      } else if (character !== '+') {\n        currentKey += character;\n      }\n    }\n    if (currentKey) {\n      keys.push(currentKey);\n    }\n    /* If duplicates i.e ctrl+ctrl+a or alt+alt+b or b+alt+b it is invalid */\n    if (keys.length !== new Set(keys).size) {\n      throw new Error(`Can't parse keybinding ${keybinding} Duplicate modifiers`);\n    }\n\n    for (let keyString of keys) {\n      if (SPECIAL_ALIASES[keyString] !== undefined) {\n        keyString = SPECIAL_ALIASES[keyString];\n      }\n      const key = EASY_TO_KEY[keyString];\n\n      /* meta only works on macOS */\n      if (keyString === SpecialCases.META) {\n        if (isOSX) {\n          schema.meta = true;\n        } else {\n          throw new Error(`Can't parse keybinding ${keybinding} meta is for OSX only`);\n        }\n        /* ctrlcmd for M1 keybindings that work on both macOS and other platforms */\n      } else if (keyString === SpecialCases.CTRLCMD) {\n        if (isOSX) {\n          schema.meta = true;\n        } else {\n          schema.ctrl = true;\n        }\n      } else if (Key.isKey(key)) {\n        if (Key.isModifier(key.code)) {\n          if (key.code === Key.CONTROL_LEFT.code || key.code === Key.CONTROL_RIGHT.code) {\n            schema.ctrl = true;\n          } else if (key.code === Key.SHIFT_LEFT.code || key.code === Key.SHIFT_RIGHT.code) {\n            schema.shift = true;\n          } else if (key.code === Key.ALT_LEFT.code || key.code === Key.ALT_RIGHT.code) {\n            schema.alt = true;\n          }\n        } else {\n          schema.key = key;\n        }\n      } else {\n        throw new Error(`Unrecognized key '${keyString}' in '${keybinding}'`);\n      }\n    }\n\n    KeyCode.keybindings[keybinding] = new KeyCode(schema);\n    return KeyCode.keybindings[keybinding];\n  }\n\n  /**\n   * Return true if this KeyCode only contains modifiers.\n   */\n  public isModifierOnly(): boolean {\n    return this.key === undefined;\n  }\n\n  /**\n   * Return true if the given KeyCode is equal to this one.\n   */\n  equals(other: KeyCode): boolean {\n    if (this.key && (!other.key || this.key.code !== other.key.code) || !this.key && other.key) {\n      return false;\n    }\n    return this.ctrl === other.ctrl && this.alt === other.alt && this.shift === other.shift && this.meta === other.meta;\n  }\n\n  /*\n   * Return a keybinding string compatible with the `Keybinding.keybinding` property.\n   */\n  toString(): string {\n    const result = [];\n    if (this.meta) {\n      result.push(SpecialCases.META);\n    }\n    if (this.shift) {\n      result.push(Key.SHIFT_LEFT.easyString);\n    }\n    if (this.alt) {\n      result.push(Key.ALT_LEFT.easyString);\n    }\n    if (this.ctrl) {\n      result.push(Key.CONTROL_LEFT.easyString);\n    }\n    if (this.key) {\n      result.push(this.key.easyString);\n    }\n    return result.join('+');\n  }\n\n}\n\nexport namespace KeyCode {\n\n  /**\n   * Determines a `true` of `false` value for the key code argument.\n   */\n  export type Predicate = (keyCode: KeyCode) => boolean;\n\n  /*\n   * Return true if the string is a modifier M1 to M4.\n   */\n  export function isModifierString(key: string): boolean {\n    return key === KeyModifier.CtrlCmd\n        || key === KeyModifier.Shift\n        || key === KeyModifier.Alt\n        || key === KeyModifier.MacCtrl;\n  }\n\n  /**\n   * Different scopes have different execution environments. This means that they have different built-ins\n   * (different global object, different constructors, etc.). This may result in unexpected results. For instance,\n   * `[] instanceof window.frames[0].Array` will return `false`, because `Array.prototype !== window.frames[0].Array`\n   * and arrays inherit from the former.\n   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\n   *\n   * Note: just add another check if the current `event.type` checking is insufficient.\n   */\n  export function isKeyboardEvent(event: object & { readonly type?: string }): event is KeyboardEvent {\n    if (typeof KeyboardEvent === 'undefined') { // This can happen in tests\n      return false;\n    }\n    if (event instanceof KeyboardEvent) {\n      return true;\n    }\n    const {type} = event;\n    if (type) {\n      return type === 'keypress' || type === 'keydown' || type === 'keyup';\n    }\n    return false;\n  }\n\n  /**\n   * Determine the pressed key of a keyboard event. This key should correspond to the physical key according\n   * to a standard US keyboard layout. International keyboard layouts are handled by `KeyboardLayoutService`.\n   *\n   * `keyIdentifier` is used to access this deprecated field:\n   * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyIdentifier\n   */\n  export function toKey(event: KeyboardEvent, dispatch: 'code' | 'keyCode' = 'code'): Key {\n    const code = event.code;\n    if (code && dispatch === 'code') {\n      if (isOSX) {\n        // https://github.com/eclipse-tart/tart/issues/4986\n        const char = event.key;\n        if (code === 'IntlBackslash' && (char === '`' || char === '~')) {\n          return Key.BACKQUOTE;\n        } else if (code === 'Backquote' && (char === '§' || char === '±')) {\n          return Key.INTL_BACKSLASH;\n        }\n      }\n\n      // https://github.com/eclipse-tart/tart/issues/7315\n      if (code.startsWith('Numpad') && event.key && event.key.length > 1) {\n        const k = Key.getKey(event.key);\n        if (k) {\n          return k;\n        }\n      }\n\n      const key = Key.getKey(code);\n      if (key) {\n        return key;\n      }\n    }\n\n    // tslint:disable-next-line: deprecation\n    const keyCode = event.keyCode;\n    if (keyCode) {\n      const key = Key.getKey(keyCode);\n      if (key) {\n        return key;\n      }\n    }\n\n    const keyIdentifier = (event as KeyboardEvent & { keyIdentifier?: string }).keyIdentifier;\n    if (keyIdentifier) {\n      const key = Key.getKey(keyIdentifier);\n      if (key) {\n        return key;\n      }\n    }\n    throw new Error(`Cannot get key code from the keyboard event: ${event}.`);\n  }\n\n  /**\n   * Determine the actual printable character that is generated from a pressed key.\n   * If the key does not correspond to a printable character, `undefined` is returned.\n   * The result may be altered by modifier keys.\n   */\n  export function toCharacter(event: KeyboardEvent): string | undefined {\n    const key = event.key;\n    // Use the key property if it contains exactly one unicode character\n    if (key && Array.from(key).length === 1) {\n      return key;\n    }\n    const charCode = event.charCode;\n    // Use the charCode property if it does not correspond to a unicode control character\n    if (charCode && charCode > 0x1f && !(charCode >= 0x80 && charCode <= 0x9f)) {\n      return String.fromCharCode(charCode);\n    }\n    return undefined;\n  }\n\n}\n\nexport enum KeyModifier {\n  /**\n   * M1 is the COMMAND key on MacOS X, and the CTRL key on most other platforms.\n   */\n  CtrlCmd = 'M1',\n  /**\n   * M2 is the SHIFT key.\n   */\n  Shift = 'M2',\n  /**\n   * M3 is the Option key on MacOS X, and the ALT key on most other platforms.\n   */\n  Alt = 'M3',\n  /**\n   * M4 is the CTRL key on MacOS X, and is undefined on other platforms.\n   */\n  MacCtrl = 'M4'\n}\n\nexport namespace KeyModifier {\n  /**\n   * The CTRL key, independently of the platform.\n   * _Note:_ In general `KeyModifier.CtrlCmd` should be preferred over this constant.\n   */\n  export const CTRL: KeyModifier.MacCtrl | KeyModifier.CtrlCmd = isOSX ? KeyModifier.MacCtrl : KeyModifier.CtrlCmd;\n  /**\n   * An alias for the SHIFT key (`KeyModifier.Shift`).\n   */\n  export const SHIFT: KeyModifier.Shift = KeyModifier.Shift;\n\n  /**\n   * `true` if the argument represents a modifier. Otherwise, `false`.\n   */\n  export function isModifier(key: string | undefined): boolean {\n    if (key) {\n      switch (key) {\n        case 'M1': // Fall through.\n        case 'M2': // Fall through.\n        case 'M3': // Fall through.\n        case 'M4':\n          return true;\n        default:\n          return false;\n      }\n    }\n    return false;\n  }\n}\n\nexport interface Key {\n  readonly code: string;\n  readonly keyCode: number;\n  readonly easyString: string;\n}\n\nconst CODE_TO_KEY: { [code: string]: Key } = {};\nconst KEY_CODE_TO_KEY: { [keyCode: number]: Key } = {};\nconst EASY_TO_KEY: { [code: string]: Key } = {}; // From 'ctrl' to Key structure\nconst MODIFIERS: Key[] = [];\n\nconst SPECIAL_ALIASES: { [index: string]: string } = {\n  'option': 'alt',\n  'command': 'meta',\n  'cmd': 'meta',\n  'return': 'enter',\n  'esc': 'escape',\n  'mod': 'ctrl',\n  'ins': 'insert',\n  'del': 'delete',\n  'control': 'ctrl',\n};\n\nexport namespace SpecialCases {\n  export const META = 'meta';\n  export const CTRLCMD = 'ctrlcmd';\n}\n\nexport namespace Key {\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function isKey(arg: any): arg is Key {\n    return typeof arg === 'object' && ('code' in arg) && ('keyCode' in arg);\n  }\n\n  export function getKey(arg: string | number): Key | undefined {\n    if (typeof arg === 'number') {\n      return KEY_CODE_TO_KEY[arg];\n    } else {\n      return CODE_TO_KEY[arg];\n    }\n  }\n\n  export function isModifier(arg: string | number): boolean {\n    if (typeof arg === 'number') {\n      return MODIFIERS.find(key => key.keyCode === arg) !== undefined;\n    }\n    return MODIFIERS.find(key => key.code === arg) !== undefined;\n  }\n\n  export function equals(key: Key, keyCode: KeyCode): boolean {\n    return !!keyCode.key && key.keyCode === keyCode.key.keyCode;\n  }\n\n  export const BACKSPACE: Key = {code: 'Backspace', keyCode: 8, easyString: 'backspace'};\n  export const TAB: Key = {code: 'Tab', keyCode: 9, easyString: 'tab'};\n  export const ENTER: Key = {code: 'Enter', keyCode: 13, easyString: 'enter'};\n  export const ESCAPE: Key = {code: 'Escape', keyCode: 27, easyString: 'escape'};\n  export const SPACE: Key = {code: 'Space', keyCode: 32, easyString: 'space'};\n  export const PAGE_UP: Key = {code: 'PageUp', keyCode: 33, easyString: 'pageup'};\n  export const PAGE_DOWN: Key = {code: 'PageDown', keyCode: 34, easyString: 'pagedown'};\n  export const END: Key = {code: 'End', keyCode: 35, easyString: 'end'};\n  export const HOME: Key = {code: 'Home', keyCode: 36, easyString: 'home'};\n  export const ARROW_LEFT: Key = {code: 'ArrowLeft', keyCode: 37, easyString: 'left'};\n  export const ARROW_UP: Key = {code: 'ArrowUp', keyCode: 38, easyString: 'up'};\n  export const ARROW_RIGHT: Key = {code: 'ArrowRight', keyCode: 39, easyString: 'right'};\n  export const ARROW_DOWN: Key = {code: 'ArrowDown', keyCode: 40, easyString: 'down'};\n  export const INSERT: Key = {code: 'Insert', keyCode: 45, easyString: 'insert'};\n  export const DELETE: Key = {code: 'Delete', keyCode: 46, easyString: 'delete'};\n\n  export const SHIFT_LEFT: Key = {code: 'ShiftLeft', keyCode: 16, easyString: 'shift'};\n  export const SHIFT_RIGHT: Key = {code: 'ShiftRight', keyCode: 16, easyString: 'shift'};\n  export const CONTROL_LEFT: Key = {code: 'ControlLeft', keyCode: 17, easyString: 'ctrl'};\n  export const CONTROL_RIGHT: Key = {code: 'ControlRight', keyCode: 17, easyString: 'ctrl'};\n  export const ALT_LEFT: Key = {code: 'AltLeft', keyCode: 18, easyString: 'alt'};\n  export const ALT_RIGHT: Key = {code: 'AltRight', keyCode: 18, easyString: 'alt'};\n  export const CAPS_LOCK: Key = {code: 'CapsLock', keyCode: 20, easyString: 'capslock'};\n  export const OS_LEFT: Key = {code: 'OSLeft', keyCode: 91, easyString: 'super'};\n  export const OS_RIGHT: Key = {code: 'OSRight', keyCode: 92, easyString: 'super'};\n\n  export const DIGIT0: Key = {code: 'Digit0', keyCode: 48, easyString: '0'};\n  export const DIGIT1: Key = {code: 'Digit1', keyCode: 49, easyString: '1'};\n  export const DIGIT2: Key = {code: 'Digit2', keyCode: 50, easyString: '2'};\n  export const DIGIT3: Key = {code: 'Digit3', keyCode: 51, easyString: '3'};\n  export const DIGIT4: Key = {code: 'Digit4', keyCode: 52, easyString: '4'};\n  export const DIGIT5: Key = {code: 'Digit5', keyCode: 53, easyString: '5'};\n  export const DIGIT6: Key = {code: 'Digit6', keyCode: 54, easyString: '6'};\n  export const DIGIT7: Key = {code: 'Digit7', keyCode: 55, easyString: '7'};\n  export const DIGIT8: Key = {code: 'Digit8', keyCode: 56, easyString: '8'};\n  export const DIGIT9: Key = {code: 'Digit9', keyCode: 57, easyString: '9'};\n\n  export const KEY_A: Key = {code: 'KeyA', keyCode: 65, easyString: 'a'};\n  export const KEY_B: Key = {code: 'KeyB', keyCode: 66, easyString: 'b'};\n  export const KEY_C: Key = {code: 'KeyC', keyCode: 67, easyString: 'c'};\n  export const KEY_D: Key = {code: 'KeyD', keyCode: 68, easyString: 'd'};\n  export const KEY_E: Key = {code: 'KeyE', keyCode: 69, easyString: 'e'};\n  export const KEY_F: Key = {code: 'KeyF', keyCode: 70, easyString: 'f'};\n  export const KEY_G: Key = {code: 'KeyG', keyCode: 71, easyString: 'g'};\n  export const KEY_H: Key = {code: 'KeyH', keyCode: 72, easyString: 'h'};\n  export const KEY_I: Key = {code: 'KeyI', keyCode: 73, easyString: 'i'};\n  export const KEY_J: Key = {code: 'KeyJ', keyCode: 74, easyString: 'j'};\n  export const KEY_K: Key = {code: 'KeyK', keyCode: 75, easyString: 'k'};\n  export const KEY_L: Key = {code: 'KeyL', keyCode: 76, easyString: 'l'};\n  export const KEY_M: Key = {code: 'KeyM', keyCode: 77, easyString: 'm'};\n  export const KEY_N: Key = {code: 'KeyN', keyCode: 78, easyString: 'n'};\n  export const KEY_O: Key = {code: 'KeyO', keyCode: 79, easyString: 'o'};\n  export const KEY_P: Key = {code: 'KeyP', keyCode: 80, easyString: 'p'};\n  export const KEY_Q: Key = {code: 'KeyQ', keyCode: 81, easyString: 'q'};\n  export const KEY_R: Key = {code: 'KeyR', keyCode: 82, easyString: 'r'};\n  export const KEY_S: Key = {code: 'KeyS', keyCode: 83, easyString: 's'};\n  export const KEY_T: Key = {code: 'KeyT', keyCode: 84, easyString: 't'};\n  export const KEY_U: Key = {code: 'KeyU', keyCode: 85, easyString: 'u'};\n  export const KEY_V: Key = {code: 'KeyV', keyCode: 86, easyString: 'v'};\n  export const KEY_W: Key = {code: 'KeyW', keyCode: 87, easyString: 'w'};\n  export const KEY_X: Key = {code: 'KeyX', keyCode: 88, easyString: 'x'};\n  export const KEY_Y: Key = {code: 'KeyY', keyCode: 89, easyString: 'y'};\n  export const KEY_Z: Key = {code: 'KeyZ', keyCode: 90, easyString: 'z'};\n\n  export const MULTIPLY: Key = {code: 'NumpadMultiply', keyCode: 106, easyString: 'multiply'};\n  export const ADD: Key = {code: 'NumpadAdd', keyCode: 107, easyString: 'add'};\n  export const DECIMAL: Key = {code: 'NumpadDecimal', keyCode: 108, easyString: 'decimal'};\n  export const SUBTRACT: Key = {code: 'NumpadSubtract', keyCode: 109, easyString: 'subtract'};\n  export const DIVIDE: Key = {code: 'NumpadDivide', keyCode: 111, easyString: 'divide'};\n\n  export const F1: Key = {code: 'F1', keyCode: 112, easyString: 'f1'};\n  export const F2: Key = {code: 'F2', keyCode: 113, easyString: 'f2'};\n  export const F3: Key = {code: 'F3', keyCode: 114, easyString: 'f3'};\n  export const F4: Key = {code: 'F4', keyCode: 115, easyString: 'f4'};\n  export const F5: Key = {code: 'F5', keyCode: 116, easyString: 'f5'};\n  export const F6: Key = {code: 'F6', keyCode: 117, easyString: 'f6'};\n  export const F7: Key = {code: 'F7', keyCode: 118, easyString: 'f7'};\n  export const F8: Key = {code: 'F8', keyCode: 119, easyString: 'f8'};\n  export const F9: Key = {code: 'F9', keyCode: 120, easyString: 'f9'};\n  export const F10: Key = {code: 'F10', keyCode: 121, easyString: 'f10'};\n  export const F11: Key = {code: 'F11', keyCode: 122, easyString: 'f11'};\n  export const F12: Key = {code: 'F12', keyCode: 123, easyString: 'f12'};\n  export const F13: Key = {code: 'F13', keyCode: 124, easyString: 'f13'};\n  export const F14: Key = {code: 'F14', keyCode: 125, easyString: 'f14'};\n  export const F15: Key = {code: 'F15', keyCode: 126, easyString: 'f15'};\n  export const F16: Key = {code: 'F16', keyCode: 127, easyString: 'f16'};\n  export const F17: Key = {code: 'F17', keyCode: 128, easyString: 'f17'};\n  export const F18: Key = {code: 'F18', keyCode: 129, easyString: 'f18'};\n  export const F19: Key = {code: 'F19', keyCode: 130, easyString: 'f19'};\n  export const F20: Key = {code: 'F20', keyCode: 131, easyString: 'f20'};\n  export const F21: Key = {code: 'F21', keyCode: 132, easyString: 'f21'};\n  export const F22: Key = {code: 'F22', keyCode: 133, easyString: 'f22'};\n  export const F23: Key = {code: 'F23', keyCode: 134, easyString: 'f23'};\n  export const F24: Key = {code: 'F24', keyCode: 135, easyString: 'f24'};\n\n  export const NUM_LOCK: Key = {code: 'NumLock', keyCode: 144, easyString: 'numlock'};\n  export const SEMICOLON: Key = {code: 'Semicolon', keyCode: 186, easyString: ';'};\n  export const EQUAL: Key = {code: 'Equal', keyCode: 187, easyString: '='};\n  export const COMMA: Key = {code: 'Comma', keyCode: 188, easyString: ','};\n  export const MINUS: Key = {code: 'Minus', keyCode: 189, easyString: '-'};\n  export const PERIOD: Key = {code: 'Period', keyCode: 190, easyString: '.'};\n  export const SLASH: Key = {code: 'Slash', keyCode: 191, easyString: '/'};\n  export const BACKQUOTE: Key = {code: 'Backquote', keyCode: 192, easyString: '`'};\n  export const INTL_RO: Key = {code: 'IntlRo', keyCode: 193, easyString: 'intlro'};\n  export const BRACKET_LEFT: Key = {code: 'BracketLeft', keyCode: 219, easyString: '['};\n  export const BACKSLASH: Key = {code: 'Backslash', keyCode: 220, easyString: '\\\\'};\n  export const BRACKET_RIGHT: Key = {code: 'BracketRight', keyCode: 221, easyString: ']'};\n  export const QUOTE: Key = {code: 'Quote', keyCode: 222, easyString: '\\''};\n  export const INTL_BACKSLASH: Key = {code: 'IntlBackslash', keyCode: 229, easyString: 'intlbackslash'};\n  export const INTL_YEN: Key = {code: 'IntlYen', keyCode: 255, easyString: 'intlyen'};\n\n  export const MAX_KEY_CODE = INTL_YEN.keyCode;\n\n}\n\n/* -------------------- Initialize the static key mappings -------------------- */\n(() => {\n  // Set the default key mappings from the constants in the Key namespace\n  Object.keys(Key).map(prop => Reflect.get(Key, prop)).filter(key => Key.isKey(key)).forEach(key => {\n    CODE_TO_KEY[key.code] = key;\n    KEY_CODE_TO_KEY[key.keyCode] = key;\n    EASY_TO_KEY[key.easyString] = key;\n  });\n\n  // Set additional key mappings\n  CODE_TO_KEY['Numpad0'] = Key.DIGIT0;\n  KEY_CODE_TO_KEY[96] = Key.DIGIT0;\n  CODE_TO_KEY['Numpad1'] = Key.DIGIT1;\n  KEY_CODE_TO_KEY[97] = Key.DIGIT1;\n  CODE_TO_KEY['Numpad2'] = Key.DIGIT2;\n  KEY_CODE_TO_KEY[98] = Key.DIGIT2;\n  CODE_TO_KEY['Numpad3'] = Key.DIGIT3;\n  KEY_CODE_TO_KEY[99] = Key.DIGIT3;\n  CODE_TO_KEY['Numpad4'] = Key.DIGIT4;\n  KEY_CODE_TO_KEY[100] = Key.DIGIT4;\n  CODE_TO_KEY['Numpad5'] = Key.DIGIT5;\n  KEY_CODE_TO_KEY[101] = Key.DIGIT5;\n  CODE_TO_KEY['Numpad6'] = Key.DIGIT6;\n  KEY_CODE_TO_KEY[102] = Key.DIGIT6;\n  CODE_TO_KEY['Numpad7'] = Key.DIGIT7;\n  KEY_CODE_TO_KEY[103] = Key.DIGIT7;\n  CODE_TO_KEY['Numpad8'] = Key.DIGIT8;\n  KEY_CODE_TO_KEY[104] = Key.DIGIT8;\n  CODE_TO_KEY['Numpad9'] = Key.DIGIT9;\n  KEY_CODE_TO_KEY[105] = Key.DIGIT9;\n  CODE_TO_KEY['NumpadEnter'] = Key.ENTER;\n  CODE_TO_KEY['NumpadEqual'] = Key.EQUAL;\n  CODE_TO_KEY['MetaLeft'] = Key.OS_LEFT;   // Chrome, Safari\n  KEY_CODE_TO_KEY[224] = Key.OS_LEFT;      // Firefox on Mac\n  CODE_TO_KEY['MetaRight'] = Key.OS_RIGHT; // Chrome, Safari\n  KEY_CODE_TO_KEY[93] = Key.OS_RIGHT;      // Chrome, Safari, Edge\n  KEY_CODE_TO_KEY[225] = Key.ALT_RIGHT;    // Linux\n  KEY_CODE_TO_KEY[110] = Key.DECIMAL;      // Mac, Windows\n  KEY_CODE_TO_KEY[59] = Key.SEMICOLON;     // Firefox\n  KEY_CODE_TO_KEY[61] = Key.EQUAL;         // Firefox\n  KEY_CODE_TO_KEY[173] = Key.MINUS;        // Firefox\n  KEY_CODE_TO_KEY[226] = Key.BACKSLASH;    // Chrome, Edge on Windows\n  KEY_CODE_TO_KEY[60] = Key.BACKSLASH;     // Firefox on Linux\n\n  // Set the modifier keys\n  MODIFIERS.push(...[Key.ALT_LEFT, Key.ALT_RIGHT, Key.CONTROL_LEFT, Key.CONTROL_RIGHT, Key.OS_LEFT, Key.OS_RIGHT, Key.SHIFT_LEFT, Key.SHIFT_RIGHT]);\n})();\n\nexport type KeysOrKeyCodes = Key | KeyCode | (Key | KeyCode)[];\nexport namespace KeysOrKeyCodes {\n\n  export const toKeyCode = (keyOrKeyCode: Key | KeyCode) =>\n      keyOrKeyCode instanceof KeyCode ? keyOrKeyCode : KeyCode.createKeyCode({first: keyOrKeyCode});\n\n  export const toKeyCodes = (keysOrKeyCodes: KeysOrKeyCodes) => {\n    if (keysOrKeyCodes instanceof KeyCode) {\n      return [keysOrKeyCodes];\n    } else if (Array.isArray(keysOrKeyCodes)) {\n      return keysOrKeyCodes.slice().map(toKeyCode);\n    }\n    return [toKeyCode(keysOrKeyCodes)];\n  };\n\n}\n"]}