{"version":3,"sources":["browser/saveable.ts"],"names":[],"mappings":"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","file":"../../src/browser/saveable.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {Widget} from '@lumino/widgets';\nimport {Message} from '@lumino/messaging';\nimport {Event} from '../common/event';\nimport {MaybePromise} from '../common/types';\nimport {Key} from './keyboard/keys';\nimport {AbstractDialog} from './dialogs';\nimport {waitForClosed} from './widgets';\n\nexport interface Saveable {\n  readonly dirty: boolean;\n  readonly onDirtyChanged: Event<void>;\n  readonly autoSave: 'on' | 'off';\n\n  /**\n   * Saves dirty changes.\n   */\n  save(options?: SaveOptions): MaybePromise<void>;\n\n  /**\n   * Reverts dirty changes.\n   */\n  revert?(options?: Saveable.RevertOptions): Promise<void>;\n\n  /**\n   * Creates a snapshot of the dirty state.\n   */\n  createSnapshot?(): object;\n\n  /**\n   * Applies the given snapshot to the dirty state.\n   */\n  applySnapshot?(snapshot: object): void;\n}\n\nexport interface SaveableSource {\n  readonly saveable: Saveable;\n}\n\nexport namespace Saveable {\n  export interface RevertOptions {\n    /**\n     * If soft then only dirty flag should be updated, otherwise\n     * the underlying data should be reverted as well.\n     */\n    soft?: boolean\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function isSource(arg: any): arg is SaveableSource {\n    return !!arg && ('saveable' in arg) && is(arg.saveable);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is(arg: any): arg is Saveable {\n    return !!arg && ('dirty' in arg) && ('onDirtyChanged' in arg);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function get(arg: any): Saveable | undefined {\n    if (is(arg)) {\n      return arg;\n    }\n    if (isSource(arg)) {\n      return arg.saveable;\n    }\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function getDirty(arg: any): Saveable | undefined {\n    const saveable = get(arg);\n    if (saveable && saveable.dirty) {\n      return saveable;\n    }\n    return undefined;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function isDirty(arg: any): boolean {\n    return !!getDirty(arg);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export async function save(arg: any, options?: SaveOptions): Promise<void> {\n    const saveable = get(arg);\n    if (saveable) {\n      await saveable.save(options);\n    }\n  }\n\n  export function apply(widget: Widget): SaveableWidget | undefined {\n    if (SaveableWidget.is(widget)) {\n      return widget;\n    }\n    const saveable = Saveable.get(widget);\n    if (!saveable) {\n      return undefined;\n    }\n    setDirty(widget, saveable.dirty);\n    saveable.onDirtyChanged(() => setDirty(widget, saveable.dirty));\n    const closeWidget = widget.close.bind(widget);\n    const closeWithoutSaving: SaveableWidget['closeWithoutSaving'] = async () => {\n      if (saveable.dirty && saveable.revert) {\n        await saveable.revert();\n      }\n      closeWidget();\n      return waitForClosed(widget);\n    };\n    let closing = false;\n    const closeWithSaving: SaveableWidget['closeWithSaving'] = async options => {\n      if (closing) {\n        return;\n      }\n      closing = true;\n      try {\n        const result = await shouldSave(saveable, () => {\n          if (options && options.shouldSave) {\n            return options.shouldSave();\n          }\n          return new ShouldSaveDialog(widget).open();\n        });\n        if (typeof result === 'boolean') {\n          if (result) {\n            await Saveable.save(widget);\n          }\n          await closeWithoutSaving();\n        }\n      } finally {\n        closing = false;\n      }\n    };\n    return Object.assign(widget, {\n      closeWithoutSaving,\n      closeWithSaving,\n      close: () => closeWithSaving()\n    });\n  }\n\n  export async function shouldSave(saveable: Saveable, cb: () => MaybePromise<boolean | undefined>): Promise<boolean | undefined> {\n    if (!saveable.dirty) {\n      return false;\n    }\n\n    if (saveable.autoSave === 'on') {\n      return true;\n    }\n\n    return cb();\n  }\n}\n\nexport interface SaveableWidget extends Widget {\n  closeWithoutSaving(): Promise<void>;\n\n  closeWithSaving(options?: SaveableWidget.CloseOptions): Promise<void>;\n}\n\nexport namespace SaveableWidget {\n  export function is(widget: Widget | undefined): widget is SaveableWidget {\n    return !!widget && 'closeWithoutSaving' in widget;\n  }\n\n  export function getDirty<T extends Widget>(widgets: Iterable<T>): IterableIterator<SaveableWidget & T> {\n    return get(widgets, Saveable.isDirty);\n  }\n\n  export function* get<T extends Widget>(\n      widgets: Iterable<T>,\n      filter: (widget: T) => boolean = () => true\n  ): IterableIterator<SaveableWidget & T> {\n    for (const widget of widgets) {\n      if (SaveableWidget.is(widget) && filter(widget)) {\n        yield widget;\n      }\n    }\n  }\n\n  export interface CloseOptions {\n    shouldSave?(): MaybePromise<boolean | undefined>\n  }\n}\n\n/**\n * Possible formatting types when saving.\n */\nexport const enum FormatType {\n  /**\n   * Formatting should occur (default).\n   */\n  ON = 1,\n  /**\n   * Formatting should not occur.\n   */\n  OFF,\n  /**\n   * Formatting should only occur if the resource is dirty.\n   */\n  DIRTY\n}\n\nexport interface SaveOptions {\n  /**\n   * Formatting type to apply when saving.\n   */\n  readonly formatType?: FormatType;\n}\n\n/**\n * The class name added to the dirty widget's title.\n */\nconst DIRTY_CLASS = 'tart-mod-dirty';\n\nexport function setDirty(widget: Widget, dirty: boolean): void {\n  const dirtyClass = ` ${DIRTY_CLASS}`;\n  widget.title.className = widget.title.className.replace(dirtyClass, '');\n  if (dirty) {\n    widget.title.className += dirtyClass;\n  }\n}\n\nexport class ShouldSaveDialog extends AbstractDialog<boolean> {\n\n  protected shouldSave = true;\n\n  protected readonly dontSaveButton: HTMLButtonElement;\n\n  constructor(widget: Widget) {\n    super({\n      title: `Do you want to save the changes you made to ${widget.title.label || widget.title.caption}?`\n    });\n\n    const messageNode = document.createElement('div');\n    messageNode.textContent = \"Your changes will be lost if you don't save them.\";\n    messageNode.setAttribute('style', 'flex: 1 100%; padding-bottom: calc(var(--tart-ui-padding)*3);');\n    this.contentNode.appendChild(messageNode);\n    this.dontSaveButton = this.appendDontSaveButton();\n    this.appendCloseButton();\n    this.appendAcceptButton('Save');\n  }\n\n  get value(): boolean {\n    return this.shouldSave;\n  }\n\n  protected appendDontSaveButton(): HTMLButtonElement {\n    const button = this.createButton(\"Don't save\");\n    this.controlPanel.appendChild(button);\n    button.classList.add('secondary');\n    return button;\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    super.onAfterAttach(msg);\n    this.addKeyListener(this.dontSaveButton, Key.ENTER, () => {\n      this.shouldSave = false;\n      this.accept();\n    }, 'click');\n  }\n\n}\n"]}