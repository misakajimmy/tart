{"version":3,"sources":["browser/tree/tree-widget.tsx"],"names":[],"mappings":"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","file":"../../../src/browser/tree/tree-widget.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {debounce} from 'lodash';\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {Message} from '@lumino/messaging';\nimport {Disposable, MenuPath, SelectionService} from '../../common';\nimport {Key, KeyCode, KeyModifier} from '../keyboard/keys';\nimport {ContextMenuRenderer} from '../context-menu-renderer';\nimport {StatefulWidget} from '../shell';\nimport {\n  BUSY_CLASS,\n  CODICON_LOADING_CLASSES,\n  CODICON_TREE_ITEM_CLASSES,\n  COLLAPSED_CLASS,\n  EXPANSION_TOGGLE_CLASS,\n  FOCUS_CLASS,\n  SELECTED_CLASS,\n  UnsafeWidgetUtilities,\n  Widget\n} from '../widgets';\nimport {CompositeTreeNode, TreeNode} from './tree';\nimport {TreeModel} from './tree-model';\nimport {ExpandableTreeNode} from './tree-expansion';\nimport {SelectableTreeNode, TreeSelection} from './tree-selection';\nimport {DecoratedTreeNode, TreeDecoration, TreeDecoratorService} from './tree-decorator';\nimport {notEmpty} from '../../common/objects';\nimport {isOSX} from '../../common/os';\nimport {ReactWidget} from '../widgets/react-widget';\nimport * as React from 'react';\nimport {CellMeasurer, CellMeasurerCache, List, ListRowRenderer, ScrollParams} from 'react-virtualized';\nimport {TopDownTreeIterator} from './tree-iterator';\nimport {SearchBox, SearchBoxFactory, SearchBoxProps} from './search-box';\nimport {TreeSearch} from './tree-search';\nimport {ElementExt} from '@lumino/domutils';\nimport {TreeWidgetSelection} from './tree-widget-selection';\nimport {MaybePromise} from '../../common/types';\nimport {LabelProvider} from '../label-provider';\nimport {CorePreferences} from '../core-preferences';\n\nexport const TREE_CLASS = 'tart-Tree';\nexport const TREE_CONTAINER_CLASS = 'tart-TreeContainer';\nexport const TREE_NODE_CLASS = 'tart-TreeNode';\nexport const TREE_NODE_CONTENT_CLASS = 'tart-TreeNodeContent';\nexport const TREE_NODE_INFO_CLASS = 'tart-TreeNodeInfo';\nexport const TREE_NODE_TAIL_CLASS = 'tart-TreeNodeTail';\nexport const TREE_NODE_SEGMENT_CLASS = 'tart-TreeNodeSegment';\nexport const TREE_NODE_SEGMENT_GROW_CLASS = 'tart-TreeNodeSegmentGrow';\n\nexport const EXPANDABLE_TREE_NODE_CLASS = 'tart-ExpandableTreeNode';\nexport const COMPOSITE_TREE_NODE_CLASS = 'tart-CompositeTreeNode';\nexport const TREE_NODE_CAPTION_CLASS = 'tart-TreeNodeCaption';\nexport const TREE_NODE_INDENT_GUIDE_CLASS = 'tart-tree-node-indent';\n\nexport const TreeProps = Symbol('TreeProps');\n\n/**\n * Representation of tree properties.\n */\nexport interface TreeProps {\n\n  /**\n   * The path of the context menu that one can use to contribute context menu items to the tree widget.\n   */\n  readonly contextMenuPath?: MenuPath;\n\n  /**\n   * The size of the padding (in pixels) per hierarchy depth. The root element won't have left padding but\n   * the padding for the children will be calculated as `leftPadding * hierarchyDepth` and so on.\n   */\n  readonly leftPadding: number;\n\n  readonly expansionTogglePadding: number;\n\n  /**\n   * `true` if the tree widget support multi-selection. Otherwise, `false`. Defaults to `false`.\n   */\n  readonly multiSelect?: boolean;\n\n  /**\n   * `true` if the tree widget support searching. Otherwise, `false`. Defaults to `false`.\n   */\n  readonly search?: boolean\n\n  /**\n   * `true` if the tree widget should be virtualized searching. Otherwise, `false`. Defaults to `true`.\n   */\n  readonly virtualized?: boolean\n\n  /**\n   * `true` if the selected node should be auto scrolled only if the widget is active. Otherwise, `false`. Defaults to `false`.\n   */\n  readonly scrollIfActive?: boolean\n\n  /**\n   * `true` if a tree widget contributes to the global selection. Defaults to `false`.\n   */\n  readonly globalSelection?: boolean;\n\n  /**\n   *  `true` if the tree widget supports expansion only when clicking the expansion toggle. Defaults to `false`.\n   */\n  readonly expandOnlyOnExpansionToggleClick?: boolean;\n\n}\n\n/**\n * Representation of node properties.\n */\nexport interface NodeProps {\n\n  /**\n   * A root relative number representing the hierarchical depth of the actual node. Root is `0`, its children have `1` and so on.\n   */\n  readonly depth: number;\n\n}\n\n/**\n * The default tree properties.\n */\nexport const defaultTreeProps: TreeProps = {\n  leftPadding: 8,\n  expansionTogglePadding: 22\n};\n\nexport namespace TreeWidget {\n\n  /**\n   * Bare minimum common interface of the keyboard and the mouse event with respect to the key maskings.\n   */\n  export interface ModifierAwareEvent {\n    /**\n     * Determines if the modifier aware event has the `meta` key masking.\n     */\n    readonly metaKey: boolean;\n    /**\n     * Determines if the modifier aware event has the `ctrl` key masking.\n     */\n    readonly ctrlKey: boolean;\n    /**\n     * Determines if the modifier aware event has the `shift` key masking.\n     */\n    readonly shiftKey: boolean;\n  }\n\n}\n\n@injectable()\nexport class TreeWidget extends ReactWidget implements StatefulWidget {\n\n  scrollArea: Element = this.node;\n  protected searchBox: SearchBox;\n  protected searchHighlights: Map<string, TreeDecoration.CaptionHighlight>;\n  @inject(TreeDecoratorService)\n  protected readonly decoratorService: TreeDecoratorService;\n  @inject(TreeSearch)\n  protected readonly treeSearch: TreeSearch;\n  @inject(SearchBoxFactory)\n  protected readonly searchBoxFactory: SearchBoxFactory;\n  protected decorations: Map<string, TreeDecoration.Data[]> = new Map();\n  @inject(SelectionService)\n  protected readonly selectionService: SelectionService;\n  @inject(LabelProvider)\n  protected readonly labelProvider: LabelProvider;\n  @inject(CorePreferences)\n  protected readonly corePreferences: CorePreferences;\n  protected shouldScrollToRow = true;\n  protected rows = new Map<string, TreeWidget.NodeRow>();\n  protected updateRows = debounce(() => this.doUpdateRows(), 10);\n  /**\n   * Row index to ensure visibility.\n   * - Used to forcefully scroll if necessary.\n   */\n  protected scrollToRow: number | undefined;\n  /**\n   * Update tree decorations.\n   * - Updating decorations are debounced in order to limit the number of expensive updates.\n   */\n  protected readonly updateDecorations = debounce(() => this.doUpdateDecorations(), 150);\n  protected view: TreeWidget.View | undefined;\n  /**\n   * Store the last scroll state.\n   */\n  protected lastScrollState: {\n    /**\n     * The scroll top value.\n     */\n    scrollTop: number,\n    /**\n     * The scroll left value.\n     */\n    scrollLeft: number\n  } | undefined;\n\n  constructor(\n      @inject(TreeProps) readonly props: TreeProps,\n      @inject(TreeModel) readonly model: TreeModel,\n      @inject(ContextMenuRenderer) protected readonly contextMenuRenderer: ContextMenuRenderer,\n  ) {\n    super();\n    this.scrollOptions = {\n      suppressScrollX: true,\n      minScrollbarLength: 35\n    };\n    this.addClass(TREE_CLASS);\n    this.node.tabIndex = 0;\n  }\n\n  /**\n   * Store the tree state.\n   */\n  storeState(): object {\n    const decorations = this.decoratorService.deflateDecorators(this.decorations);\n    let state: object = {\n      decorations\n    };\n    if (this.model.root) {\n      state = {\n        ...state,\n        root: this.deflateForStorage(this.model.root),\n        model: this.model.storeState()\n      };\n    }\n\n    return state;\n  }\n\n  /**\n   * Restore the state.\n   * @param oldState the old state object.\n   */\n  restoreState(oldState: object): void {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const {root, decorations, model} = (oldState as any);\n    if (root) {\n      this.model.root = this.inflateFromStorage(root);\n    }\n    if (decorations) {\n      this.decorations = this.decoratorService.inflateDecorators(decorations);\n    }\n    if (model) {\n      this.model.restoreState(model);\n    }\n  }\n\n  @postConstruct()\n  protected init(): void {\n    if (this.props.search) {\n      this.searchBox = this.searchBoxFactory({...SearchBoxProps.DEFAULT, showButtons: true, showFilter: true});\n      this.searchBox.node.addEventListener('focus', () => {\n        this.node.focus();\n      });\n      this.toDispose.pushAll([\n        this.searchBox,\n        this.searchBox.onTextChange(async data => {\n          await this.treeSearch.filter(data);\n          this.searchHighlights = this.treeSearch.getHighlights();\n          this.searchBox.updateHighlightInfo({\n            filterText: data,\n            total: this.rows.size,\n            matched: this.searchHighlights.size\n          });\n          this.update();\n        }),\n        this.searchBox.onClose(data => this.treeSearch.filter(undefined)),\n        this.searchBox.onNext(() => {\n          // Enable next selection if there are currently highlights.\n          if (this.searchHighlights.size > 1) {\n            this.model.selectNextNode();\n          }\n        }),\n        this.searchBox.onPrevious(() => {\n          // Enable previous selection if there are currently highlights.\n          if (this.searchHighlights.size > 1) {\n            this.model.selectPrevNode();\n          }\n        }),\n        this.searchBox.onFilterToggled(e => {\n          this.updateRows();\n        }),\n        this.treeSearch,\n        this.treeSearch.onFilteredNodesChanged(nodes => {\n          if (this.searchBox.isFiltering) {\n            this.updateRows();\n          }\n          const node = nodes.find(SelectableTreeNode.is);\n          if (node) {\n            this.model.selectNode(node);\n          }\n        }),\n      ]);\n    }\n    this.toDispose.pushAll([\n      this.model,\n      this.model.onChanged(() => this.updateRows()),\n      this.model.onSelectionChanged(() => this.updateScrollToRow({resize: false})),\n      this.model.onDidChangeBusy(() => this.update()),\n      this.model.onNodeRefreshed(() => this.updateDecorations()),\n      this.model.onExpansionChanged(() => this.updateDecorations()),\n      this.decoratorService,\n      this.decoratorService.onDidChangeDecorations(() => this.updateDecorations()),\n      this.labelProvider.onDidChange(e => {\n        for (const row of this.rows.values()) {\n          if (e.affects(row)) {\n            this.forceUpdate();\n            return;\n          }\n        }\n      })\n    ]);\n    setTimeout(() => {\n      this.updateRows();\n      this.updateDecorations();\n    });\n    if (this.props.globalSelection) {\n      this.toDispose.pushAll([\n        this.model.onSelectionChanged(() => {\n          if (this.node.contains(document.activeElement)) {\n            this.updateGlobalSelection();\n          }\n        }),\n        Disposable.create(() => {\n          const selection = this.selectionService.selection;\n          if (TreeWidgetSelection.isSource(selection, this)) {\n            this.selectionService.selection = undefined;\n          }\n        })\n      ]);\n    }\n    this.toDispose.push(this.corePreferences.onPreferenceChanged(preference => {\n      if (preference.preferenceName === 'workbench.tree.renderIndentGuides') {\n        this.update();\n      }\n    }));\n  }\n\n  /**\n   * Update the global selection for the tree.\n   */\n  protected updateGlobalSelection(): void {\n    this.selectionService.selection = TreeWidgetSelection.create(this);\n  }\n\n  protected doUpdateRows(): void {\n    const root = this.model.root;\n    const rowsToUpdate: Array<[string, TreeWidget.NodeRow]> = [];\n    if (root) {\n      const depths = new Map<CompositeTreeNode | undefined, number>();\n      let index = 0;\n      const c = new TopDownTreeIterator(root, {\n        pruneCollapsed: true,\n        pruneSiblings: true\n      });\n      for (const node of c) {\n        if (this.shouldDisplayNode(node)) {\n          const parentDepth = depths.get(node.parent);\n          const depth = parentDepth === undefined ? 0 : TreeNode.isVisible(node.parent) ? parentDepth + 1 : parentDepth;\n          if (CompositeTreeNode.is(node)) {\n            depths.set(node, depth);\n          }\n          rowsToUpdate.push([node.id, {\n            index: index++,\n            node,\n            depth\n          }]);\n        }\n      }\n    }\n    this.rows = new Map(rowsToUpdate);\n    this.updateScrollToRow();\n  }\n\n  protected shouldDisplayNode(node: TreeNode): boolean {\n    return TreeNode.isVisible(node) && (!this.searchBox?.isFiltering || this.treeSearch.passesFilters(node));\n  }\n\n  /**\n   * Update the `scrollToRow`.\n   * @param updateOptions the tree widget force update options.\n   */\n  protected updateScrollToRow(updateOptions?: TreeWidget.ForceUpdateOptions): void {\n    this.scrollToRow = this.getScrollToRow();\n    this.forceUpdate(updateOptions);\n  }\n\n  /**\n   * Get the `scrollToRow`.\n   *\n   * @returns the `scrollToRow` if available.\n   */\n  protected getScrollToRow(): number | undefined {\n    if (!this.shouldScrollToRow) {\n      return undefined;\n    }\n    const selected = this.model.selectedNodes;\n    const node: TreeNode | undefined = selected.find(SelectableTreeNode.hasFocus) || selected[0];\n    const row = node && this.rows.get(node.id);\n    return row && row.index;\n  }\n\n  protected async doUpdateDecorations(): Promise<void> {\n    this.decorations = await this.decoratorService.getDecorations(this.model);\n    this.forceUpdate();\n  }\n\n  /**\n   * Force deep resizing and rendering of rows.\n   * https://github.com/bvaughn/react-virtualized/blob/master/docs/List.md#recomputerowheights-index-number\n   */\n  protected forceUpdate({resize}: TreeWidget.ForceUpdateOptions = {resize: false}): void {\n    if (this.view && this.view.list) {\n      if (resize && this.isVisible) {\n        this.view.cache.clearAll();\n        this.view.list.recomputeRowHeights();\n      } else {\n        this.view.list.forceUpdateGrid();\n      }\n    }\n    this.update();\n  }\n\n  protected onActivateRequest(msg: Message): void {\n    super.onActivateRequest(msg);\n    this.node.focus({preventScroll: true});\n  }\n\n  /**\n   * Actually focus the tree node.\n   */\n  protected doFocus(): void {\n    if (!this.model.selectedNodes.length) {\n      const node = this.getNodeToFocus();\n      if (SelectableTreeNode.is(node)) {\n        this.model.selectNode(node);\n      }\n    }\n    // It has to be called after nodes are selected.\n    if (this.props.globalSelection) {\n      this.updateGlobalSelection();\n    }\n    this.forceUpdate();\n  }\n\n  /**\n   * Get the tree node to focus.\n   *\n   * @returns the node to focus if available.\n   */\n  protected getNodeToFocus(): SelectableTreeNode | undefined {\n    const root = this.model.root;\n    if (SelectableTreeNode.isVisible(root)) {\n      return root;\n    }\n    return this.model.getNextSelectableNode(root);\n  }\n\n  protected onUpdateRequest(msg: Message): void {\n    if (!this.isAttached) {\n      // if (!this.isAttached || !this.isVisible) {\n      return;\n    }\n    super.onUpdateRequest(msg);\n  }\n\n  protected onResize(msg: Widget.ResizeMessage): void {\n    super.onResize(msg);\n    this.forceUpdate({resize: true});\n  }\n\n  protected render(): React.ReactNode {\n    return React.createElement('div', this.createContainerAttributes(), this.renderTree(this.model));\n  }\n\n  /**\n   * Create the container attributes for the widget.\n   */\n  protected createContainerAttributes(): React.HTMLAttributes<HTMLElement> {\n    const classNames = [TREE_CONTAINER_CLASS];\n    if (!this.rows.size) {\n      classNames.push('empty');\n    }\n    return {\n      className: classNames.join(' '),\n      onContextMenu: event => this.handleContextMenuEvent(this.getContainerTreeNode(), event)\n    };\n  }\n\n  /**\n   * Get the container tree node.\n   *\n   * @returns the tree node for the container if available.\n   */\n  protected getContainerTreeNode(): TreeNode | undefined {\n    return this.model.root;\n  }\n\n  /**\n   * Render the tree widget.\n   * @param model the tree model.\n   */\n  protected renderTree(model: TreeModel): React.ReactNode {\n    if (model.root) {\n      const rows = Array.from(this.rows.values());\n      if (this.props.virtualized === false) {\n        this.onRender.push(Disposable.create(() => this.scrollToSelected()));\n        return rows.map(row => <div key={row.index}>{this.renderNodeRow(row)}</div>);\n      }\n      return <TreeWidget.View\n          ref={view => this.view = (view || undefined)}\n          width={this.node.offsetWidth}\n          height={this.node.offsetHeight}\n          rows={rows}\n          renderNodeRow={this.renderNodeRow}\n          scrollToRow={this.scrollToRow}\n          handleScroll={this.handleScroll}\n      />;\n    }\n    // eslint-disable-next-line no-null/no-null\n    return null;\n  }\n\n  /**\n   * Scroll to the selected tree node.\n   */\n  protected scrollToSelected(): void {\n    if (this.props.scrollIfActive === true && !this.node.contains(document.activeElement)) {\n      return;\n    }\n    const focus = this.node.getElementsByClassName(FOCUS_CLASS)[0];\n    if (focus) {\n      ElementExt.scrollIntoViewIfNeeded(this.scrollArea, focus);\n    } else {\n      const selected = this.node.getElementsByClassName(SELECTED_CLASS)[0];\n      if (selected) {\n        ElementExt.scrollIntoViewIfNeeded(this.scrollArea, selected);\n      }\n    }\n  }\n\n  /**\n   * Handle the scroll event.\n   */\n  protected readonly handleScroll = (info: ScrollParams) => {\n    this.node.scrollTop = info.scrollTop;\n  };\n\n  /**\n   * Render the node row.\n   */\n  protected readonly renderNodeRow = (row: TreeWidget.NodeRow) => this.doRenderNodeRow(row);\n\n  /**\n   * Actually render the node row.\n   */\n  protected doRenderNodeRow({index, node, depth}: TreeWidget.NodeRow): React.ReactNode {\n    return <React.Fragment>\n      {this.renderIndent(node, {depth})}\n      {this.renderNode(node, {depth})}\n    </React.Fragment>;\n  }\n\n  /**\n   * Render the tree node given the node properties.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected renderIcon(node: TreeNode, props: NodeProps): React.ReactNode {\n    // eslint-disable-next-line no-null/no-null\n    return null;\n  }\n\n  /**\n   * Toggle the node.\n   */\n  protected readonly toggle = (event: React.MouseEvent<HTMLElement>) => this.doToggle(event);\n\n  /**\n   * Actually toggle the tree node.\n   * @param event the mouse click event.\n   */\n  protected doToggle(event: React.MouseEvent<HTMLElement>): void {\n    const nodeId = event.currentTarget.getAttribute('data-node-id');\n    if (nodeId) {\n      const node = this.model.getNode(nodeId);\n      if (node && this.props.expandOnlyOnExpansionToggleClick) {\n        if (this.isExpandable(node) && !this.hasShiftMask(event) && !this.hasCtrlCmdMask(event)) {\n          this.model.toggleNodeExpansion(node);\n        }\n      } else {\n        this.handleClickEvent(node, event);\n      }\n    }\n    event.stopPropagation();\n  }\n\n  /**\n   * Render the node expansion toggle.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected renderExpansionToggle(node: TreeNode, props: NodeProps): React.ReactNode {\n    if (!this.isExpandable(node)) {\n      // eslint-disable-next-line no-null/no-null\n      return null;\n    }\n    const classes = [TREE_NODE_SEGMENT_CLASS, EXPANSION_TOGGLE_CLASS];\n    if (!node.expanded) {\n      classes.push(COLLAPSED_CLASS);\n    }\n    if (node.busy) {\n      classes.push(BUSY_CLASS, ...CODICON_LOADING_CLASSES);\n    } else {\n      classes.push(...CODICON_TREE_ITEM_CLASSES);\n    }\n    const className = classes.join(' ');\n    return <div\n        data-node-id={node.id}\n        className={className}\n        onClick={this.toggle}\n        onDoubleClick={this.handleExpansionToggleDblClickEvent}>\n    </div>;\n  }\n\n  /**\n   * Render the tree node caption given the node properties.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected renderCaption(node: TreeNode, props: NodeProps): React.ReactNode {\n    const tooltip = this.getDecorationData(node, 'tooltip').filter(notEmpty).join(' â€¢ ');\n    const classes = [TREE_NODE_SEGMENT_CLASS];\n    if (!this.hasTrailingSuffixes(node)) {\n      classes.push(TREE_NODE_SEGMENT_GROW_CLASS);\n    }\n    const className = classes.join(' ');\n    let attrs = this.decorateCaption(node, {\n      className, id: node.id\n    });\n    if (tooltip.length > 0) {\n      attrs = {\n        ...attrs,\n        title: tooltip\n      };\n    }\n    const children: React.ReactNode[] = [];\n    const caption = this.toNodeName(node);\n    const highlight = this.getDecorationData(node, 'highlight')[0];\n    if (highlight) {\n      children.push(this.toReactNode(caption, highlight));\n    }\n    const searchHighlight = this.searchHighlights ? this.searchHighlights.get(node.id) : undefined;\n    if (searchHighlight) {\n      children.push(...this.toReactNode(caption, searchHighlight));\n    } else if (!highlight) {\n      children.push(caption);\n    }\n    return React.createElement('div', attrs, ...children);\n  }\n\n  /**\n   * Update the node given the caption and highlight.\n   * @param caption the caption.\n   * @param highlight the tree decoration caption highlight.\n   */\n  protected toReactNode(caption: string, highlight: TreeDecoration.CaptionHighlight): React.ReactNode[] {\n    let style: React.CSSProperties = {};\n    if (highlight.color) {\n      style = {\n        ...style,\n        color: highlight.color\n      };\n    }\n    if (highlight.backgroundColor) {\n      style = {\n        ...style,\n        backgroundColor: highlight.backgroundColor\n      };\n    }\n    const createChildren = (fragment: TreeDecoration.CaptionHighlight.Fragment, index: number) => {\n      const {data} = fragment;\n      if (fragment.highlight) {\n        return <mark className={TreeDecoration.Styles.CAPTION_HIGHLIGHT_CLASS} style={style}\n                     key={index}>{data}</mark>;\n      } else {\n        return data;\n      }\n    };\n    return TreeDecoration.CaptionHighlight.split(caption, highlight).map(createChildren);\n  }\n\n  /**\n   * Decorate the tree caption.\n   * @param node the tree node.\n   * @param attrs the additional attributes.\n   */\n  protected decorateCaption(node: TreeNode, attrs: React.HTMLAttributes<HTMLElement>): React.Attributes & React.HTMLAttributes<HTMLElement> {\n    const style = this.getDecorationData(node, 'fontData')\n        .filter(notEmpty)\n        .reverse()\n        .map(fontData => this.applyFontStyles({}, fontData))\n        .reduce((acc, current) => ({\n          ...acc,\n          ...current\n        }), {});\n    return {\n      ...attrs,\n      style\n    };\n  }\n\n  /**\n   * Determine if the tree node contains trailing suffixes.\n   * @param node the tree node.\n   *\n   * @returns `true` if the tree node contains trailing suffices.\n   */\n  protected hasTrailingSuffixes(node: TreeNode): boolean {\n    return this.getDecorationData(node, 'captionSuffixes').filter(notEmpty).reduce((acc, current) => acc.concat(current), []).length > 0;\n  }\n\n  /**\n   * Apply font styles to the tree.\n   * @param original the original css properties.\n   * @param fontData the optional `fontData`.\n   */\n  protected applyFontStyles(original: React.CSSProperties, fontData: TreeDecoration.FontData | undefined): React.CSSProperties {\n    if (fontData === undefined) {\n      return original;\n    }\n    const modified = {...original}; // make a copy to mutate\n    const {color, style} = fontData;\n    if (color) {\n      modified.color = color;\n    }\n    if (style) {\n      (Array.isArray(style) ? style : [style]).forEach(s => {\n        switch (s) {\n          case 'bold':\n            modified.fontWeight = s;\n            break;\n          case 'normal':\n          case 'oblique':\n          case 'italic':\n            modified.fontStyle = s;\n            break;\n          case 'underline':\n          case 'line-through':\n            modified.textDecoration = s;\n            break;\n          default:\n            throw new Error(`Unexpected font style: \"${s}\".`);\n        }\n      });\n    }\n    return modified;\n  }\n\n  /**\n   * Render caption affixes for the given tree node.\n   * @param node the tree node.\n   * @param props the node properties.\n   * @param affixKey the affix key.\n   */\n  protected renderCaptionAffixes(node: TreeNode, props: NodeProps, affixKey: 'captionPrefixes' | 'captionSuffixes'): React.ReactNode {\n    const suffix = affixKey === 'captionSuffixes';\n    const affixClass = suffix ? TreeDecoration.Styles.CAPTION_SUFFIX_CLASS : TreeDecoration.Styles.CAPTION_PREFIX_CLASS;\n    const classes = [TREE_NODE_SEGMENT_CLASS, affixClass];\n    const affixes = this.getDecorationData(node, affixKey).filter(notEmpty).reduce((acc, current) => acc.concat(current), []);\n    const children: React.ReactNode[] = [];\n    for (let i = 0; i < affixes.length; i++) {\n      const affix = affixes[i];\n      if (suffix && i === affixes.length - 1) {\n        classes.push(TREE_NODE_SEGMENT_GROW_CLASS);\n      }\n      const style = this.applyFontStyles({}, affix.fontData);\n      const className = classes.join(' ');\n      const key = node.id + '_' + i;\n      const attrs = {\n        className,\n        style,\n        key\n      };\n      children.push(React.createElement('div', attrs, affix.data));\n    }\n    return <React.Fragment>{children}</React.Fragment>;\n  }\n\n  /**\n   * Decorate the tree node icon.\n   * @param node the tree node.\n   * @param icon the icon.\n   */\n  protected decorateIcon(node: TreeNode, icon: React.ReactNode): React.ReactNode {\n    if (!icon) {\n      return;\n    }\n    const overlayIcons: React.ReactNode[] = [];\n    // if multiple overlays have the same overlay.position attribute, we'll de-duplicate those and only process the first one from the decoration array\n    const seenPositions = new Set<TreeDecoration.IconOverlayPosition>();\n    const overlays = this.getDecorationData(node, 'iconOverlay').filter(notEmpty);\n\n    for (const overlay of overlays) {\n      if (!seenPositions.has(overlay.position)) {\n        seenPositions.add(overlay.position);\n        const iconClasses = [TreeDecoration.Styles.DECORATOR_SIZE_CLASS, TreeDecoration.IconOverlayPosition.getStyle(overlay.position)];\n        const style = (color?: string) => color === undefined ? {} : {color};\n\n        if (overlay.background) {\n          overlayIcons.push(<span key={node.id + 'bg'}\n                                  className={this.getIconClass(overlay.background.shape, iconClasses)}\n                                  style={style(overlay.background.color)}></span>);\n        }\n\n        const overlayIcon = 'icon' in overlay ? overlay.icon : overlay.iconClass;\n        overlayIcons.push(<span key={node.id} className={this.getIconClass(overlayIcon, iconClasses)}\n                                style={style(overlay.color)}></span>);\n      }\n    }\n\n    if (overlayIcons.length > 0) {\n      return <div className={TreeDecoration.Styles.ICON_WRAPPER_CLASS}>{icon}{overlayIcons}</div>;\n    }\n\n    return icon;\n  }\n\n  /**\n   * Render the tree node tail decorations.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected renderTailDecorations(node: TreeNode, props: NodeProps): React.ReactNode {\n    const tailDecorations = this.getDecorationData(node, 'tailDecorations').filter(notEmpty).reduce((acc, current) => acc.concat(current), []);\n    if (tailDecorations.length === 0) {\n      return;\n    }\n    return this.renderTailDecorationsForNode(node, props, tailDecorations);\n  }\n\n  protected renderTailDecorationsForNode(node: TreeNode, props: NodeProps, tailDecorations:\n      (TreeDecoration.TailDecoration | TreeDecoration.TailDecorationIcon | TreeDecoration.TailDecorationIconClass)[]): React.ReactNode {\n    return <React.Fragment>\n      {tailDecorations.map((decoration, index) => {\n        const {tooltip} = decoration;\n        const {data, fontData} = decoration as TreeDecoration.TailDecoration;\n        const color = (decoration as TreeDecoration.TailDecorationIcon).color;\n        const className = [TREE_NODE_SEGMENT_CLASS, TREE_NODE_TAIL_CLASS].join(' ');\n        const style = fontData ? this.applyFontStyles({}, fontData) : color ? {color} : undefined;\n        const icon = (decoration as TreeDecoration.TailDecorationIcon).icon || (decoration as TreeDecoration.TailDecorationIconClass).iconClass;\n        const content = data ? data : icon ?\n            <span key={node.id + 'icon' + index} className={this.getIconClass(icon)}></span> : '';\n        return <div key={node.id + className + index} className={className} style={style} title={tooltip}>\n          {content}\n        </div>;\n      })}\n    </React.Fragment>;\n  }\n\n  /**\n   * Determine the classes to use for an icon\n   * - Assumes a Font Awesome name when passed a single string, otherwise uses the passed string array\n   * @param iconName the icon name or list of icon names.\n   * @param additionalClasses additional CSS classes.\n   *\n   * @returns the icon class name.\n   */\n  protected getIconClass(iconName: string | string[], additionalClasses: string[] = []): string {\n    const iconClass = (typeof iconName === 'string') ? ['a', 'fa', `fa-${iconName}`] : ['a'].concat(iconName);\n    return iconClass.concat(additionalClasses).join(' ');\n  }\n\n  /**\n   * Render indent for the file tree based on the depth\n   * @param node the tree node.\n   * @param depth the depth of the tree node.\n   */\n  protected renderIndent(node: TreeNode, props: NodeProps): React.ReactNode {\n    const renderIndentGuides = this.corePreferences['workbench.tree.renderIndentGuides'];\n    if (renderIndentGuides === 'none') {\n      return undefined;\n    }\n\n    const indentDivs: React.ReactNode[] = [];\n    let current: TreeNode | undefined = node;\n    let depth = props.depth;\n    while (current && depth) {\n      const classNames: string[] = [TREE_NODE_INDENT_GUIDE_CLASS];\n      if (this.needsActiveIndentGuideline(current)) {\n        classNames.push('active');\n      } else {\n        classNames.push(renderIndentGuides === 'onHover' ? 'hover' : 'always');\n      }\n      const paddingLeft = this.props.leftPadding * depth;\n      indentDivs.unshift(<div key={depth} className={classNames.join(' ')} style={{\n        paddingLeft: `${paddingLeft}px`\n      }}/>);\n      current = current.parent;\n      depth--;\n    }\n    return indentDivs;\n  }\n\n  protected needsActiveIndentGuideline(node: TreeNode): boolean {\n    const parent = node.parent;\n    if (!parent || !this.isExpandable(parent)) {\n      return false;\n    }\n    if (SelectableTreeNode.isSelected(parent)) {\n      return true;\n    }\n    if (parent.expanded) {\n      for (const sibling of parent.children) {\n        if (SelectableTreeNode.isSelected(sibling) && !(this.isExpandable(sibling) && sibling.expanded)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Render the node given the tree node and node properties.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected renderNode(node: TreeNode, props: NodeProps): React.ReactNode {\n    if (!TreeNode.isVisible(node)) {\n      return undefined;\n    }\n    const attributes = this.createNodeAttributes(node, props);\n    const content = <div className={TREE_NODE_CONTENT_CLASS}>\n      {this.renderExpansionToggle(node, props)}\n      {this.decorateIcon(node, this.renderIcon(node, props))}\n      {this.renderCaptionAffixes(node, props, 'captionPrefixes')}\n      {this.renderCaption(node, props)}\n      {this.renderCaptionAffixes(node, props, 'captionSuffixes')}\n      {this.renderTailDecorations(node, props)}\n    </div>;\n    return React.createElement('div', attributes, content);\n  }\n\n  /**\n   * Create node attributes for the tree node given the node properties.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected createNodeAttributes(node: TreeNode, props: NodeProps): React.Attributes & React.HTMLAttributes<HTMLElement> {\n    const className = this.createNodeClassNames(node, props).join(' ');\n    const style = this.createNodeStyle(node, props);\n    return {\n      className,\n      style,\n      onClick: event => this.handleClickEvent(node, event),\n      onDoubleClick: event => this.handleDblClickEvent(node, event),\n      onContextMenu: event => this.handleContextMenuEvent(node, event)\n    };\n  }\n\n  /**\n   * Create the node class names.\n   * @param node the tree node.\n   * @param props the node properties.\n   *\n   * @returns the list of tree node class names.\n   */\n  protected createNodeClassNames(node: TreeNode, props: NodeProps): string[] {\n    const classNames = [TREE_NODE_CLASS];\n    if (CompositeTreeNode.is(node)) {\n      classNames.push(COMPOSITE_TREE_NODE_CLASS);\n    }\n    if (this.isExpandable(node)) {\n      classNames.push(EXPANDABLE_TREE_NODE_CLASS);\n    }\n    if (SelectableTreeNode.isSelected(node)) {\n      classNames.push(SELECTED_CLASS);\n    }\n    if (SelectableTreeNode.hasFocus(node)) {\n      classNames.push(FOCUS_CLASS);\n    }\n    return classNames;\n  }\n\n  /**\n   * Get the default node style.\n   * @param node the tree node.\n   * @param props the node properties.\n   *\n   * @returns the CSS properties if available.\n   */\n  protected getDefaultNodeStyle(node: TreeNode, props: NodeProps): React.CSSProperties | undefined {\n    const paddingLeft = this.getPaddingLeft(node, props) + 'px';\n    return {paddingLeft};\n  }\n\n  protected getPaddingLeft(node: TreeNode, props: NodeProps): number {\n    return props.depth * this.props.leftPadding + (this.needsExpansionTogglePadding(node) ? this.props.expansionTogglePadding : 0);\n  }\n\n  /**\n   * If the node is a composite, a toggle will be rendered.\n   * Otherwise we need to add the width and the left, right padding => 18px\n   */\n  protected needsExpansionTogglePadding(node: TreeNode): boolean {\n    return !this.isExpandable(node);\n  }\n\n  /**\n   * Create the tree node style.\n   * @param node the tree node.\n   * @param props the node properties.\n   */\n  protected createNodeStyle(node: TreeNode, props: NodeProps): React.CSSProperties | undefined {\n    return this.decorateNodeStyle(node, this.getDefaultNodeStyle(node, props));\n  }\n\n  /**\n   * Decorate the node style.\n   * @param node the tree node.\n   * @param style the optional CSS properties.\n   *\n   * @returns the CSS styles if available.\n   */\n  protected decorateNodeStyle(node: TreeNode, style: React.CSSProperties | undefined): React.CSSProperties | undefined {\n    const backgroundColor = this.getDecorationData(node, 'backgroundColor').filter(notEmpty).shift();\n    if (backgroundColor) {\n      style = {\n        ...(style || {}),\n        backgroundColor\n      };\n    }\n    return style;\n  }\n\n  /**\n   * Determine if the tree node is expandable.\n   * @param node the tree node.\n   *\n   * @returns `true` if the tree node is expandable.\n   */\n  protected isExpandable(node: TreeNode): node is ExpandableTreeNode {\n    return ExpandableTreeNode.is(node);\n  }\n\n  /**\n   * Get the tree node decorations.\n   * @param node the tree node.\n   *\n   * @returns the list of tree decoration data.\n   */\n  protected getDecorations(node: TreeNode): TreeDecoration.Data[] {\n    const decorations: TreeDecoration.Data[] = [];\n    if (DecoratedTreeNode.is(node)) {\n      decorations.push(node.decorationData);\n    }\n    if (this.decorations.has(node.id)) {\n      decorations.push(...this.decorations.get(node.id)!);\n    }\n    return decorations.sort(TreeDecoration.Data.comparePriority);\n  }\n\n  /**\n   * Get the tree decoration data for the given key.\n   * @param node the tree node.\n   * @param key the tree decoration data key.\n   *\n   * @returns the tree decoration data at the given key.\n   */\n  protected getDecorationData<K extends keyof TreeDecoration.Data>(node: TreeNode, key: K): TreeDecoration.Data[K][] {\n    return this.getDecorations(node).filter(data => data[key] !== undefined).map(data => data[key]).filter(notEmpty);\n  }\n\n  /**\n   * Get the scroll container.\n   */\n  protected getScrollContainer(): MaybePromise<HTMLElement> {\n    this.toDisposeOnDetach.push(Disposable.create(() => {\n      const {scrollTop, scrollLeft} = this.node;\n      this.lastScrollState = {scrollTop, scrollLeft};\n    }));\n    if (this.lastScrollState) {\n      const {scrollTop, scrollLeft} = this.lastScrollState;\n      this.node.scrollTop = scrollTop;\n      this.node.scrollLeft = scrollLeft;\n    }\n    return this.node;\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    const up = [\n      Key.ARROW_UP,\n      KeyCode.createKeyCode({first: Key.ARROW_UP, modifiers: [KeyModifier.Shift]})\n    ];\n    const down = [\n      Key.ARROW_DOWN,\n      KeyCode.createKeyCode({first: Key.ARROW_DOWN, modifiers: [KeyModifier.Shift]})\n    ];\n    if (this.props.search) {\n      if (this.searchBox.isAttached) {\n        Widget.detach(this.searchBox);\n      }\n      UnsafeWidgetUtilities.attach(this.searchBox, this.node.parentElement!);\n      this.addKeyListener(this.node, this.searchBox.keyCodePredicate.bind(this.searchBox), this.searchBox.handle.bind(this.searchBox));\n      this.toDisposeOnDetach.push(Disposable.create(() => {\n        Widget.detach(this.searchBox);\n      }));\n    }\n    super.onAfterAttach(msg);\n    this.addKeyListener(this.node, Key.ARROW_LEFT, event => this.handleLeft(event));\n    this.addKeyListener(this.node, Key.ARROW_RIGHT, event => this.handleRight(event));\n    this.addKeyListener(this.node, up, event => this.handleUp(event));\n    this.addKeyListener(this.node, down, event => this.handleDown(event));\n    this.addKeyListener(this.node, Key.ENTER, event => this.handleEnter(event));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.addEventListener<any>(this.node, 'ps-scroll-y', (e: Event & { target: { scrollTop: number } }) => {\n      if (this.view && this.view.list && this.view.list.Grid) {\n        const {scrollTop} = e.target;\n        this.view.list.Grid.handleScrollEvent({scrollTop});\n      }\n    });\n    this.addEventListener(this.node, 'focus', () => this.doFocus());\n  }\n\n  /**\n   * Handle the `left arrow` keyboard event.\n   * @param event the `left arrow` keyboard event.\n   */\n  protected async handleLeft(event: KeyboardEvent): Promise<void> {\n    if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n      return;\n    }\n    if (!await this.model.collapseNode()) {\n      this.model.selectParent();\n    }\n  }\n\n  /**\n   * Handle the `right arrow` keyboard event.\n   * @param event the `right arrow` keyboard event.\n   */\n  protected async handleRight(event: KeyboardEvent): Promise<void> {\n    if (!!this.props.multiSelect && (this.hasCtrlCmdMask(event) || this.hasShiftMask(event))) {\n      return;\n    }\n    if (!await this.model.expandNode()) {\n      this.model.selectNextNode();\n    }\n  }\n\n  /**\n   * Handle the `up arrow` keyboard event.\n   * @param event the `up arrow` keyboard event.\n   */\n  protected handleUp(event: KeyboardEvent): void {\n    if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n      this.model.selectPrevNode(TreeSelection.SelectionType.RANGE);\n    } else {\n      this.model.selectPrevNode();\n    }\n  }\n\n  /**\n   * Handle the `down arrow` keyboard event.\n   * @param event the `down arrow` keyboard event.\n   */\n  protected handleDown(event: KeyboardEvent): void {\n    if (!!this.props.multiSelect && this.hasShiftMask(event)) {\n      this.model.selectNextNode(TreeSelection.SelectionType.RANGE);\n    } else {\n      this.model.selectNextNode();\n    }\n  }\n\n  /**\n   * Handle the `enter key` keyboard event.\n   * - `enter` opens the tree node.\n   * @param event the `enter key` keyboard event.\n   */\n  protected handleEnter(event: KeyboardEvent): void {\n    this.model.openNode();\n  }\n\n  /**\n   * Handle the single-click mouse event.\n   * @param node the tree node if available.\n   * @param event the mouse single-click event.\n   */\n  protected handleClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n    if (node) {\n      const shiftMask = this.hasShiftMask(event);\n      const ctrlCmdMask = this.hasCtrlCmdMask(event);\n      if (!!this.props.multiSelect) {\n        if (SelectableTreeNode.is(node)) {\n          if (shiftMask) {\n            this.model.selectRange(node);\n          } else if (ctrlCmdMask) {\n            this.model.toggleNode(node);\n          } else {\n            this.model.selectNode(node);\n          }\n        }\n      } else {\n        if (SelectableTreeNode.is(node)) {\n          this.model.selectNode(node);\n        }\n      }\n      if (!this.props.expandOnlyOnExpansionToggleClick) {\n        if (this.isExpandable(node) && !shiftMask && !ctrlCmdMask) {\n          this.model.toggleNodeExpansion(node);\n        }\n      }\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Handle the double-click mouse event.\n   * @param node the tree node if available.\n   * @param event the double-click mouse event.\n   */\n  protected handleDblClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n    this.model.openNode(node);\n    event.stopPropagation();\n  }\n\n  /**\n   * Handle the context menu click event.\n   * - The context menu click event is triggered by the right-click.\n   * @param node the tree node if available.\n   * @param event the right-click mouse event.\n   */\n  protected handleContextMenuEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\n    if (SelectableTreeNode.is(node)) {\n      // Keep the selection for the context menu, if the widget support multi-selection and the right click happens on an already selected node.\n      if (!this.props.multiSelect || !node.selected) {\n        const type = !!this.props.multiSelect && this.hasCtrlCmdMask(event) ? TreeSelection.SelectionType.TOGGLE : TreeSelection.SelectionType.DEFAULT;\n        this.model.addSelection({node, type});\n      }\n      const contextMenuPath = this.props.contextMenuPath;\n      if (contextMenuPath) {\n        const {x, y} = event.nativeEvent;\n        const args = this.toContextMenuArgs(node);\n        this.onRender.push(Disposable.create(() =>\n            setTimeout(() => this.contextMenuRenderer.render({\n              menuPath: contextMenuPath,\n              anchor: {x, y},\n              args\n            }))\n        ));\n      }\n      this.doFocus();\n    }\n    event.stopPropagation();\n    event.preventDefault();\n  }\n\n  /**\n   * Handle the double-click mouse event on the expansion toggle.\n   */\n  protected readonly handleExpansionToggleDblClickEvent = (event: React.MouseEvent<HTMLElement>) => this.doHandleExpansionToggleDblClickEvent(event);\n\n  /**\n   * Actually handle the double-click mouse event on the expansion toggle.\n   * @param event the double-click mouse event.\n   */\n  protected doHandleExpansionToggleDblClickEvent(event: React.MouseEvent<HTMLElement>): void {\n    if (this.props.expandOnlyOnExpansionToggleClick) {\n      // Ignore the double-click event.\n      event.stopPropagation();\n    }\n  }\n\n  /**\n   * Convert the tree node to context menu arguments.\n   * @param node the selectable tree node.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected toContextMenuArgs(node: SelectableTreeNode): any[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * Determine if the tree modifier aware event has a `ctrlcmd` mask.\n   * @param event the tree modifier aware event.\n   *\n   * @returns `true` if the tree modifier aware event contains the `ctrlcmd` mask.\n   */\n  protected hasCtrlCmdMask(event: TreeWidget.ModifierAwareEvent): boolean {\n    const {metaKey, ctrlKey} = event;\n    return (isOSX && metaKey) || ctrlKey;\n  }\n\n  /**\n   * Determine if the tree modifier aware event has a `shift` mask.\n   * @param event the tree modifier aware event.\n   *\n   * @returns `true` if the tree modifier aware event contains the `shift` mask.\n   */\n  protected hasShiftMask(event: TreeWidget.ModifierAwareEvent): boolean {\n    // Ctrl/Cmd mask overrules the Shift mask.\n    if (this.hasCtrlCmdMask(event)) {\n      return false;\n    }\n    return event.shiftKey;\n  }\n\n  /**\n   * Deflate the tree node for storage.\n   * @param node the tree node.\n   */\n  protected deflateForStorage(node: TreeNode): object {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const copy = Object.assign({}, node) as any;\n    if (copy.parent) {\n      delete copy.parent;\n    }\n    if ('previousSibling' in copy) {\n      delete copy.previousSibling;\n    }\n    if ('nextSibling' in copy) {\n      delete copy.nextSibling;\n    }\n    if ('busy' in copy) {\n      delete copy.busy;\n    }\n    if (CompositeTreeNode.is(node)) {\n      copy.children = [];\n      for (const child of node.children) {\n        copy.children.push(this.deflateForStorage(child));\n      }\n    }\n    return copy;\n  }\n\n  /**\n   * Inflate the tree node from storage.\n   * @param node the tree node.\n   * @param parent the optional tree node.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected inflateFromStorage(node: any, parent?: TreeNode): TreeNode {\n    if (node.selected) {\n      node.selected = false;\n    }\n    if (parent) {\n      node.parent = parent;\n    }\n    if (Array.isArray(node.children)) {\n      for (const child of node.children as TreeNode[]) {\n        this.inflateFromStorage(child, node);\n      }\n    }\n    return node;\n  }\n\n  protected toNodeIcon(node: TreeNode): string {\n    return this.labelProvider.getIcon(node);\n  }\n\n  protected toNodeName(node: TreeNode): string {\n    return this.labelProvider.getName(node);\n  }\n\n  protected toNodeDescription(node: TreeNode): string {\n    return this.labelProvider.getLongName(node);\n  }\n\n}\n\nexport namespace TreeWidget {\n  /**\n   * Representation of the tree force update options.\n   */\n  export interface ForceUpdateOptions {\n    /**\n     * Controls whether to force a resize of the widget.\n     */\n    resize: boolean\n  }\n\n  /**\n   * Representation of a tree node row.\n   */\n  export interface NodeRow {\n    /**\n     * The node row index.\n     */\n    index: number\n    /**\n     * The actual node.\n     */\n    node: TreeNode\n    /**\n     * A root relative number representing the hierarchical depth of the actual node. Root is `0`, its children have `1` and so on.\n     */\n    depth: number\n  }\n\n  /**\n   * Representation of the tree view properties.\n   */\n  export interface ViewProps {\n    /**\n     * The width property.\n     */\n    width: number\n    /**\n     * The height property.\n     */\n    height: number\n    /**\n     * The scroll to row value.\n     */\n    scrollToRow?: number\n    /**\n     * The list of node rows.\n     */\n    rows: NodeRow[]\n    handleScroll: (info: ScrollParams) => void\n    renderNodeRow: (row: NodeRow) => React.ReactNode\n  }\n\n  export class View extends React.Component<ViewProps> {\n    list: List | undefined;\n    readonly cache = new CellMeasurerCache({\n      fixedWidth: true\n    });\n\n    render(): React.ReactNode {\n      const {rows, width, height, scrollToRow, handleScroll} = this.props;\n      return <div>\n        {\n          console.log('loading') === undefined ? <div style={{height: '1px'}}/> : <div/>\n        }\n        <List\n            ref={list => this.list = (list || undefined)}\n            width={width}\n            height={height}\n            rowCount={rows.length}\n            rowHeight={this.cache.rowHeight}\n            rowRenderer={this.renderTreeRow}\n            scrollToIndex={scrollToRow}\n            onScroll={handleScroll}\n            tabIndex={-1}\n        />\n      </div>;\n    }\n\n    protected renderTreeRow: ListRowRenderer = ({key, index, style, parent}) => {\n      const row = this.props.rows[index]!;\n      return <CellMeasurer\n          cache={this.cache}\n          columnIndex={0}\n          key={key}\n          parent={parent}\n          rowIndex={index}>\n        <div key={key} style={style}>{this.props.renderNodeRow(row)}</div>\n      </CellMeasurer>;\n    };\n  }\n}\n"]}