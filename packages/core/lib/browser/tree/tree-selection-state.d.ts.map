{"version":3,"sources":["browser/tree/tree-selection-state.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAElF,OAAO,EAAC,IAAI,EAAE,QAAQ,EAAC,MAAM,QAAQ,CAAC;AAEtC,OAAO,EAAC,kBAAkB,EAAE,aAAa,EAAC,MAAM,kBAAkB,CAAC;AAEnE;;GAEG;AACH,MAAM,WAAW,sBAAuB,SAAQ,aAAa;IAE3D;;;OAGG;IACH,QAAQ,CAAC,KAAK,CAAC,EAAE,kBAAkB,CAAC;CAErC;AAED,yBAAiB,sBAAsB,CAAC;IAEtC;;OAEG;IACH,SAAgB,EAAE,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,GAAG,GAAG,IAAI,sBAAsB,CAEzE;IAED;;;OAGG;IACH,SAAgB,KAAK,CAAC,GAAG,EAAE,aAAa,GAAG,SAAS,GAAG,kBAAkB,GAAG,SAAS,CAEpF;CACF;AAED;;GAEG;AACH,qBAAa,kBAAkB;IAGzB,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI;IAC7B,QAAQ,CAAC,cAAc,EAAE,aAAa,CAAC,sBAAsB,CAAC;gBAD3C,IAAI,EAAE,IAAI,EACpB,cAAc,GAAE,aAAa,CAAC,sBAAsB,CAAM;IAGvE,IAAI,KAAK,IAAI,kBAAkB,GAAG,SAAS,CAI1C;IAED,SAAS,CAAC,SAAS,EAAE,sBAAsB,GAAG,kBAAkB;IAiBhE,SAAS,IAAI,aAAa,CAAC,kBAAkB,CAAC;IAqB9C,SAAS,CAAC,aAAa,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,EAAE,QAAQ,CAAC,kBAAkB,CAAC,GAAG,kBAAkB;IAS1G,SAAS,CAAC,YAAY,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,EAAE,QAAQ,CAAC,kBAAkB,CAAC,GAAG,kBAAkB;IA0BzG,SAAS,CAAC,WAAW,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,EAAE,QAAQ,CAAC,kBAAkB,CAAC,GAAG,kBAAkB;IAyBxG;;;OAGG;IACH,SAAS,CAAC,cAAc,CAAC,SAAS,EAAE,sBAAsB,GAAG,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IAgD3F,SAAS,CAAC,oBAAoB,CAAC,IAAI,EAAE,QAAQ,GAAG,SAAS,GAAG,kBAAkB,GAAG,SAAS;IAgB1F;;OAEG;IACH,SAAS,CAAC,uBAAuB,CAAC,CAAC,SAAS,aAAa,EAAE,UAAU,EAAE,aAAa,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;CAO3G","file":"../../../src/browser/tree/tree-selection-state.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {Tree, TreeNode} from './tree';\nimport {DepthFirstTreeIterator} from './tree-iterator';\nimport {SelectableTreeNode, TreeSelection} from './tree-selection';\n\n/**\n * A tree selection that might contain additional information about the tree node that has the focus.\n */\nexport interface FocusableTreeSelection extends TreeSelection {\n\n  /**\n   * The tree node that has the focus in the tree selection. In case of a range selection,\n   * the `focus` differs from the `node`.\n   */\n  readonly focus?: SelectableTreeNode;\n\n}\n\nexport namespace FocusableTreeSelection {\n\n  /**\n   * `true` if the argument is a focusable tree selection. Otherwise, `false`.\n   */\n  export function is(arg: object | undefined): arg is FocusableTreeSelection {\n    return TreeSelection.is(arg) && 'focus' in arg;\n  }\n\n  /**\n   * Returns with the tree node that has the focus if the argument is a focusable tree selection.\n   * Otherwise, returns `undefined`.\n   */\n  export function focus(arg: TreeSelection | undefined): SelectableTreeNode | undefined {\n    return is(arg) ? arg.focus : undefined;\n  }\n}\n\n/**\n * Class for representing and managing the selection state and the focus of a tree.\n */\nexport class TreeSelectionState {\n\n  constructor(\n      protected readonly tree: Tree,\n      readonly selectionStack: ReadonlyArray<FocusableTreeSelection> = []) {\n  }\n\n  get focus(): SelectableTreeNode | undefined {\n    const copy = this.checkNoDefaultSelection(this.selectionStack);\n    const candidate = copy[copy.length - 1].focus;\n    return this.toSelectableTreeNode(candidate);\n  }\n\n  nextState(selection: FocusableTreeSelection): TreeSelectionState {\n    const {node, type} = {\n      type: TreeSelection.SelectionType.DEFAULT,\n      ...selection\n    };\n    switch (type) {\n      case TreeSelection.SelectionType.DEFAULT:\n        return this.handleDefault(this, node);\n      case TreeSelection.SelectionType.TOGGLE:\n        return this.handleToggle(this, node);\n      case TreeSelection.SelectionType.RANGE:\n        return this.handleRange(this, node);\n      default:\n        throw new Error(`Unexpected tree selection type: ${type}.`);\n    }\n  }\n\n  selection(): ReadonlyArray<SelectableTreeNode> {\n    const copy = this.checkNoDefaultSelection(this.selectionStack);\n    const nodeIds = new Set<string>();\n    for (let i = 0; i < copy.length; i++) {\n      const {node, type} = copy[i];\n      if (TreeSelection.isRange(type)) {\n        const selection = copy[i];\n        for (const id of this.selectionRange(selection).map(n => n.id)) {\n          nodeIds.add(id);\n        }\n      } else if (TreeSelection.isToggle(type)) {\n        if (nodeIds.has(node.id)) {\n          nodeIds.delete(node.id);\n        } else {\n          nodeIds.add(node.id);\n        }\n      }\n    }\n    return Array.from(nodeIds.keys()).map(id => this.tree.getNode(id)).filter(SelectableTreeNode.is).reverse();\n  }\n\n  protected handleDefault(state: TreeSelectionState, node: Readonly<SelectableTreeNode>): TreeSelectionState {\n    const {tree} = state;\n    return new TreeSelectionState(tree, [{\n      node,\n      type: TreeSelection.SelectionType.TOGGLE,\n      focus: node\n    }]);\n  }\n\n  protected handleToggle(state: TreeSelectionState, node: Readonly<SelectableTreeNode>): TreeSelectionState {\n    const {tree, selectionStack} = state;\n    const copy = this.checkNoDefaultSelection(selectionStack).slice();\n    const focus = (() => {\n      const allRanges = copy.filter(selection => TreeSelection.isRange(selection));\n      for (let i = allRanges.length - 1; i >= 0; i--) {\n        const latestRangeIndex = copy.indexOf(allRanges[i]);\n        const latestRangeSelection = copy[latestRangeIndex];\n        const latestRange = latestRangeSelection && latestRangeSelection.focus ? this.selectionRange(latestRangeSelection) : [];\n        if (latestRange.indexOf(node) !== -1) {\n          if (this.focus === latestRangeSelection.focus) {\n            return latestRangeSelection.focus || node;\n          } else {\n            return this.focus;\n          }\n        }\n      }\n      return node;\n    })();\n    return new TreeSelectionState(tree, [...copy, {\n      node,\n      type: TreeSelection.SelectionType.TOGGLE,\n      focus\n    }]);\n  }\n\n  protected handleRange(state: TreeSelectionState, node: Readonly<SelectableTreeNode>): TreeSelectionState {\n    const {tree, selectionStack} = state;\n    const copy = this.checkNoDefaultSelection(selectionStack).slice();\n    let focus = FocusableTreeSelection.focus(copy[copy.length - 1]);\n\n    // Drop the previous range when we are trying to modify that.\n    if (TreeSelection.isRange(copy[copy.length - 1])) {\n      const range = this.selectionRange(copy.pop()!);\n      // And we drop all preceding individual nodes that were contained in the range we are dropping.\n      // That means, anytime we cover individual nodes with a range, they will belong to the range so we need to drop them now.\n      for (let i = copy.length - 1; i >= 0; i--) {\n        if (range.indexOf(copy[i].node) !== -1) {\n          // Make sure to keep a reference to the focus while we are discarding previous elements. Otherwise, we lose this information.\n          focus = copy[i].focus;\n          copy.splice(i, 1);\n        }\n      }\n    }\n    return new TreeSelectionState(tree, [...copy, {\n      node,\n      type: TreeSelection.SelectionType.RANGE,\n      focus\n    }]);\n  }\n\n  /**\n   * Returns with an array of items representing the selection range. The from node is the `focus` the to node\n   * is the selected node itself on the tree selection. Both the `from` node and the `to` node are inclusive.\n   */\n  protected selectionRange(selection: FocusableTreeSelection): Readonly<SelectableTreeNode>[] {\n    const fromNode = selection.focus;\n    const toNode = selection.node;\n    if (fromNode === undefined) {\n      return [];\n    }\n    if (toNode === fromNode) {\n      return [toNode];\n    }\n    const {root} = this.tree;\n    if (root === undefined) {\n      return [];\n    }\n    const to = this.tree.validateNode(toNode);\n    if (to === undefined) {\n      return [];\n    }\n    const from = this.tree.validateNode(fromNode);\n    if (from === undefined) {\n      return [];\n    }\n    let started = false;\n    let finished = false;\n    const range = [];\n    for (const node of new DepthFirstTreeIterator(root, {pruneCollapsed: true})) {\n      if (finished) {\n        break;\n      }\n      // Only collect items which are between (inclusive) the `from` node and the `to` node.\n      if (node === from || node === to) {\n        if (started) {\n          finished = true;\n        } else {\n          started = true;\n        }\n      }\n      if (started) {\n        range.push(node);\n      }\n    }\n\n    // We need to reverse the selection range order.\n    if (range.indexOf(from) > range.indexOf(to)) {\n      range.reverse();\n    }\n    return range.filter(SelectableTreeNode.is);\n  }\n\n  protected toSelectableTreeNode(node: TreeNode | undefined): SelectableTreeNode | undefined {\n    if (!!node) {\n      const candidate = this.tree.getNode(node.id);\n      if (!!candidate) {\n        if (SelectableTreeNode.is(candidate)) {\n          return candidate;\n        } else {\n          console.warn(`Could not map to a selectable tree node. Node with ID: ${node.id} is not a selectable node.`);\n        }\n      } else {\n        console.warn(`Could not map to a selectable tree node. Node does not exist with ID: ${node.id}.`);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Checks whether the argument contains any `DEFAULT` tree selection type. If yes, throws an error, otherwise returns with a reference the argument.\n   */\n  protected checkNoDefaultSelection<T extends TreeSelection>(selections: ReadonlyArray<T>): ReadonlyArray<T> {\n    if (selections.some(selection => selection.type === undefined || selection.type === TreeSelection.SelectionType.DEFAULT)) {\n      throw new Error(`Unexpected DEFAULT selection type. [${selections.map(selection => `ID: ${selection.node.id} | ${selection.type}`).join(', ')}]`);\n    }\n    return selections;\n  }\n\n}\n"]}