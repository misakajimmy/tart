{"version":3,"sources":["browser/tree/tree.ts"],"names":[],"mappings":"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","file":"../../../src/browser/tree/tree.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {injectable} from 'inversify';\nimport {\n  CancellationToken,\n  CancellationTokenSource,\n  Disposable,\n  DisposableCollection,\n  Emitter,\n  Event,\n  Mutable,\n  WaitUntilEvent\n} from '../../common';\nimport {timeout} from '../../common/promise-util';\n\nexport const Tree = Symbol('Tree');\n\n/**\n * The tree - an abstract data type.\n */\nexport interface Tree extends Disposable {\n  /**\n   * A root node of this tree.\n   * Undefined if there is no root node.\n   * Setting a root node refreshes the tree.\n   */\n  root: TreeNode | undefined;\n  /**\n   * Emit when the tree is changed.\n   */\n  readonly onChanged: Event<void>;\n  /**\n   * Emit when the children of the given node are refreshed.\n   */\n  readonly onNodeRefreshed: Event<Readonly<CompositeTreeNode> & WaitUntilEvent>;\n  /**\n   * Emits when the busy state of the given node is changed.\n   */\n  readonly onDidChangeBusy: Event<TreeNode>;\n\n  /**\n   * Return a node for the given identifier or undefined if such does not exist.\n   */\n  getNode(id: string | undefined): TreeNode | undefined;\n\n  /**\n   * Return a valid node in this tree matching to the given; otherwise undefined.\n   */\n  validateNode(node: TreeNode | undefined): TreeNode | undefined;\n\n  /**\n   * Refresh children of the root node.\n   *\n   * Return a valid refreshed composite root or `undefined` if such does not exist.\n   */\n  refresh(): Promise<Readonly<CompositeTreeNode> | undefined>;\n\n  /**\n   * Refresh children of a node for the give node id if it is valid.\n   *\n   * Return a valid refreshed composite node or `undefined` if such does not exist.\n   */\n  refresh(parent: Readonly<CompositeTreeNode>): Promise<Readonly<CompositeTreeNode> | undefined>;\n\n  /**\n   * Marks the give node as busy after a specified number of milliseconds.\n   * A token source of the given token should be canceled to unmark.\n   */\n  markAsBusy(node: Readonly<TreeNode>, ms: number, token: CancellationToken): Promise<void>;\n}\n\n/**\n * The tree node.\n */\nexport interface TreeNode {\n  /**\n   * An unique id of this node.\n   */\n  readonly id: string;\n  /**\n   * A human-readable name of this tree node.\n   *\n   * @deprecated use `LabelProvider.getName` instead or move this property to your tree node type\n   */\n  readonly name?: string;\n  /**\n   * A css string for this tree node icon.\n   *\n   * @deprecated use `LabelProvider.getIcon` instead or move this property to your tree node type\n   */\n  readonly icon?: string;\n  /**\n   * A human-readable description of this tree node.\n   *\n   * @deprecated use `LabelProvider.getLongName` instead or move this property to your tree node type\n   */\n  readonly description?: string;\n  /**\n   * Test whether this node should be rendered.\n   * If undefined then node will be rendered.\n   */\n  readonly visible?: boolean;\n  /**\n   * A parent node of this tree node.\n   * Undefined if this node is root.\n   */\n  readonly parent: Readonly<CompositeTreeNode> | undefined;\n  /**\n   * A previous sibling of this tree node.\n   */\n  readonly previousSibling?: TreeNode;\n  /**\n   * A next sibling of this tree node.\n   */\n  readonly nextSibling?: TreeNode;\n  /**\n   * Whether this node is busy. Greater than 0 then busy; otherwise not.\n   */\n  readonly busy?: number;\n}\n\nexport namespace TreeNode {\n  export function is(node: Object | undefined): node is TreeNode {\n    return !!node && typeof node === 'object' && 'id' in node && 'parent' in node;\n  }\n\n  export function equals(left: TreeNode | undefined, right: TreeNode | undefined): boolean {\n    return left === right || (!!left && !!right && left.id === right.id);\n  }\n\n  export function isVisible(node: TreeNode | undefined): boolean {\n    return !!node && (node.visible === undefined || node.visible);\n  }\n}\n\n/**\n * The composite tree node.\n */\nexport interface CompositeTreeNode extends TreeNode {\n  /**\n   * Child nodes of this tree node.\n   */\n  children: ReadonlyArray<TreeNode>;\n}\n\nexport namespace CompositeTreeNode {\n  export function is(node: Object | undefined): node is CompositeTreeNode {\n    return !!node && 'children' in node;\n  }\n\n  export function getFirstChild(parent: CompositeTreeNode): TreeNode | undefined {\n    return parent.children[0];\n  }\n\n  export function getLastChild(parent: CompositeTreeNode): TreeNode | undefined {\n    return parent.children[parent.children.length - 1];\n  }\n\n  export function isAncestor(parent: CompositeTreeNode, child: TreeNode | undefined): boolean {\n    if (!child) {\n      return false;\n    }\n    if (TreeNode.equals(parent, child.parent)) {\n      return true;\n    }\n    return isAncestor(parent, child.parent);\n  }\n\n  export function indexOf(parent: CompositeTreeNode, node: TreeNode | undefined): number {\n    if (!node) {\n      return -1;\n    }\n    return parent.children.findIndex(child => TreeNode.equals(node, child));\n  }\n\n  export function addChildren(parent: CompositeTreeNode, children: TreeNode[]): CompositeTreeNode {\n    for (const child of children) {\n      addChild(parent, child);\n    }\n    return parent;\n  }\n\n  export function addChild(parent: CompositeTreeNode, child: TreeNode): CompositeTreeNode {\n    const children = parent.children as TreeNode[];\n    const index = children.findIndex(value => value.id === child.id);\n    if (index !== -1) {\n      children.splice(index, 1, child);\n      setParent(child, index, parent);\n    } else {\n      children.push(child);\n      setParent(child, parent.children.length - 1, parent);\n    }\n    return parent;\n  }\n\n  export function removeChild(parent: CompositeTreeNode, child: TreeNode): void {\n    const children = parent.children as TreeNode[];\n    const index = children.findIndex(value => value.id === child.id);\n    if (index === -1) {\n      return;\n    }\n    children.splice(index, 1);\n    const {previousSibling, nextSibling} = child;\n    if (previousSibling) {\n      Object.assign(previousSibling, {nextSibling});\n    }\n    if (nextSibling) {\n      Object.assign(nextSibling, {previousSibling});\n    }\n  }\n\n  export function setParent(child: TreeNode, index: number, parent: CompositeTreeNode): void {\n    const previousSibling = parent.children[index - 1];\n    const nextSibling = parent.children[index + 1];\n    Object.assign(child, {parent, previousSibling, nextSibling});\n    if (previousSibling) {\n      Object.assign(previousSibling, {nextSibling: child});\n    }\n    if (nextSibling) {\n      Object.assign(nextSibling, {previousSibling: child});\n    }\n  }\n}\n\n/**\n * A default implementation of the tree.\n */\n@injectable()\nexport class TreeImpl implements Tree {\n\n  protected readonly onChangedEmitter = new Emitter<void>();\n  protected readonly onNodeRefreshedEmitter = new Emitter<CompositeTreeNode & WaitUntilEvent>();\n  protected readonly toDispose = new DisposableCollection();\n  protected readonly onDidChangeBusyEmitter = new Emitter<TreeNode>();\n  readonly onDidChangeBusy = this.onDidChangeBusyEmitter.event;\n  protected nodes: {\n    [id: string]: Mutable<TreeNode> | undefined\n  } = {};\n\n  constructor() {\n    this.toDispose.push(this.onChangedEmitter);\n    this.toDispose.push(this.onNodeRefreshedEmitter);\n    this.toDispose.push(this.onDidChangeBusyEmitter);\n  }\n\n  protected _root: TreeNode | undefined;\n\n  get root(): TreeNode | undefined {\n    return this._root;\n  }\n\n  set root(root: TreeNode | undefined) {\n    this.nodes = {};\n    this._root = root;\n    this.addNode(root);\n    this.refresh();\n  }\n\n  get onChanged(): Event<void> {\n    return this.onChangedEmitter.event;\n  }\n\n  get onNodeRefreshed(): Event<CompositeTreeNode & WaitUntilEvent> {\n    return this.onNodeRefreshedEmitter.event;\n  }\n\n  dispose(): void {\n    this.nodes = {};\n    this.toDispose.dispose();\n  }\n\n  getNode(id: string | undefined): TreeNode | undefined {\n    return id !== undefined ? this.nodes[id] : undefined;\n  }\n\n  validateNode(node: TreeNode | undefined): TreeNode | undefined {\n    const id = !!node ? node.id : undefined;\n    return this.getNode(id);\n  }\n\n  async refresh(raw?: CompositeTreeNode): Promise<CompositeTreeNode | undefined> {\n    const parent = !raw ? this._root : this.validateNode(raw);\n    let result: CompositeTreeNode | undefined;\n    if (CompositeTreeNode.is(parent)) {\n      const busySource = new CancellationTokenSource();\n      this.doMarkAsBusy(parent, 800, busySource.token);\n      try {\n        result = parent;\n        const children = await this.resolveChildren(parent);\n        result = await this.setChildren(parent, children);\n      } finally {\n        busySource.cancel();\n      }\n    }\n    this.fireChanged();\n    return result;\n  }\n\n  async markAsBusy(raw: TreeNode, ms: number, token: CancellationToken): Promise<void> {\n    const node = this.validateNode(raw);\n    if (node) {\n      await this.doMarkAsBusy(node, ms, token);\n    }\n  }\n\n  protected fireChanged(): void {\n    this.onChangedEmitter.fire(undefined);\n  }\n\n  protected async fireNodeRefreshed(parent: CompositeTreeNode): Promise<void> {\n    await WaitUntilEvent.fire(this.onNodeRefreshedEmitter, parent);\n    this.fireChanged();\n  }\n\n  protected resolveChildren(parent: CompositeTreeNode): Promise<TreeNode[]> {\n    return Promise.resolve(Array.from(parent.children));\n  }\n\n  protected async setChildren(parent: CompositeTreeNode, children: TreeNode[]): Promise<CompositeTreeNode | undefined> {\n    const root = this.getRootNode(parent);\n    if (this.nodes[root.id] && this.nodes[root.id] !== root) {\n      console.error(`Child node '${parent.id}' does not belong to this '${root.id}' tree.`);\n      return undefined;\n    }\n    this.removeNode(parent);\n    parent.children = children;\n    this.addNode(parent);\n    await this.fireNodeRefreshed(parent);\n    return parent;\n  }\n\n  protected removeNode(node: TreeNode | undefined): void {\n    if (CompositeTreeNode.is(node)) {\n      node.children.forEach(child => this.removeNode(child));\n    }\n    if (node) {\n      delete this.nodes[node.id];\n    }\n  }\n\n  protected getRootNode(node: TreeNode): TreeNode {\n    if (node.parent === undefined) {\n      return node;\n    } else {\n      return this.getRootNode(node.parent);\n    }\n  }\n\n  protected addNode(node: TreeNode | undefined): void {\n    if (node) {\n      this.nodes[node.id] = node;\n    }\n    if (CompositeTreeNode.is(node)) {\n      const {children} = node;\n      children.forEach((child, index) => {\n        CompositeTreeNode.setParent(child, index, node);\n        this.addNode(child);\n      });\n    }\n  }\n\n  protected async doMarkAsBusy(node: Mutable<TreeNode>, ms: number, token: CancellationToken): Promise<void> {\n    try {\n      await timeout(ms, token);\n      this.doSetBusy(node);\n      token.onCancellationRequested(() => this.doResetBusy(node));\n    } catch {\n      /* no-op */\n    }\n  }\n\n  protected doSetBusy(node: Mutable<TreeNode>): void {\n    const oldBusy = node.busy || 0;\n    node.busy = oldBusy + 1;\n    if (oldBusy === 0) {\n      this.onDidChangeBusyEmitter.fire(node);\n    }\n  }\n\n  protected doResetBusy(node: Mutable<TreeNode>): void {\n    const oldBusy = node.busy || 0;\n    if (oldBusy > 0) {\n      node.busy = oldBusy - 1;\n      if (node.busy === 0) {\n        this.onDidChangeBusyEmitter.fire(node);\n      }\n    }\n  }\n\n}\n"]}