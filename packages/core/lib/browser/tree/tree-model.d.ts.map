{"version":3,"sources":["browser/tree/tree-model.ts"],"names":[],"mappings":"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","file":"../../../src/browser/tree/tree-model.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {Emitter, Event, WaitUntilEvent} from '../../common';\nimport {DisposableCollection} from '../../common/disposable';\nimport {CancellationToken} from '../../common/cancellation';\nimport {SelectionProvider} from '../../common/selection-service';\nimport {CompositeTreeNode, Tree, TreeNode} from './tree';\nimport {SelectableTreeNode, TreeSelection, TreeSelectionService} from './tree-selection';\nimport {ExpandableTreeNode, TreeExpansionService} from './tree-expansion';\nimport {TreeNavigationService} from './tree-navigation';\nimport {BottomUpTreeIterator, Iterators, TopDownTreeIterator, TreeIterator} from './tree-iterator';\nimport {TreeSearch} from './tree-search';\n\n/**\n * The tree model.\n */\nexport const TreeModel = Symbol('TreeModel');\n\nexport interface TreeModel extends Tree, TreeSelectionService, TreeExpansionService {\n\n  /**\n   * Event when a node should be opened.\n   */\n  readonly onOpenNode: Event<Readonly<TreeNode>>;\n\n  /**\n   * Expands the given node. If the `node` argument is `undefined`, then expands the currently selected tree node.\n   * If multiple tree nodes are selected, expands the most recently selected tree node.\n   */\n  expandNode(node?: Readonly<ExpandableTreeNode>): Promise<Readonly<ExpandableTreeNode> | undefined>;\n\n  /**\n   * Collapses the given node. If the `node` argument is `undefined`, then collapses the currently selected tree node.\n   * If multiple tree nodes are selected, collapses the most recently selected tree node.\n   */\n  collapseNode(node?: Readonly<ExpandableTreeNode>): Promise<boolean>;\n\n  /**\n   * Collapses recursively. If the `node` argument is `undefined`, then collapses the currently selected tree node.\n   * If multiple tree nodes are selected, collapses the most recently selected tree node.\n   */\n  collapseAll(node?: Readonly<CompositeTreeNode>): Promise<boolean>;\n\n  /**\n   * Toggles the expansion state of the given node. If not give, then it toggles the expansion state of the currently selected node.\n   * If multiple nodes are selected, then the most recently selected tree node's expansion state will be toggled.\n   */\n  toggleNodeExpansion(node?: Readonly<ExpandableTreeNode>): Promise<void>;\n\n  /**\n   * Opens the given node or the currently selected on if the argument is `undefined`.\n   * If multiple nodes are selected, open the most recently selected node.\n   */\n  openNode(node?: Readonly<TreeNode> | undefined): void;\n\n  /**\n   * Selects the parent node relatively to the selected taking into account node expansion.\n   */\n  selectParent(): void;\n\n  /**\n   * Navigates to the given node if it is defined. This method accepts both the tree node and its ID as an argument.\n   * Navigation sets a node as a root node and expand it. Resolves to the node if the navigation was successful. Otherwise,\n   * resolves to `undefined`.\n   */\n  navigateTo(nodeOrId: Readonly<TreeNode> | string | undefined): Promise<TreeNode | undefined>;\n\n  /**\n   * Tests whether it is possible to navigate forward.\n   */\n  canNavigateForward(): boolean;\n\n  /**\n   * Tests whether it is possible to navigate backward.\n   */\n  canNavigateBackward(): boolean;\n\n  /**\n   * Navigates forward.\n   */\n  navigateForward(): Promise<void>;\n\n  /**\n   * Navigates backward.\n   */\n  navigateBackward(): Promise<void>;\n\n  /**\n   * Selects the previous node relatively to the currently selected one. This method takes the expansion state of the tree into consideration.\n   */\n  selectPrevNode(type?: TreeSelection.SelectionType): void;\n\n  /**\n   * Returns the previous selectable tree node.\n   */\n  getPrevSelectableNode(node?: TreeNode): SelectableTreeNode | undefined;\n\n  /**\n   * Selects the next node relatively to the currently selected one. This method takes the expansion state of the tree into consideration.\n   */\n  selectNextNode(type?: TreeSelection.SelectionType): void;\n\n  /**\n   * Returns the next selectable tree node.\n   */\n  getNextSelectableNode(node?: TreeNode): SelectableTreeNode | undefined;\n\n  /**\n   * Selects the given tree node. Has no effect when the node does not exist in the tree. Discards any previous selection state.\n   */\n  selectNode(node: Readonly<SelectableTreeNode>): void;\n\n  /**\n   * Selects the given node if it was not yet selected, or unselects it if it was. Keeps the previous selection state and updates it\n   * with the current toggle selection.\n   */\n  toggleNode(node: Readonly<SelectableTreeNode>): void;\n\n  /**\n   * Selects a range of tree nodes. The target of the selection range is the argument, the from tree node is the previous selected node.\n   * If no node was selected previously, invoking this method does nothing.\n   */\n  selectRange(node: Readonly<SelectableTreeNode>): void;\n}\n\n@injectable()\nexport class TreeModelImpl implements TreeModel, SelectionProvider<ReadonlyArray<Readonly<SelectableTreeNode>>> {\n\n  @inject(Tree) protected readonly tree: Tree;\n  @inject(TreeSelectionService) protected readonly selectionService: TreeSelectionService;\n  @inject(TreeExpansionService) protected readonly expansionService: TreeExpansionService;\n  @inject(TreeNavigationService) protected readonly navigationService: TreeNavigationService;\n  @inject(TreeSearch) protected readonly treeSearch: TreeSearch;\n\n  protected readonly onChangedEmitter = new Emitter<void>();\n  protected readonly onOpenNodeEmitter = new Emitter<TreeNode>();\n  protected readonly toDispose = new DisposableCollection();\n\n  get root(): TreeNode | undefined {\n    return this.tree.root;\n  }\n\n  set root(root: TreeNode | undefined) {\n    this.tree.root = root;\n  }\n\n  get onChanged(): Event<void> {\n    return this.onChangedEmitter.event;\n  }\n\n  get onOpenNode(): Event<TreeNode> {\n    return this.onOpenNodeEmitter.event;\n  }\n\n  get onNodeRefreshed(): Event<Readonly<CompositeTreeNode> & WaitUntilEvent> {\n    return this.tree.onNodeRefreshed;\n  }\n\n  // tslint:disable-next-line:typedef\n  get selectedNodes() {\n    return this.selectionService.selectedNodes;\n  }\n\n  // tslint:disable-next-line:typedef\n  get onSelectionChanged() {\n    return this.selectionService.onSelectionChanged;\n  }\n\n  get onExpansionChanged(): Event<Readonly<ExpandableTreeNode>> {\n    return this.expansionService.onExpansionChanged;\n  }\n\n  get onDidChangeBusy(): Event<TreeNode> {\n    return this.tree.onDidChangeBusy;\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  getNode(id: string | undefined): TreeNode | undefined {\n    return this.tree.getNode(id);\n  }\n\n  validateNode(node: TreeNode | undefined): TreeNode | undefined {\n    return this.tree.validateNode(node);\n  }\n\n  async refresh(parent?: Readonly<CompositeTreeNode>): Promise<CompositeTreeNode | undefined> {\n    if (parent) {\n      return this.tree.refresh(parent);\n    }\n    return this.tree.refresh();\n  }\n\n  async expandNode(raw?: Readonly<ExpandableTreeNode>): Promise<ExpandableTreeNode | undefined> {\n    for (const node of raw ? [raw] : this.selectedNodes) {\n      if (ExpandableTreeNode.is(node)) {\n        return this.expansionService.expandNode(node);\n      }\n    }\n    return undefined;\n  }\n\n  async collapseNode(raw?: Readonly<ExpandableTreeNode>): Promise<boolean> {\n    for (const node of raw ? [raw] : this.selectedNodes) {\n      if (ExpandableTreeNode.is(node)) {\n        return this.expansionService.collapseNode(node);\n      }\n    }\n    return false;\n  }\n\n  async collapseAll(raw?: Readonly<CompositeTreeNode>): Promise<boolean> {\n    const node = raw || this.selectedNodes[0];\n    if (SelectableTreeNode.is(node)) {\n      this.selectNode(node);\n    }\n    if (CompositeTreeNode.is(node)) {\n      return this.expansionService.collapseAll(node);\n    }\n    return false;\n  }\n\n  async toggleNodeExpansion(raw?: Readonly<ExpandableTreeNode>): Promise<void> {\n    for (const node of raw ? [raw] : this.selectedNodes) {\n      if (ExpandableTreeNode.is(node)) {\n        await this.expansionService.toggleNodeExpansion(node);\n        return;\n      }\n    }\n  }\n\n  selectPrevNode(type: TreeSelection.SelectionType = TreeSelection.SelectionType.DEFAULT): void {\n    const node = this.getPrevSelectableNode();\n    if (node) {\n      this.addSelection({node, type});\n    }\n  }\n\n  getPrevSelectableNode(node: TreeNode = this.selectedNodes[0]): SelectableTreeNode | undefined {\n    const iterator = this.createBackwardIterator(node);\n    return iterator && this.doGetNextNode(iterator);\n  }\n\n  selectNextNode(type: TreeSelection.SelectionType = TreeSelection.SelectionType.DEFAULT): void {\n    const node = this.getNextSelectableNode();\n    if (node) {\n      this.addSelection({node, type});\n    }\n  }\n\n  getNextSelectableNode(node: TreeNode = this.selectedNodes[0]): SelectableTreeNode | undefined {\n    const iterator = this.createIterator(node);\n    return iterator && this.doGetNextNode(iterator);\n  }\n\n  openNode(raw?: TreeNode | undefined): void {\n    const node = raw || this.selectedNodes[0];\n    if (node) {\n      this.doOpenNode(node);\n      this.onOpenNodeEmitter.fire(node);\n    }\n  }\n\n  selectParent(): void {\n    if (this.selectedNodes.length === 1) {\n      const node = this.selectedNodes[0];\n      const parent = SelectableTreeNode.getVisibleParent(node);\n      if (parent) {\n        this.selectNode(parent);\n      }\n    }\n  }\n\n  async navigateTo(nodeOrId: TreeNode | string | undefined): Promise<TreeNode | undefined> {\n    if (nodeOrId) {\n      const node = typeof nodeOrId === 'string' ? this.getNode(nodeOrId) : nodeOrId;\n      if (node) {\n        this.navigationService.push(node);\n        await this.doNavigate(node);\n        return node;\n      }\n    }\n    return undefined;\n  }\n\n  canNavigateForward(): boolean {\n    return !!this.navigationService.next;\n  }\n\n  canNavigateBackward(): boolean {\n    return !!this.navigationService.prev;\n  }\n\n  async navigateForward(): Promise<void> {\n    const node = this.navigationService.advance();\n    if (node) {\n      await this.doNavigate(node);\n    }\n  }\n\n  async navigateBackward(): Promise<void> {\n    const node = this.navigationService.retreat();\n    if (node) {\n      await this.doNavigate(node);\n    }\n  }\n\n  addSelection(selectionOrTreeNode: TreeSelection | Readonly<SelectableTreeNode>): void {\n    this.selectionService.addSelection(selectionOrTreeNode);\n  }\n\n  selectNode(node: Readonly<SelectableTreeNode>): void {\n    this.addSelection(node);\n  }\n\n  toggleNode(node: Readonly<SelectableTreeNode>): void {\n    this.addSelection({node, type: TreeSelection.SelectionType.TOGGLE});\n  }\n\n  selectRange(node: Readonly<SelectableTreeNode>): void {\n    this.addSelection({node, type: TreeSelection.SelectionType.RANGE});\n  }\n\n  storeState(): TreeModelImpl.State {\n    return {\n      selection: this.selectionService.storeState()\n    };\n  }\n\n  restoreState(state: TreeModelImpl.State): void {\n    if (state.selection) {\n      this.selectionService.restoreState(state.selection);\n    }\n  }\n\n  markAsBusy(node: Readonly<TreeNode>, ms: number, token: CancellationToken): Promise<void> {\n    return this.tree.markAsBusy(node, ms, token);\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.toDispose.push(this.tree);\n    this.toDispose.push(this.tree.onChanged(() => this.fireChanged()));\n\n    this.toDispose.push(this.selectionService);\n\n    this.toDispose.push(this.expansionService);\n    this.toDispose.push(this.expansionService.onExpansionChanged(node => {\n      this.fireChanged();\n      this.handleExpansion(node);\n    }));\n\n    this.toDispose.push(this.onOpenNodeEmitter);\n    this.toDispose.push(this.onChangedEmitter);\n    this.toDispose.push(this.treeSearch);\n  }\n\n  protected handleExpansion(node: Readonly<ExpandableTreeNode>): void {\n    this.selectIfAncestorOfSelected(node);\n  }\n\n  /**\n   * Select the given node if it is the ancestor of a selected node.\n   */\n  protected selectIfAncestorOfSelected(node: Readonly<ExpandableTreeNode>): void {\n    if (!node.expanded && [...this.selectedNodes].some(selectedNode => CompositeTreeNode.isAncestor(node, selectedNode))) {\n      if (SelectableTreeNode.isVisible(node)) {\n        this.selectNode(node);\n      }\n    }\n  }\n\n  protected fireChanged(): void {\n    this.onChangedEmitter.fire(undefined);\n  }\n\n  protected doGetNextNode(iterator: TreeIterator): SelectableTreeNode | undefined {\n    // Skip the first item. // TODO: clean this up, and skip the first item in a different way without loading everything.\n    iterator.next();\n    let result = iterator.next();\n    while (!result.done && !this.isVisibleSelectableNode(result.value)) {\n      result = iterator.next();\n    }\n    const node = result.value;\n    if (SelectableTreeNode.isVisible(node)) {\n      return node;\n    }\n    return undefined;\n  }\n\n  protected isVisibleSelectableNode(node: TreeNode): node is SelectableTreeNode {\n    return SelectableTreeNode.isVisible(node);\n  }\n\n  protected createBackwardIterator(node: TreeNode | undefined): TreeIterator | undefined {\n    const {filteredNodes} = this.treeSearch;\n    if (filteredNodes.length === 0) {\n      return node ? new BottomUpTreeIterator(node!, {pruneCollapsed: true}) : undefined;\n    }\n    if (node && filteredNodes.indexOf(node) === -1) {\n      return undefined;\n    }\n    return Iterators.cycle(filteredNodes.slice().reverse(), node);\n  }\n\n  protected createIterator(node: TreeNode | undefined): TreeIterator | undefined {\n    const {filteredNodes} = this.treeSearch;\n    if (filteredNodes.length === 0) {\n      return node ? new TopDownTreeIterator(node!, {pruneCollapsed: true}) : undefined;\n    }\n    if (node && filteredNodes.indexOf(node) === -1) {\n      return undefined;\n    }\n    return Iterators.cycle(filteredNodes, node);\n  }\n\n  protected doOpenNode(node: TreeNode): void {\n    if (ExpandableTreeNode.is(node)) {\n      this.toggleNodeExpansion(node);\n    }\n  }\n\n  protected async doNavigate(node: TreeNode): Promise<void> {\n    this.tree.root = node;\n    if (ExpandableTreeNode.is(node)) {\n      await this.expandNode(node);\n    }\n    if (SelectableTreeNode.is(node)) {\n      this.selectNode(node);\n    }\n  }\n\n}\n\nexport namespace TreeModelImpl {\n  export interface State {\n    selection: object\n  }\n}\n"]}