{"version":3,"sources":["browser/tree/tree-selection-impl.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAGlF,OAAO,EAAC,IAAI,EAAE,QAAQ,EAAC,MAAM,QAAQ,CAAC;AACtC,OAAO,EAAC,OAAO,EAAE,KAAK,EAAC,MAAM,cAAc,CAAC;AAC5C,OAAO,EAAyB,kBAAkB,EAAC,MAAM,wBAAwB,CAAC;AAClF,OAAO,EAAC,kBAAkB,EAAE,aAAa,EAAE,oBAAoB,EAAC,MAAM,kBAAkB,CAAC;AAEzF,qBACa,wBAAyB,YAAW,oBAAoB;IAGnE,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IAC9B,SAAS,CAAC,QAAQ,CAAC,yBAAyB,mDAA8D;IAE1G,SAAS,CAAC,KAAK,EAAE,kBAAkB,CAAC;IAEpC,IAAI,aAAa,IAAI,aAAa,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC,CAE/D;IAED,IAAI,kBAAkB,IAAI,KAAK,CAAC,aAAa,CAAC,QAAQ,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAE3E;IAED,OAAO,IAAI,IAAI;IAIf,YAAY,CAAC,mBAAmB,EAAE,aAAa,GAAG,QAAQ,CAAC,kBAAkB,CAAC,GAAG,IAAI;IAyBrF,UAAU,IAAI,wBAAwB,CAAC,KAAK;IAU5C,YAAY,CAAC,KAAK,EAAE,wBAAwB,CAAC,KAAK,GAAG,IAAI;IAoBzD,SAAS,CAAC,IAAI,IAAI,IAAI;IAItB,SAAS,CAAC,oBAAoB,IAAI,IAAI;IAItC,SAAS,CAAC,UAAU,CAAC,QAAQ,EAAE,kBAAkB,GAAG,IAAI;IAgBxD,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,aAAa,CAAC,kBAAkB,CAAC,GAAG,IAAI;IAIlE,SAAS,CAAC,MAAM,CAAC,KAAK,EAAE,aAAa,CAAC,kBAAkB,CAAC,GAAG,IAAI;IAIhE,SAAS,CAAC,WAAW,CAAC,GAAG,KAAK,EAAE,aAAa,CAAC,kBAAkB,CAAC,EAAE,GAAG,IAAI;IAI1E,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,kBAAkB,GAAG,SAAS,GAAG,IAAI;IAM9D;;;OAGG;IACH,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,aAAa,CAAC,CAAC,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC;IAI1F;;OAEG;IACH,SAAS,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,SAAS;CAKjF;AAED,yBAAiB,wBAAwB,CAAC;IACxC,UAAiB,KAAK;QACpB,cAAc,EAAE,aAAa,CAAC,2BAA2B,CAAC,CAAA;KAC3D;IAED,UAAiB,2BAA2B;QAC1C,KAAK,CAAC,EAAE,MAAM,CAAA;QACd,IAAI,CAAC,EAAE,MAAM,CAAA;QACb,IAAI,CAAC,EAAE,aAAa,CAAC,aAAa,CAAA;KACnC;CACF","file":"../../../src/browser/tree/tree-selection-impl.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {Tree, TreeNode} from './tree';\nimport {Emitter, Event} from '../../common';\nimport {FocusableTreeSelection, TreeSelectionState} from './tree-selection-state';\nimport {SelectableTreeNode, TreeSelection, TreeSelectionService} from './tree-selection';\n\n@injectable()\nexport class TreeSelectionServiceImpl implements TreeSelectionService {\n\n  @inject(Tree)\n  protected readonly tree: Tree;\n  protected readonly onSelectionChangedEmitter = new Emitter<ReadonlyArray<Readonly<SelectableTreeNode>>>();\n\n  protected state: TreeSelectionState;\n\n  get selectedNodes(): ReadonlyArray<Readonly<SelectableTreeNode>> {\n    return this.state.selection();\n  }\n\n  get onSelectionChanged(): Event<ReadonlyArray<Readonly<SelectableTreeNode>>> {\n    return this.onSelectionChangedEmitter.event;\n  }\n\n  dispose(): void {\n    this.onSelectionChangedEmitter.dispose();\n  }\n\n  addSelection(selectionOrTreeNode: TreeSelection | Readonly<SelectableTreeNode>): void {\n    const selection = ((arg: TreeSelection | Readonly<SelectableTreeNode>): TreeSelection => {\n      const type = TreeSelection.SelectionType.DEFAULT;\n      if (TreeSelection.is(arg)) {\n        return {\n          type,\n          ...arg\n        };\n      }\n      return {\n        type,\n        node: arg\n      };\n    })(selectionOrTreeNode);\n\n    const node = this.validateNode(selection.node);\n    if (node === undefined) {\n      return;\n    }\n    Object.assign(selection, {node});\n\n    const newState = this.state.nextState(selection);\n    this.transiteTo(newState);\n  }\n\n  storeState(): TreeSelectionServiceImpl.State {\n    return {\n      selectionStack: this.state.selectionStack.map(s => ({\n        focus: s.focus && s.focus.id || undefined,\n        node: s.node && s.node.id || undefined,\n        type: s.type\n      }))\n    };\n  }\n\n  restoreState(state: TreeSelectionServiceImpl.State): void {\n    const selectionStack: FocusableTreeSelection[] = [];\n    for (const selection of state.selectionStack) {\n      const node = selection.node && this.tree.getNode(selection.node) || undefined;\n      if (!SelectableTreeNode.is(node)) {\n        break;\n      }\n      const focus = selection.focus && this.tree.getNode(selection.focus) || undefined;\n      selectionStack.push({\n        node,\n        focus: SelectableTreeNode.is(focus) && focus || undefined,\n        type: selection.type\n      });\n    }\n    if (selectionStack.length) {\n      this.transiteTo(new TreeSelectionState(this.tree, selectionStack));\n    }\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.state = new TreeSelectionState(this.tree);\n  }\n\n  protected fireSelectionChanged(): void {\n    this.onSelectionChangedEmitter.fire(this.state.selection());\n  }\n\n  protected transiteTo(newState: TreeSelectionState): void {\n    const oldNodes = this.state.selection();\n    const newNodes = newState.selection();\n\n    const toUnselect = this.difference(oldNodes, newNodes);\n    const toSelect = this.difference(newNodes, oldNodes);\n\n    this.unselect(toUnselect);\n    this.select(toSelect);\n    this.removeFocus(oldNodes, newNodes);\n    this.addFocus(newState.focus);\n\n    this.state = newState;\n    this.fireSelectionChanged();\n  }\n\n  protected unselect(nodes: ReadonlyArray<SelectableTreeNode>): void {\n    nodes.forEach(node => node.selected = false);\n  }\n\n  protected select(nodes: ReadonlyArray<SelectableTreeNode>): void {\n    nodes.forEach(node => node.selected = true);\n  }\n\n  protected removeFocus(...nodes: ReadonlyArray<SelectableTreeNode>[]): void {\n    nodes.forEach(node => node.forEach(n => n.focus = false));\n  }\n\n  protected addFocus(node: SelectableTreeNode | undefined): void {\n    if (node) {\n      node.focus = true;\n    }\n  }\n\n  /**\n   * Returns an array of the difference of two arrays. The returned array contains all elements that are contained by\n   * `left` and not contained by `right`. `right` may also contain elements not present in `left`: these are simply ignored.\n   */\n  protected difference<T>(left: ReadonlyArray<T>, right: ReadonlyArray<T>): ReadonlyArray<T> {\n    return left.filter(item => right.indexOf(item) === -1);\n  }\n\n  /**\n   * Returns a reference to the argument if the node exists in the tree. Otherwise, `undefined`.\n   */\n  protected validateNode(node: Readonly<TreeNode>): Readonly<TreeNode> | undefined {\n    const result = this.tree.validateNode(node);\n    return SelectableTreeNode.is(result) ? result : undefined;\n  }\n\n}\n\nexport namespace TreeSelectionServiceImpl {\n  export interface State {\n    selectionStack: ReadonlyArray<FocusableTreeSelectionState>\n  }\n\n  export interface FocusableTreeSelectionState {\n    focus?: string\n    node?: string\n    type?: TreeSelection.SelectionType\n  }\n}\n"]}