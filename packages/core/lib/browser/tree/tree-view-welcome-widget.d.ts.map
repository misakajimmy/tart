{"version":3,"sources":["browser/tree/tree-view-welcome-widget.tsx"],"names":[],"mappings":"AACA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAC,eAAe,EAAC,MAAM,cAAc,CAAC;AAC7C,OAAO,EAAC,iBAAiB,EAAC,MAAM,wBAAwB,CAAC;AACzD,OAAO,EAAC,aAAa,EAAC,MAAM,WAAW,CAAC;AACxC,OAAO,EAAC,SAAS,EAAC,MAAM,cAAc,CAAC;AACvC,OAAO,EAAC,UAAU,EAAC,MAAM,eAAe,CAAC;AAEzC,UAAU,WAAW;IACnB,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,OAAO,EAAE,MAAM,CAAC;IACzB,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;CACxB;AAED,UAAU,KAAK;IACb,QAAQ,CAAC,WAAW,EAAE,WAAW,CAAC;IAClC,OAAO,EAAE,OAAO,CAAC;CAClB;AAED,UAAU,KAAK;IACb,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,IAAI,EAAE,MAAM,CAAC;IACtB,QAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC;CACzB;AAED,aAAK,cAAc,GAAG,MAAM,GAAG,KAAK,CAAC;AAErC,qBACa,qBAAsB,SAAQ,UAAU;IAGnD,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,eAAe,CAAC;IAG7C,SAAS,CAAC,QAAQ,CAAC,cAAc,EAAE,iBAAiB,CAAC;IAGrD,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAEhD,SAAS,CAAC,gBAAgB,EAAE,KAAK,CAAC,SAAS,EAAE,CAAM;IACnD,SAAS,CAAC,WAAW,EAAE,KAAK,GAAG,SAAS,CAAC;IACzC,SAAS,CAAC,KAAK,EAAE,KAAK,EAAE,CAAM;IAE9B,IAAI,YAAY,IAAI,WAAW,EAAE,CAMhC;IAED,8BAA8B,CAAC,YAAY,EAAE,WAAW,EAAE,GAAG,IAAI;IAcjE,0BAA0B,IAAI,IAAI;IAwBlC,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,GAAG,KAAK,CAAC,SAAS;IAOvD,SAAS,CAAC,qBAAqB,IAAI,OAAO;IAI1C,SAAS,CAAC,iBAAiB,IAAI,KAAK,CAAC,SAAS;IAQ9C,SAAS,CAAC,sBAAsB,IAAI,IAAI;IAgDxC,SAAS,CAAC,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,GAAG,KAAK,CAAC,SAAS;IAazE,SAAS,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,KAAK,CAAC,SAAS;IAIxE,SAAS,CAAC,qBAAqB,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,GAAG,KAAK,CAAC,SAAS;IAW9E,SAAS,CAAC,gBAAgB,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM;IAQhD,SAAS,CAAC,cAAc,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO;IAQ/C,SAAS,CAAC,iBAAiB,UAAW,gBAAgB,QAAQ,MAAM,KAAG,IAAI,CASzE;IAEF,SAAS,CAAC,eAAe,CAAC,IAAI,EAAE,MAAM,GAAG,cAAc,EAAE;CA6B1D","file":"../../../src/browser/tree/tree-view-welcome-widget.d.ts","sourcesContent":["import {inject, injectable} from 'inversify';\nimport * as React from 'react';\nimport {CommandRegistry} from '../../common';\nimport {ContextKeyService} from '../context-key-service';\nimport {WindowService} from '../window';\nimport {TreeModel} from './tree-model';\nimport {TreeWidget} from './tree-widget';\n\ninterface ViewWelcome {\n  readonly view: string;\n  readonly content: string;\n  readonly when?: string;\n  readonly order: number;\n}\n\ninterface IItem {\n  readonly welcomeInfo: ViewWelcome;\n  visible: boolean;\n}\n\ninterface ILink {\n  readonly label: string;\n  readonly href: string;\n  readonly title?: string;\n}\n\ntype LinkedTextItem = string | ILink;\n\n@injectable()\nexport class TreeViewWelcomeWidget extends TreeWidget {\n\n  @inject(CommandRegistry)\n  protected readonly commands: CommandRegistry;\n\n  @inject(ContextKeyService)\n  protected readonly contextService: ContextKeyService;\n\n  @inject(WindowService)\n  protected readonly windowService: WindowService;\n\n  protected viewWelcomeNodes: React.ReactNode[] = [];\n  protected defaultItem: IItem | undefined;\n  protected items: IItem[] = [];\n\n  get visibleItems(): ViewWelcome[] {\n    const visibleItems = this.items.filter(v => v.visible);\n    if (visibleItems.length && this.defaultItem) {\n      return [this.defaultItem.welcomeInfo];\n    }\n    return visibleItems.map(v => v.welcomeInfo);\n  }\n\n  handleViewWelcomeContentChange(viewWelcomes: ViewWelcome[]): void {\n    this.items = [];\n    for (const welcomeInfo of viewWelcomes) {\n      if (welcomeInfo.when === 'default') {\n        this.defaultItem = {welcomeInfo, visible: true};\n      } else {\n        const visible = welcomeInfo.when === undefined || this.contextService.match(welcomeInfo.when);\n        this.items.push({welcomeInfo, visible});\n      }\n    }\n    this.updateViewWelcomeNodes();\n    this.update();\n  }\n\n  handleWelcomeContextChange(): void {\n    let didChange = false;\n\n    for (const item of this.items) {\n      if (!item.welcomeInfo.when || item.welcomeInfo.when === 'default') {\n        continue;\n      }\n\n      const visible = item.welcomeInfo.when === undefined || this.contextService.match(item.welcomeInfo.when);\n\n      if (item.visible === visible) {\n        continue;\n      }\n\n      item.visible = visible;\n      didChange = true;\n    }\n\n    if (didChange) {\n      this.updateViewWelcomeNodes();\n      this.update();\n    }\n  }\n\n  protected renderTree(model: TreeModel): React.ReactNode {\n    if (this.shouldShowWelcomeView() && this.visibleItems.length) {\n      return this.renderViewWelcome();\n    }\n    return super.renderTree(model);\n  }\n\n  protected shouldShowWelcomeView(): boolean {\n    return false;\n  }\n\n  protected renderViewWelcome(): React.ReactNode {\n    return (\n        <div className='tart-WelcomeView'>\n          {...this.viewWelcomeNodes}\n        </div>\n    );\n  }\n\n  protected updateViewWelcomeNodes(): void {\n    this.viewWelcomeNodes = [];\n    const items = this.visibleItems.sort((a, b) => a.order - b.order);\n\n    for (const [iIndex, {content}] of items.entries()) {\n      const lines = content.split('\\n');\n\n      for (let [lIndex, line] of lines.entries()) {\n        const lineKey = `${iIndex}-${lIndex}`;\n        line = line.trim();\n\n        if (!line) {\n          continue;\n        }\n\n        const linkedTextItems = this.parseLinkedText(line);\n\n        if (linkedTextItems.length === 1 && typeof linkedTextItems[0] !== 'string') {\n          this.viewWelcomeNodes.push(\n              this.renderButtonNode(linkedTextItems[0], lineKey)\n          );\n        } else {\n          const linkedTextNodes: React.ReactNode[] = [];\n\n          for (const [nIndex, node] of linkedTextItems.entries()) {\n            const linkedTextKey = `${lineKey}-${nIndex}`;\n\n            if (typeof node === 'string') {\n              linkedTextNodes.push(\n                  this.renderTextNode(node, linkedTextKey)\n              );\n            } else {\n              linkedTextNodes.push(\n                  this.renderCommandLinkNode(node, linkedTextKey)\n              );\n            }\n          }\n\n          this.viewWelcomeNodes.push(\n              <div key={`line-${lineKey}`}>\n                {...linkedTextNodes}\n              </div>\n          );\n        }\n      }\n    }\n  }\n\n  protected renderButtonNode(node: ILink, lineKey: string): React.ReactNode {\n    return (\n        <div key={`line-${lineKey}`} className='tart-WelcomeViewButtonWrapper'>\n          <button title={node.title}\n                  className='tart-button tart-WelcomeViewButton'\n                  disabled={!this.isEnabledClick(node.href)}\n                  onClick={e => this.openLinkOrCommand(e, node.href)}>\n            {node.label}\n          </button>\n        </div>\n    );\n  }\n\n  protected renderTextNode(node: string, textKey: string): React.ReactNode {\n    return <span key={`text-${textKey}`}>{node}</span>;\n  }\n\n  protected renderCommandLinkNode(node: ILink, linkKey: string): React.ReactNode {\n    return (\n        <a key={`link-${linkKey}`}\n           className={this.getLinkClassName(node.href)}\n           title={node.title || ''}\n           onClick={e => this.openLinkOrCommand(e, node.href)}>\n          {node.label}\n        </a>\n    );\n  }\n\n  protected getLinkClassName(href: string): string {\n    const classNames = ['tart-WelcomeViewCommandLink'];\n    if (!this.isEnabledClick(href)) {\n      classNames.push('disabled');\n    }\n    return classNames.join(' ');\n  }\n\n  protected isEnabledClick(href: string): boolean {\n    if (href.startsWith('command:')) {\n      const command = href.replace('command:', '');\n      return this.commands.isEnabled(command);\n    }\n    return true;\n  }\n\n  protected openLinkOrCommand = (event: React.MouseEvent, href: string): void => {\n    event.stopPropagation();\n\n    if (href.startsWith('command:')) {\n      const command = href.replace('command:', '');\n      this.commands.executeCommand(command);\n    } else {\n      this.windowService.openNewWindow(href, {external: true});\n    }\n  };\n\n  protected parseLinkedText(text: string): LinkedTextItem[] {\n    const result: LinkedTextItem[] = [];\n\n    const linkRegex = /\\[([^\\]]+)\\]\\(((?:https?:\\/\\/|command:)[^\\)\\s]+)(?: (\"|')([^\\3]+)(\\3))?\\)/gi;\n    let index = 0;\n    let match: RegExpExecArray | null;\n\n    while (match = linkRegex.exec(text)) {\n      if (match.index - index > 0) {\n        result.push(text.substring(index, match.index));\n      }\n\n      const [, label, href, , title] = match;\n\n      if (title) {\n        result.push({label, href, title});\n      } else {\n        result.push({label, href});\n      }\n\n      index = match.index + match[0].length;\n    }\n\n    if (index < text.length) {\n      result.push(text.substring(index));\n    }\n\n    return result;\n  }\n}\n"]}