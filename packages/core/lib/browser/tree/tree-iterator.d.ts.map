{"version":3,"sources":["browser/tree/tree-iterator.ts"],"names":[],"mappings":"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","file":"../../../src/browser/tree/tree-iterator.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {CompositeTreeNode, TreeNode} from './tree';\nimport {ExpandableTreeNode} from './tree-expansion';\n\nexport interface TreeIterator extends Iterator<TreeNode> {\n}\n\nexport namespace TreeIterator {\n\n  export interface Options {\n    readonly pruneCollapsed: boolean\n    readonly pruneSiblings: boolean\n  }\n\n  export const DEFAULT_OPTIONS: Options = {\n    pruneCollapsed: false,\n    pruneSiblings: false\n  };\n\n}\n\nexport abstract class AbstractTreeIterator implements TreeIterator, Iterable<TreeNode> {\n\n  protected readonly delegate: IterableIterator<TreeNode>;\n  protected readonly options: TreeIterator.Options;\n\n  constructor(protected readonly root: TreeNode, options?: Partial<TreeIterator.Options>) {\n    this.options = {\n      ...TreeIterator.DEFAULT_OPTIONS,\n      ...options\n    };\n    this.delegate = this.iterator(this.root);\n  }\n\n  // tslint:disable-next-line:typedef\n  [Symbol.iterator]() {\n    return this.delegate;\n  }\n\n  next(): IteratorResult<TreeNode> {\n    return this.delegate.next();\n  }\n\n  protected abstract iterator(node: TreeNode): IterableIterator<TreeNode>;\n\n  protected children(node: TreeNode): TreeNode[] | undefined {\n    if (!CompositeTreeNode.is(node)) {\n      return undefined;\n    }\n    if (this.options.pruneCollapsed && this.isCollapsed(node)) {\n      return undefined;\n    }\n    return node.children.slice();\n  }\n\n  protected isCollapsed(node: TreeNode): boolean {\n    return ExpandableTreeNode.isCollapsed(node);\n  }\n\n  protected isEmpty(nodes: TreeNode[] | undefined): boolean {\n    return nodes === undefined || nodes.length === 0;\n  }\n\n}\n\nexport class DepthFirstTreeIterator extends AbstractTreeIterator {\n\n  protected iterator(root: TreeNode): IterableIterator<TreeNode> {\n    return Iterators.depthFirst(root, this.children.bind(this));\n  }\n\n}\n\nexport class BreadthFirstTreeIterator extends AbstractTreeIterator {\n\n  protected iterator(root: TreeNode): IterableIterator<TreeNode> {\n    return Iterators.breadthFirst(root, this.children.bind(this));\n  }\n\n}\n\n/**\n * This tree iterator visits all nodes from top to bottom considering the following rules.\n *\n * Let assume the following tree:\n * ```\n *   R\n *   |\n *   +---1\n *   |   |\n *   |   +---1.1\n *   |   |\n *   |   +---1.2\n *   |   |\n *   |   +---1.3\n *   |   |    |\n *   |   |    +---1.3.1\n *   |   |    |\n *   |   |    +---1.3.2\n *   |   |\n *   |   +---1.4\n *   |\n *   +---2\n *       |\n *       +---2.1\n * ```\n * When selecting `1.2` as the root, the normal `DepthFirstTreeIterator` would stop on `1.2` as it does not have children,\n * but this iterator will visit the next sibling (`1.3` and `1.4` but **not** `1.1`) nodes. So the expected traversal order will be\n * `1.2`, `1.3`, `1.3.1`, `1.3.2`,  and `1.4` then jumps to `2` and continues with `2.1`.\n */\nexport class TopDownTreeIterator extends AbstractTreeIterator {\n\n  protected iterator(root: TreeNode): IterableIterator<TreeNode> {\n    const doNext = this.doNext.bind(this);\n    return (function* (): IterableIterator<TreeNode> {\n      let next = root;\n      while (next) {\n        yield next;\n        next = doNext(next);\n      }\n    }).bind(this)();\n  }\n\n  protected doNext(node: TreeNode): TreeNode | undefined {\n    return this.findFirstChild(node) || this.findNextSibling(node);\n  }\n\n  protected findFirstChild(node: TreeNode): TreeNode | undefined {\n    return (this.children(node) || [])[0];\n  }\n\n  protected findNextSibling(node: TreeNode | undefined): TreeNode | undefined {\n    if (!node) {\n      return undefined;\n    }\n    if (this.options.pruneSiblings && node === this.root) {\n      return undefined;\n    }\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    return this.findNextSibling(node.parent);\n  }\n\n}\n\n/**\n * Unlike other tree iterators, this does not visit all the nodes, it stops once it reaches the root node\n * while traversing up the tree hierarchy in an inverse pre-order fashion. This is the counterpart of the `TopDownTreeIterator`.\n */\nexport class BottomUpTreeIterator extends AbstractTreeIterator {\n\n  protected iterator(root: TreeNode): IterableIterator<TreeNode> {\n    const doNext = this.doNext.bind(this);\n    return (function* (): IterableIterator<TreeNode> {\n      let next = root;\n      while (next) {\n        yield next;\n        next = doNext(next);\n      }\n    }).bind(this)();\n  }\n\n  protected doNext(node: TreeNode): TreeNode | undefined {\n    const previousSibling = node.previousSibling;\n    const lastChild = this.lastChild(previousSibling);\n    return lastChild || node.parent;\n  }\n\n  protected lastChild(node: TreeNode | undefined): TreeNode | undefined {\n    const children = node ? this.children(node) : [];\n    if (this.isEmpty(children)) {\n      return node;\n    }\n    if (CompositeTreeNode.is(node)) {\n      const lastChild = CompositeTreeNode.getLastChild(node);\n      return this.lastChild(lastChild);\n    }\n    return undefined;\n  }\n\n}\n\nexport namespace Iterators {\n\n  /**\n   * Generator for depth first, pre-order tree traversal iteration.\n   */\n  export function* depthFirst<T>(root: T, children: (node: T) => T[] | undefined, include: (node: T) => boolean = () => true): IterableIterator<T> {\n    const stack: T[] = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      const top = stack.pop()!;\n      yield top;\n      stack.push(...(children(top) || []).filter(include).reverse());\n    }\n  }\n\n  /**\n   * Generator for breadth first tree traversal iteration.\n   */\n  export function* breadthFirst<T>(root: T, children: (node: T) => T[] | undefined, include: (node: T) => boolean = () => true): IterableIterator<T> {\n    const queue: T[] = [];\n    queue.push(root);\n    while (queue.length > 0) {\n      const head = queue.shift()!;\n      yield head;\n      queue.push(...(children(head) || []).filter(include));\n    }\n  }\n\n  /**\n   * Returns with the iterator of the argument.\n   */\n  export function asIterator<T>(elements: ReadonlyArray<T>): IterableIterator<T> {\n    return elements.slice()[Symbol.iterator]();\n  }\n\n  /**\n   * Returns an iterator that cycles indefinitely over the elements of iterable.\n   *  - If `start` is given it starts the iteration from that element. Otherwise, it starts with the first element of the array.\n   *  - If `start` is given, it must contain by the `elements` array. Otherwise, an error will be thrown.\n   *\n   * **Warning**: Typical uses of the resulting iterator may produce an infinite loop. You should use an explicit break.\n   */\n  export function* cycle<T>(elements: ReadonlyArray<T>, start?: T): IterableIterator<T> {\n    const copy = elements.slice();\n    let index = !!start ? copy.indexOf(start) : 0;\n    if (index === -1) {\n      throw new Error(`${start} is not contained in ${copy}.`);\n    }\n    while (true) {\n      yield copy[index];\n      index++;\n      if (index === copy.length) {\n        index = 0;\n      }\n    }\n  }\n\n}\n"]}