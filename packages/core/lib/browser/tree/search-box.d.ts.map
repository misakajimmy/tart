{"version":3,"sources":["browser/tree/search-box.ts"],"names":[],"mappings":"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","file":"../../../src/browser/tree/search-box.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {SearchBoxDebounce, SearchBoxDebounceOptions} from './search-box-debounce';\nimport {BaseWidget, Message} from '../widgets/widget';\nimport {Emitter, Event} from '../../common';\nimport {Key, KeyCode} from '../keyboard/keys';\n\n/**\n * Initializer properties for the search box widget.\n */\nexport interface SearchBoxProps extends SearchBoxDebounceOptions {\n\n  /**\n   * If `true`, the `Previous`, `Next`, and `Close` buttons will be visible. Otherwise, `false`. Defaults to `false`.\n   */\n  readonly showButtons?: boolean;\n\n  /**\n   * If `true`, `Filter` and `Close` buttons will be visible, and clicking the `Filter` button will triggers filter on the search term. Defaults to `false`.\n   */\n  readonly showFilter?: boolean;\n\n}\n\nexport namespace SearchBoxProps {\n\n  /**\n   * The default search box widget option.\n   */\n  export const DEFAULT: SearchBoxProps = SearchBoxDebounceOptions.DEFAULT;\n\n}\n\n/**\n * The search box widget.\n */\nexport class SearchBox extends BaseWidget {\n\n  protected static SPECIAL_KEYS = [\n    Key.ESCAPE,\n    Key.BACKSPACE\n  ];\n\n  protected static MAX_CONTENT_LENGTH = 15;\n\n  protected readonly nextEmitter = new Emitter<void>();\n  protected readonly previousEmitter = new Emitter<void>();\n  protected readonly closeEmitter = new Emitter<void>();\n  protected readonly textChangeEmitter = new Emitter<string | undefined>();\n  protected readonly filterToggleEmitter = new Emitter<boolean>();\n  protected readonly input: HTMLSpanElement;\n  protected readonly filter: HTMLElement | undefined;\n\n  constructor(protected readonly props: SearchBoxProps,\n              protected readonly debounce: SearchBoxDebounce) {\n\n    super();\n    this.toDispose.pushAll([\n      this.nextEmitter,\n      this.previousEmitter,\n      this.closeEmitter,\n      this.textChangeEmitter,\n      this.filterToggleEmitter,\n      this.debounce,\n      this.debounce.onChanged(data => this.fireTextChange(data))\n    ]);\n    this.hide();\n    this.update();\n    const {input, filter} = this.createContent();\n    this.input = input;\n    this.filter = filter;\n  }\n\n  protected _isFiltering: boolean = false;\n\n  get isFiltering(): boolean {\n    return this._isFiltering;\n  }\n\n  get onPrevious(): Event<void> {\n    return this.previousEmitter.event;\n  }\n\n  get onNext(): Event<void> {\n    return this.nextEmitter.event;\n  }\n\n  get onClose(): Event<void> {\n    return this.closeEmitter.event;\n  }\n\n  get onTextChange(): Event<string | undefined> {\n    return this.textChangeEmitter.event;\n  }\n\n  get onFilterToggled(): Event<boolean> {\n    return this.filterToggleEmitter.event;\n  }\n\n  get keyCodePredicate(): KeyCode.Predicate {\n    return this.canHandle.bind(this);\n  }\n\n  handle(event: KeyboardEvent): void {\n    event.preventDefault();\n    const keyCode = KeyCode.createKeyCode(event);\n    if (this.canHandle(keyCode)) {\n      if (Key.equals(Key.ESCAPE, keyCode) || this.isCtrlBackspace(keyCode)) {\n        this.hide();\n      } else {\n        this.show();\n        this.handleKey(keyCode);\n      }\n    }\n  }\n\n  onBeforeHide(): void {\n    this.removeClass(SearchBox.Styles.NO_MATCH);\n    this.doFireFilterToggle(false);\n    this.debounce.append(undefined);\n    this.fireClose();\n  }\n\n  updateHighlightInfo(info: SearchBox.HighlightInfo): void {\n    if (info.filterText && info.filterText.length > 0) {\n      if (info.matched === 0) {\n        this.addClass(SearchBox.Styles.NO_MATCH);\n      } else {\n        this.removeClass(SearchBox.Styles.NO_MATCH);\n      }\n    }\n  }\n\n  protected firePrevious(): void {\n    this.previousEmitter.fire(undefined);\n  }\n\n  protected fireNext(): void {\n    this.nextEmitter.fire(undefined);\n  }\n\n  protected fireClose(): void {\n    this.closeEmitter.fire(undefined);\n  }\n\n  protected fireTextChange(input: string | undefined): void {\n    this.textChangeEmitter.fire(input);\n  }\n\n  protected fireFilterToggle(): void {\n    this.doFireFilterToggle();\n  }\n\n  protected doFireFilterToggle(toggleTo: boolean = !this._isFiltering): void {\n    if (this.filter) {\n      if (toggleTo) {\n        this.filter.classList.add(SearchBox.Styles.FILTER_ON);\n      } else {\n        this.filter.classList.remove(SearchBox.Styles.FILTER_ON);\n      }\n      this._isFiltering = toggleTo;\n      this.filterToggleEmitter.fire(toggleTo);\n      this.update();\n    }\n  }\n\n  protected handleArrowUp(): void {\n    this.firePrevious();\n  }\n\n  protected handleArrowDown(): void {\n    this.fireNext();\n  }\n\n  protected handleKey(keyCode: KeyCode): void {\n    const character = Key.equals(Key.BACKSPACE, keyCode) ? '\\b' : keyCode.character;\n    const data = this.debounce.append(character);\n    if (data) {\n      this.input.textContent = this.getTrimmedContent(data);\n      this.update();\n    } else {\n      this.hide();\n    }\n  }\n\n  protected getTrimmedContent(data: string): string {\n    if (data.length > SearchBox.MAX_CONTENT_LENGTH) {\n      return '...' + data.substring(data.length - SearchBox.MAX_CONTENT_LENGTH);\n    }\n    return data;\n  }\n\n  protected canHandle(keyCode: KeyCode | undefined): boolean {\n    if (keyCode === undefined) {\n      return false;\n    }\n    const {ctrl, alt, meta} = keyCode;\n    if (this.isCtrlBackspace(keyCode)) {\n      return true;\n    }\n    if (ctrl || alt || meta || keyCode.key === Key.SPACE) {\n      return false;\n    }\n    if (keyCode.character || (this.isVisible && SearchBox.SPECIAL_KEYS.some(key => Key.equals(key, keyCode)))) {\n      return true;\n    }\n    return false;\n  }\n\n  protected isCtrlBackspace(keyCode: KeyCode): boolean {\n    if (keyCode.ctrl && Key.equals(Key.BACKSPACE, keyCode)) {\n      return true;\n    }\n    return false;\n  }\n\n  protected createContent(): {\n    container: HTMLElement,\n    input: HTMLSpanElement,\n    filter: HTMLElement | undefined,\n    previous: HTMLElement | undefined,\n    next: HTMLElement | undefined,\n    close: HTMLElement | undefined\n  } {\n    this.node.setAttribute('tabIndex', '0');\n    this.addClass(SearchBox.Styles.SEARCH_BOX);\n\n    const input = document.createElement('span');\n    input.classList.add(SearchBox.Styles.SEARCH_INPUT);\n    this.node.appendChild(input);\n\n    const buttons = document.createElement('div');\n    buttons.classList.add(SearchBox.Styles.SEARCH_BUTTONS_WRAPPER);\n    this.node.appendChild(buttons);\n\n    let filter: HTMLElement | undefined;\n    if (this.props.showFilter) {\n      filter = document.createElement('div');\n      filter.classList.add(\n          SearchBox.Styles.BUTTON,\n          ...SearchBox.Styles.FILTER,\n      );\n      filter.title = 'Enable Filter on Type';\n      buttons.appendChild(filter);\n      filter.onclick = this.fireFilterToggle.bind(this);\n    }\n\n    let previous: HTMLElement | undefined;\n    let next: HTMLElement | undefined;\n    let close: HTMLElement | undefined;\n\n    if (!!this.props.showButtons) {\n      previous = document.createElement('div');\n      previous.classList.add(\n          SearchBox.Styles.BUTTON,\n          SearchBox.Styles.BUTTON_PREVIOUS\n      );\n      previous.title = 'Previous (Up)';\n      buttons.appendChild(previous);\n      previous.onclick = () => this.firePrevious.bind(this)();\n\n      next = document.createElement('div');\n      next.classList.add(\n          SearchBox.Styles.BUTTON,\n          SearchBox.Styles.BUTTON_NEXT\n      );\n      next.title = 'Next (Down)';\n      buttons.appendChild(next);\n      next.onclick = () => this.fireNext.bind(this)();\n    }\n\n    if (this.props.showButtons || this.props.showFilter) {\n      close = document.createElement('div');\n      close.classList.add(\n          SearchBox.Styles.BUTTON,\n          SearchBox.Styles.BUTTON_CLOSE\n      );\n      close.title = 'Close (Escape)';\n      buttons.appendChild(close);\n      close.onclick = () => this.hide.bind(this)();\n    }\n\n    return {\n      container: this.node,\n      input,\n      filter,\n      previous,\n      next,\n      close\n    };\n\n  }\n\n  protected onAfterAttach(msg: Message): void {\n    super.onAfterAttach(msg);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.addEventListener(this.input, 'selectstart' as any, () => false);\n  }\n\n}\n\nexport namespace SearchBox {\n\n  /**\n   * CSS classes for the search box widget.\n   */\n  export namespace Styles {\n\n    export const SEARCH_BOX = 'tart-search-box';\n    export const SEARCH_INPUT = 'tart-search-input';\n    export const SEARCH_BUTTONS_WRAPPER = 'tart-search-buttons-wrapper';\n    export const BUTTON = 'tart-search-button';\n    export const FILTER = ['codicon', 'codicon-filter'];\n    export const FILTER_ON = 'filter-active';\n    export const BUTTON_PREVIOUS = 'tart-search-button-previous';\n    export const BUTTON_NEXT = 'tart-search-button-next';\n    export const BUTTON_CLOSE = 'tart-search-button-close';\n    export const NON_SELECTABLE = 'tart-non-selectable';\n    export const NO_MATCH = 'no-match';\n  }\n\n  export interface HighlightInfo {\n    filterText: string | undefined,\n    matched: number,\n    total: number\n  }\n\n}\n\n/**\n * Search box factory.\n */\nexport const SearchBoxFactory = Symbol('SearchBoxFactory');\n\nexport interface SearchBoxFactory {\n\n  /**\n   * Creates a new search box with the given initializer properties.\n   */\n  (props: SearchBoxProps): SearchBox;\n\n}\n"]}