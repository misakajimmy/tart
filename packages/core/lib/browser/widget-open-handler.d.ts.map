{"version":3,"sources":["browser/widget-open-handler.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,aAAa,EAAE,WAAW,EAAC,MAAM,kBAAkB,CAAC;AAC5D,OAAO,EAAC,gBAAgB,EAAC,MAAM,SAAS,CAAC;AAEzC,OAAO,EAAC,UAAU,EAAC,MAAM,WAAW,CAAC;AACrC,OAAO,EAAC,aAAa,EAAC,MAAM,kBAAkB,CAAC;AAC/C,OAAO,GAAG,MAAM,eAAe,CAAC;AAChC,OAAO,EAAC,OAAO,EAAE,KAAK,EAAE,YAAY,EAAC,MAAM,WAAW,CAAC;AAEvD,oBAAY,cAAc,GAAG,MAAM,GAAG,QAAQ,GAAG,UAAU,CAAC;AAE5D;;GAEG;AACH,MAAM,WAAW,mBAAoB,SAAQ,aAAa;IACxD;;;OAGG;IACH,IAAI,CAAC,EAAE,cAAc,CAAC;IACtB;;;OAGG;IACH,aAAa,CAAC,EAAE,gBAAgB,CAAC,aAAa,CAAC;CAChD;AAED,8BACsB,iBAAiB,CAAC,CAAC,SAAS,UAAU,CAAE,YAAW,WAAW;IAElF;;;;;;;OAOG;IACH,QAAQ,CAAC,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAC;IAE7B,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,gBAAgB,CAAC;IAE3C,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAChD,SAAS,CAAC,QAAQ,CAAC,gBAAgB,aAAoB;IACvD;;OAEG;IACH,QAAQ,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,CAA+B;IAE3D;;;;OAIG;IACH,IAAI,GAAG,IAAI,CAAC,EAAE,CAEb;IAED,QAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,YAAY,CAAC,MAAM,CAAC;IAEjF;;;;;;;OAOG;IACG,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,CAAC,CAAC;IAM/D;;;;;OAKG;IACH,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC;IAI1C;;;;;;;OAOG;IACH,gBAAgB,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC;IAItC;;;;;OAKG;IACG,QAAQ,CAAC,OAAO,CAAC,EAAE,gBAAgB,CAAC,YAAY,GAAG,OAAO,CAAC,CAAC,EAAE,CAAC;IAMrE,SAAS,CAAC,IAAI,IAAI,IAAI;cAQN,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,IAAI,CAAC;IAe/E,SAAS,CAAC,mBAAmB,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,YAAY,CAAC,CAAC,CAAC,GAAG,SAAS;IAKnG,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,CAAC,GAAG,SAAS,CAAC;IAKpF,SAAS,CAAC,iBAAiB,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,CAAC,CAAC;IAKhF,SAAS,CAAC,QAAQ,CAAC,mBAAmB,CAAC,GAAG,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,MAAM;CAExF","file":"../../src/browser/widget-open-handler.d.ts","sourcesContent":["import {OpenerOptions, OpenHandler} from './opener-service';\nimport {ApplicationShell} from './shell';\nimport {inject, injectable, postConstruct} from 'inversify';\nimport {BaseWidget} from './widgets';\nimport {WidgetManager} from './widget-manager';\nimport URI from '../common/uri';\nimport {Emitter, Event, MaybePromise} from '../common';\n\nexport type WidgetOpenMode = 'open' | 'reveal' | 'activate';\n\n/**\n * `WidgetOpenerOptions` define serializable generic options used by the {@link WidgetOpenHandler}.\n */\nexport interface WidgetOpenerOptions extends OpenerOptions {\n  /**\n   * Determines whether the widget should be only opened, revealed or activated.\n   * By default is `activate`.\n   */\n  mode?: WidgetOpenMode;\n  /**\n   * Specify how an opened widget should be added to the shell.\n   * By default to the main area.\n   */\n  widgetOptions?: ApplicationShell.WidgetOptions;\n}\n\n@injectable()\nexport abstract class WidgetOpenHandler<W extends BaseWidget> implements OpenHandler {\n\n  /**\n   * The widget open handler id.\n   *\n   * #### Implementation\n   * - A widget factory for this id should be registered.\n   * - Subclasses should not implement `WidgetFactory`\n   * to avoid exposing capabilities to create a widget outside of `WidgetManager`.\n   */\n  abstract readonly id: string;\n  @inject(ApplicationShell)\n  protected readonly shell: ApplicationShell;\n  @inject(WidgetManager)\n  protected readonly widgetManager: WidgetManager;\n  protected readonly onCreatedEmitter = new Emitter<W>();\n  /**\n   * Emit when a new widget is created.\n   */\n  readonly onCreated: Event<W> = this.onCreatedEmitter.event;\n\n  /**\n   * Retrieves all open widgets that have been opened by this handler.\n   *\n   * @returns all open widgets for this open handler.\n   */\n  get all(): W[] {\n    return this.widgetManager.getWidgets(this.id) as W[];\n  }\n\n  abstract canHandle(uri: URI, options?: WidgetOpenerOptions): MaybePromise<number>;\n\n  /**\n   * Open a widget for the given uri and options.\n   * Reject if the given options are not widget options or a widget cannot be opened.\n   * @param uri the uri of the resource that should be opened.\n   * @param options the widget opener options.\n   *\n   * @returns promise of the widget that resolves when the widget has been opened.\n   */\n  async open(uri: URI, options?: WidgetOpenerOptions): Promise<W> {\n    const widget = await this.getOrCreateWidget(uri, options);\n    await this.doOpen(widget, options);\n    return widget;\n  }\n\n  /**\n   * Tries to get an existing widget for the given uri.\n   * @param uri the uri of the widget.\n   *\n   * @returns a promise that resolves to the existing widget or `undefined` if no widget for the given uri exists.\n   */\n  getByUri(uri: URI): Promise<W | undefined> {\n    return this.getWidget(uri);\n  }\n\n  /**\n   * Return an existing widget for the given uri or creates a new one.\n   *\n   * It does not open a widget, use {@link WidgetOpenHandler#open} instead.\n   * @param uri uri of the widget.\n   *\n   * @returns a promise of the existing or newly created widget.\n   */\n  getOrCreateByUri(uri: URI): Promise<W> {\n    return this.getOrCreateWidget(uri);\n  }\n\n  /**\n   * Closes all widgets that have been opened by this open handler.\n   * @param options the close options that should be applied to all widgets.\n   *\n   * @returns a promise of all closed widgets that resolves after they have been closed.\n   */\n  async closeAll(options?: ApplicationShell.CloseOptions): Promise<W[]> {\n    const closed = await Promise.all(this.all.map(widget => this.shell.closeWidget(widget.id, options)));\n    return closed.filter(widget => !!widget) as W[];\n  }\n\n  @postConstruct()\n  protected init(): void {\n    this.widgetManager.onDidCreateWidget(({factoryId, widget}) => {\n      if (factoryId === this.id) {\n        this.onCreatedEmitter.fire(widget as W);\n      }\n    });\n  }\n\n  protected async doOpen(widget: W, options?: WidgetOpenerOptions): Promise<void> {\n    const op: WidgetOpenerOptions = {\n      mode: 'activate',\n      ...options\n    };\n    if (!widget.isAttached) {\n      this.shell.addWidget(widget, op.widgetOptions || {area: 'main'});\n    }\n    if (op.mode === 'activate') {\n      await this.shell.activateWidget(widget.id);\n    } else if (op.mode === 'reveal') {\n      await this.shell.revealWidget(widget.id);\n    }\n  }\n\n  protected tryGetPendingWidget(uri: URI, options?: WidgetOpenerOptions): MaybePromise<W> | undefined {\n    const factoryOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.tryGetPendingWidget(this.id, factoryOptions);\n  }\n\n  protected getWidget(uri: URI, options?: WidgetOpenerOptions): Promise<W | undefined> {\n    const widgetOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.getWidget<W>(this.id, widgetOptions);\n  }\n\n  protected getOrCreateWidget(uri: URI, options?: WidgetOpenerOptions): Promise<W> {\n    const widgetOptions = this.createWidgetOptions(uri, options);\n    return this.widgetManager.getOrCreateWidget<W>(this.id, widgetOptions);\n  }\n\n  protected abstract createWidgetOptions(uri: URI, options?: WidgetOpenerOptions): Object;\n\n}\n"]}