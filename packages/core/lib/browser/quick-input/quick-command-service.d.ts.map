{"version":3,"sources":["browser/quick-input/quick-command-service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,iBAAiB,EAAE,OAAO,EAAE,eAAe,EAAE,UAAU,EAAC,MAAM,cAAc,CAAC;AAErF,OAAO,EAAC,uBAAuB,EAAE,mBAAmB,EAAC,MAAM,gBAAgB,CAAC;AAC5E,OAAO,EAAC,iBAAiB,EAAC,MAAM,wBAAwB,CAAC;AACzD,OAAO,EAAC,eAAe,EAAC,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAC,kBAAkB,EAAC,MAAM,eAAe,CAAC;AACjD,OAAO,EAA6B,UAAU,EAAC,MAAM,iCAAiC,CAAC;AAIvF,eAAO,MAAM,YAAY,EAAE,OAE1B,CAAC;AAEF,eAAO,MAAM,qBAAqB,SAGhC,CAAC;AAGH,qBACa,mBAAoB,YAAW,uBAAuB,EAAE,mBAAmB;IACtF,MAAM,CAAC,MAAM,SAAO;IAEpB,QAAQ,CAAC,gBAAgB,EAAE,OAAO,EAAE,CAElC;IAEF,SAAS,CAAC,QAAQ,CAAC,iBAAiB,EAAE,iBAAiB,CAAC;IAExD,SAAS,CAAC,QAAQ,CAAC,eAAe,EAAE,eAAe,CAAC;IAEpD,SAAS,CAAC,QAAQ,CAAC,eAAe,EAAE,eAAe,CAAC;IAIpD,SAAS,CAAC,QAAQ,CAAC,kBAAkB,EAAE,kBAAkB,CAAC;IAC1D,SAAS,CAAC,QAAQ,CAAC,QAAQ,wBAA+B;IAC1D,OAAO,CAAC,WAAW,CAAuB;IAC1C,OAAO,CAAC,UAAU,CAAuB;IAEzC,2BAA2B,IAAI,IAAI;IASnC,KAAK,IAAI,IAAI;IAQb,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,iBAAiB,GAAG,UAAU;IAqB9D,kBAAkB,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAG,UAAU;IAY/D;;;;;OAKG;IACH,SAAS,CAAC,gBAAgB,CAAC,GAAG,EAAE,OAAO,EAAE,GAAG,OAAO,EAAE;IAarD;;;;OAIG;IACH,SAAS,CAAC,WAAW,IAAI;QAAE,MAAM,EAAE,OAAO,EAAE,CAAC;QAAC,KAAK,EAAE,OAAO,EAAE,CAAA;KAAE;IAqChE,OAAO,CAAC,MAAM;IA0Bd,OAAO,CAAC,aAAa;IAarB,OAAO,CAAC,kBAAkB;IAQ1B;;;;;;OAMG;IACH,OAAO,CAAC,SAAS;IAIjB;;;;;OAKG;IACH,OAAO,CAAC,IAAI;CAGb","file":"../../../src/browser/quick-input/quick-command-service.d.ts","sourcesContent":["import {CancellationToken, Command, CommandRegistry, Disposable} from '../../common';\nimport {inject, injectable} from 'inversify';\nimport {QuickAccessContribution, QuickAccessProvider} from './quick-access';\nimport {ContextKeyService} from '../context-key-service';\nimport {CorePreferences} from '../core-preferences';\nimport {KeybindingRegistry} from '../keybinding';\nimport {filterItems, QuickPickItem, QuickPicks} from '../../common/quick-pick-service';\nimport {KeySequence} from '../keyboard';\nimport {codiconArray} from '../widgets';\n\nexport const quickCommand: Command = {\n  id: 'workbench.action.showCommands'\n};\n\nexport const CLEAR_COMMAND_HISTORY = Command.toDefaultLocalizedCommand({\n  id: 'clear.command.history',\n  label: 'Clear Command History'\n});\n\n\n@injectable()\nexport class QuickCommandService implements QuickAccessContribution, QuickAccessProvider {\n  static PREFIX = '>';\n  // The list of exempted commands not to be displayed in the recently used list.\n  readonly exemptedCommands: Command[] = [\n    CLEAR_COMMAND_HISTORY,\n  ];\n  @inject(ContextKeyService)\n  protected readonly contextKeyService: ContextKeyService;\n  @inject(CommandRegistry)\n  protected readonly commandRegistry: CommandRegistry;\n  @inject(CorePreferences)\n  protected readonly corePreferences: CorePreferences;\n  // @inject(QuickAccessRegistry)\n  // protected readonly quickAccessRegistry: QuickAccessRegistry;\n  @inject(KeybindingRegistry)\n  protected readonly keybindingRegistry: KeybindingRegistry;\n  protected readonly contexts = new Map<string, string[]>();\n  private recentItems: QuickPickItem[] = [];\n  private otherItems: QuickPickItem[] = [];\n\n  registerQuickAccessProvider(): void {\n    // this.quickAccessRegistry.registerQuickAccessProvider({\n    //   getInstance: () => this,\n    //   prefix: QuickCommandService.PREFIX,\n    //   placeholder: '',\n    //   helpEntries: [{description: 'Quick Command', needsEditor: false}]\n    // });\n  }\n\n  reset(): void {\n    const {recent, other} = this.getCommands();\n    this.recentItems = [];\n    this.otherItems = [];\n    this.recentItems.push(...recent.map(command => this.toItem(command)));\n    this.otherItems.push(...other.map(command => this.toItem(command)));\n  }\n\n  getPicks(filter: string, token: CancellationToken): QuickPicks {\n    const items: QuickPicks = [];\n\n    // Update the list of commands by fetching them from the registry.\n    this.reset();\n    const recentItems = filterItems(this.recentItems.slice(), filter);\n    const otherItems = filterItems(this.otherItems.slice(), filter);\n\n    if (recentItems.length > 0) {\n      items.push({type: 'separator', label: 'recently used'}, ...recentItems);\n    }\n\n    if (otherItems.length > 0) {\n      if (recentItems.length > 0) {\n        items.push({type: 'separator', label: 'other commands'});\n      }\n      items.push(...otherItems);\n    }\n    return items;\n  }\n\n  pushCommandContext(commandId: string, when: string): Disposable {\n    const contexts = this.contexts.get(commandId) || [];\n    contexts.push(when);\n    this.contexts.set(commandId, contexts);\n    return Disposable.create(() => {\n      const index = contexts.indexOf(when);\n      if (index !== -1) {\n        contexts.splice(index, 1);\n      }\n    });\n  }\n\n  /**\n   * Get the list of valid commands.\n   *\n   * @param commands the list of raw commands.\n   * @returns the list of valid commands.\n   */\n  protected getValidCommands(raw: Command[]): Command[] {\n    const valid: Command[] = [];\n    raw.forEach(command => {\n      if (command.label) {\n        const contexts = this.contexts.get(command.id);\n        if (!contexts || contexts.some(when => this.contextKeyService.match(when))) {\n          valid.push(command);\n        }\n      }\n    });\n    return valid;\n  }\n\n  /**\n   * Get the list of recently used and other commands.\n   *\n   * @returns the list of recently used commands and other commands.\n   */\n  protected getCommands(): { recent: Command[], other: Command[] } {\n\n    // Get the list of recent commands.\n    const recentCommands = this.commandRegistry.recent;\n\n    // Get the list of all valid commands.\n    const allCommands = this.getValidCommands(this.commandRegistry.commands);\n\n    // Get the max history limit.\n    const limit = this.corePreferences['workbench.commandPalette.history'];\n\n    // Build the list of recent commands.\n    let rCommands: Command[] = [];\n    if (limit > 0) {\n      rCommands.push(...recentCommands.filter(r =>\n          !this.exemptedCommands.some(c => Command.equals(r, c)) &&\n          allCommands.some(c => Command.equals(r, c)))\n      );\n      if (rCommands.length > limit) {\n        rCommands = rCommands.slice(0, limit);\n      }\n    }\n\n    // Build the list of other commands.\n    const oCommands = allCommands.filter(c => !rCommands.some(r => Command.equals(r, c)));\n\n    // Normalize the list of recent commands.\n    const recent = this.normalize(rCommands);\n\n    // Normalize, and sort the list of other commands.\n    const other = this.sort(\n        this.normalize(oCommands)\n    );\n\n    return {recent, other};\n  }\n\n  private toItem(command: Command): QuickPickItem {\n    const label = (command.category) ? `${command.category}: ` + command.label! : command.label!;\n    const iconClasses = this.getItemIconClasses(command);\n    const activeElement = window.document.activeElement as HTMLElement;\n\n    const originalLabel = command.originalLabel || command.label!;\n    const originalCategory = command.originalCategory || command.category;\n    let detail: string | undefined = originalCategory ? `${originalCategory}: ${originalLabel}` : originalLabel;\n    if (label === detail) {\n      detail = undefined;\n    }\n\n    return {\n      label,\n      detail,\n      iconClasses,\n      alwaysShow: !!this.commandRegistry.getActiveHandler(command.id),\n      keySequence: this.getKeybinding(command),\n      execute: () => {\n        activeElement.focus({preventScroll: true});\n        this.commandRegistry.executeCommand(command.id);\n        this.commandRegistry.addRecentCommand(command);\n      }\n    };\n  }\n\n  private getKeybinding(command: Command): KeySequence | undefined {\n    const keybindings = this.keybindingRegistry.getKeybindingsForCommand(command.id);\n    if (!keybindings || keybindings.length === 0) {\n      return undefined;\n    }\n\n    try {\n      return this.keybindingRegistry.resolveKeybinding(keybindings[0]);\n    } catch (error) {\n      return undefined;\n    }\n  }\n\n  private getItemIconClasses(command: Command): string[] | undefined {\n    const toggledHandler = this.commandRegistry.getToggledHandler(command.id);\n    if (toggledHandler) {\n      return codiconArray('check');\n    }\n    return undefined;\n  }\n\n  /**\n   * Normalizes a list of commands.\n   * Normalization includes obtaining commands that have labels, are visible, and are enabled.\n   *\n   * @param commands the list of commands.\n   * @returns the list of normalized commands.\n   */\n  private normalize(commands: Command[]): Command[] {\n    return commands.filter((a: Command) => a.label && (this.commandRegistry.isVisible(a.id) && this.commandRegistry.isEnabled(a.id)));\n  }\n\n  /**\n   * Sorts a list of commands alphabetically.\n   *\n   * @param commands the list of commands.\n   * @returns the list of sorted commands.\n   */\n  private sort(commands: Command[]): Command[] {\n    return commands.sort((a: Command, b: Command) => Command.compareCommands(a, b));\n  }\n}\n"]}