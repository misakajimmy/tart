{"version":3,"sources":["common/messaging/proxy-factory.ts"],"names":[],"mappings":"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","file":"../../../src/common/messaging/proxy-factory.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {ApplicationError} from '../application-error';\nimport {Event,} from '../event';\nimport {Emitter} from '../emitter';\nimport {Disposable} from '../disposable';\nimport {ConnectionHandler} from './handler';\n\nexport type JsonRpcServer<Client> = Disposable & {\n  /**\n   * If this server is a proxy to a remote server then\n   * a client is used as a local object\n   * to handle JSON-RPC messages from the remote server.\n   */\n  setClient(client: Client | undefined): void;\n  getClient?(): Client | undefined;\n};\n\nexport interface JsonRpcConnectionEventEmitter {\n  readonly onDidOpenConnection: Event<void>;\n  readonly onDidCloseConnection: Event<void>;\n}\n\nexport type JsonRpcProxy<T> = T & JsonRpcConnectionEventEmitter;\n\nexport class JsonRpcConnectionHandler<T extends object> implements ConnectionHandler {\n  constructor(\n      readonly path: string,\n      readonly targetFactory: (proxy: JsonRpcProxy<T>) => any,\n      readonly factoryConstructor: new () => JsonRpcProxyFactory<T> = JsonRpcProxyFactory\n  ) {\n  }\n\n  onConnection(connection: any): void {\n    const factory = new this.factoryConstructor();\n    const proxy = factory.createProxy();\n    factory.target = this.targetFactory(proxy);\n    factory.listen(connection);\n  }\n}\n\n/**\n * Factory for JSON-RPC proxy objects.\n *\n * A JSON-RPC proxy exposes the programmatic interface of an object through\n * JSON-RPC.  This allows remote programs to call methods of this objects by\n * sending JSON-RPC requests.  This takes place over a bi-directional stream,\n * where both ends can expose an object and both can call methods each other's\n * exposed object.\n *\n * For example, assuming we have an object of the following type on one end:\n *\n *     class Foo {\n *         bar(baz: number): number { return baz + 1 }\n *     }\n *\n * which we want to expose through a JSON-RPC interface.  We would do:\n *\n *     let target = new Foo()\n *     let factory = new JsonRpcProxyFactory<Foo>('/foo', target)\n *     factory.onConnection(connection)\n *\n * The party at the other end of the `connection`, in order to remotely call\n * methods on this object would do:\n *\n *     let factory = new JsonRpcProxyFactory<Foo>('/foo')\n *     factory.onConnection(connection)\n *     let proxy = factory.createProxy();\n *     let result = proxy.bar(42)\n *     // result is equal to 43\n *\n * One the wire, it would look like this:\n *\n *     --> {\"jsonrpc\": \"2.0\", \"id\": 0, \"method\": \"bar\", \"params\": {\"baz\": 42}}\n *     <-- {\"jsonrpc\": \"2.0\", \"id\": 0, \"result\": 43}\n *\n * Note that in the code of the caller, we didn't pass a target object to\n * JsonRpcProxyFactory, because we don't want/need to expose an object.\n * If we had passed a target object, the other side could've called methods on\n * it.\n *\n * @param <T> - The type of the object to expose to JSON-RPC.\n */\nexport class JsonRpcProxyFactory<T extends object> implements ProxyHandler<T> {\n\n  protected readonly onDidOpenConnectionEmitter = new Emitter<void>();\n  protected readonly onDidCloseConnectionEmitter = new Emitter<void>();\n\n  protected connectionPromiseResolve: (connection: any) => void;\n  protected connectionPromise: Promise<any>;\n\n  /**\n   * Build a new JsonRpcProxyFactory.\n   *\n   * @param target - The object to expose to JSON-RPC methods calls.  If this\n   *   is omitted, the proxy won't be able to handle requests, only send them.\n   */\n  constructor(public target?: any) {\n    this.waitForConnection();\n  }\n\n  /**\n   * Connect a MessageConnection to the factory.\n   *\n   * This connection will be used to send/receive JSON-RPC requests and\n   * response.\n   */\n  listen(connection: any): void {\n    connection.onRequest((prop, ...args) => this.onRequest(prop, ...args));\n    connection.onNotification((prop, ...args) => this.onNotification(prop, ...args));\n    connection.onDispose(() => this.waitForConnection());\n    connection.listen();\n    this.connectionPromiseResolve(connection);\n  }\n\n  /**\n   * Create a Proxy exposing the interface of an object of type T.  This Proxy\n   * can be used to do JSON-RPC method calls on the remote target object as\n   * if it was local.\n   *\n   * If `T` implements `JsonRpcServer` then a client is used as a target object for a remote target object.\n   */\n  createProxy(): JsonRpcProxy<T> {\n    const result = new Proxy<T>(this as any, this);\n    return result as any;\n  }\n\n  /**\n   * Get a callable object that executes a JSON-RPC method call.\n   *\n   * Getting a property on the Proxy object returns a callable that, when\n   * called, executes a JSON-RPC call.  The name of the property defines the\n   * method to be called.  The callable takes a variable number of arguments,\n   * which are passed in the JSON-RPC method call.\n   *\n   * For example, if you have a Proxy object:\n   *\n   *     let fooProxyFactory = JsonRpcProxyFactory<Foo>('/foo')\n   *     let fooProxy = fooProxyFactory.createProxy()\n   *\n   * accessing `fooProxy.bar` will return a callable that, when called,\n   * executes a JSON-RPC method call to method `bar`.  Therefore, doing\n   * `fooProxy.bar()` will call the `bar` method on the remote Foo object.\n   *\n   * @param target - unused.\n   * @param p - The property accessed on the Proxy object.\n   * @param receiver - unused.\n   * @returns A callable that executes the JSON-RPC call.\n   */\n  get(target: T, p: PropertyKey, receiver: any): any {\n    if (p === 'setClient') {\n      return (client: any) => {\n        this.target = client;\n      };\n    }\n    if (p === 'getClient') {\n      return () => this.target;\n    }\n    if (p === 'onDidOpenConnection') {\n      return this.onDidOpenConnectionEmitter.event;\n    }\n    if (p === 'onDidCloseConnection') {\n      return this.onDidCloseConnectionEmitter.event;\n    }\n    const isNotify = this.isNotification(p);\n    return (...args: any[]) => {\n      const method = p.toString();\n      const capturedError = new Error(`Request '${method}' failed`);\n      return this.connectionPromise.then(connection =>\n          new Promise((resolve, reject) => {\n            try {\n              if (isNotify) {\n                connection.sendNotification(method, ...args);\n                resolve(0);\n              } else {\n                const resultPromise = connection.sendRequest(method, ...args) as Promise<any>;\n                resultPromise\n                    .catch((err: any) => reject(this.deserializeError(capturedError, err)))\n                    .then((result: any) => resolve(result));\n              }\n            } catch (err) {\n              reject(err);\n            }\n          })\n      );\n    };\n  }\n\n  protected waitForConnection(): void {\n    this.connectionPromise = new Promise(resolve =>\n        this.connectionPromiseResolve = resolve\n    );\n    this.connectionPromise.then(connection => {\n      connection.onClose(() =>\n          this.onDidCloseConnectionEmitter.fire(undefined)\n      );\n      this.onDidOpenConnectionEmitter.fire(undefined);\n    });\n  }\n\n  /**\n   * Process an incoming JSON-RPC method call.\n   *\n   * onRequest is called when the JSON-RPC connection received a method call\n   * request.  It calls the corresponding method on [[target]].\n   *\n   * The return value is a Promise object that is resolved with the return\n   * value of the method call, if it is successful.  The promise is rejected\n   * if the called method does not exist or if it throws.\n   *\n   * @returns A promise of the method call completion.\n   */\n  protected async onRequest(method: string, ...args: any[]): Promise<any> {\n    try {\n      if (this.target) {\n        return await this.target[method](...args);\n      } else {\n        throw new Error(`no target was set to handle ${method}`);\n      }\n    } catch (error) {\n      const e = this.serializeError(error);\n      if (e) {\n        throw e;\n      }\n      const reason = e.message || '';\n      const stack = e.stack || '';\n      console.error(`Request ${method} failed with error: ${reason}`, stack);\n      throw e;\n    }\n  }\n\n  /**\n   * Process an incoming JSON-RPC notification.\n   *\n   * Same as [[onRequest]], but called on incoming notifications rather than\n   * methods calls.\n   */\n  protected onNotification(method: string, ...args: any[]): void {\n    if (this.target) {\n      this.target[method](...args);\n    }\n  }\n\n  /**\n   * Return whether the given property represents a notification.\n   *\n   * A property leads to a notification rather than a method call if its name\n   * begins with `notify` or `on`.\n   *\n   * @param p - The property being called on the proxy.\n   * @return Whether `p` represents a notification.\n   */\n  protected isNotification(p: PropertyKey): boolean {\n    return p.toString().startsWith('notify') || p.toString().startsWith('on');\n  }\n\n  protected serializeError(e: any): any {\n    if (ApplicationError.is(e)) {\n      return e;\n    }\n    return e;\n  }\n\n  protected deserializeError(capturedError: Error, e: any): any {\n    if (e) {\n      const capturedStack = capturedError.stack || '';\n      if (e.data && e.data.kind === 'application') {\n        const {stack, data, message} = e.data;\n        return ApplicationError.fromJson(e.code, {\n          message: message || capturedError.message,\n          data,\n          stack: `${capturedStack}\\nCaused by: ${stack}`\n        });\n      }\n      e.stack = capturedStack;\n    }\n    return e;\n  }\n\n}\n"]}