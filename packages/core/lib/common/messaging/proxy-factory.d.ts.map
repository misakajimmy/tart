{"version":3,"sources":["common/messaging/proxy-factory.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAKlF,OAAO,EAAC,KAAK,EAAE,MAAM,UAAU,CAAC;AAChC,OAAO,EAAC,OAAO,EAAC,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,UAAU,EAAC,MAAM,eAAe,CAAC;AACzC,OAAO,EAAC,iBAAiB,EAAC,MAAM,WAAW,CAAC;AAE5C,oBAAY,aAAa,CAAC,MAAM,IAAI,UAAU,GAAG;IAC/C;;;;OAIG;IACH,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,SAAS,GAAG,IAAI,CAAC;IAC5C,SAAS,CAAC,IAAI,MAAM,GAAG,SAAS,CAAC;CAClC,CAAC;AAEF,MAAM,WAAW,6BAA6B;IAC5C,QAAQ,CAAC,mBAAmB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1C,QAAQ,CAAC,oBAAoB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;CAC5C;AAED,oBAAY,YAAY,CAAC,CAAC,IAAI,CAAC,GAAG,6BAA6B,CAAC;AAEhE,qBAAa,wBAAwB,CAAC,CAAC,SAAS,MAAM,CAAE,YAAW,iBAAiB;IAE9E,QAAQ,CAAC,IAAI,EAAE,MAAM;IACrB,QAAQ,CAAC,aAAa,EAAE,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG;IACvD,QAAQ,CAAC,kBAAkB,EAAE,UAAU,mBAAmB,CAAC,CAAC,CAAC;gBAFpD,IAAI,EAAE,MAAM,EACZ,aAAa,EAAE,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,EAC9C,kBAAkB,GAAE,UAAU,mBAAmB,CAAC,CAAC,CAAuB;IAIvF,YAAY,CAAC,UAAU,EAAE,GAAG,GAAG,IAAI;CAMpC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyCG;AACH,qBAAa,mBAAmB,CAAC,CAAC,SAAS,MAAM,CAAE,YAAW,YAAY,CAAC,CAAC,CAAC;IAcxD,MAAM,CAAC,EAAE,GAAG;IAZ/B,SAAS,CAAC,QAAQ,CAAC,0BAA0B,gBAAuB;IACpE,SAAS,CAAC,QAAQ,CAAC,2BAA2B,gBAAuB;IAErE,SAAS,CAAC,wBAAwB,EAAE,CAAC,UAAU,EAAE,GAAG,KAAK,IAAI,CAAC;IAC9D,SAAS,CAAC,iBAAiB,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;IAE1C;;;;;OAKG;gBACgB,MAAM,CAAC,EAAE,GAAG;IAI/B;;;;;OAKG;IACH,MAAM,CAAC,UAAU,EAAE,GAAG,GAAG,IAAI;IAQ7B;;;;;;OAMG;IACH,WAAW,IAAI,YAAY,CAAC,CAAC,CAAC;IAK9B;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,WAAW,EAAE,QAAQ,EAAE,GAAG,GAAG,GAAG;IAuClD,SAAS,CAAC,iBAAiB,IAAI,IAAI;IAYnC;;;;;;;;;;;OAWG;cACa,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC;IAmBvE;;;;;OAKG;IACH,SAAS,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,IAAI;IAM9D;;;;;;;;OAQG;IACH,SAAS,CAAC,cAAc,CAAC,CAAC,EAAE,WAAW,GAAG,OAAO;IAIjD,SAAS,CAAC,cAAc,CAAC,CAAC,EAAE,GAAG,GAAG,GAAG;IAOrC,SAAS,CAAC,gBAAgB,CAAC,aAAa,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,GAAG,GAAG;CAgB9D","file":"../../../src/common/messaging/proxy-factory.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {ApplicationError} from '../application-error';\nimport {Event,} from '../event';\nimport {Emitter} from '../emitter';\nimport {Disposable} from '../disposable';\nimport {ConnectionHandler} from './handler';\n\nexport type JsonRpcServer<Client> = Disposable & {\n  /**\n   * If this server is a proxy to a remote server then\n   * a client is used as a local object\n   * to handle JSON-RPC messages from the remote server.\n   */\n  setClient(client: Client | undefined): void;\n  getClient?(): Client | undefined;\n};\n\nexport interface JsonRpcConnectionEventEmitter {\n  readonly onDidOpenConnection: Event<void>;\n  readonly onDidCloseConnection: Event<void>;\n}\n\nexport type JsonRpcProxy<T> = T & JsonRpcConnectionEventEmitter;\n\nexport class JsonRpcConnectionHandler<T extends object> implements ConnectionHandler {\n  constructor(\n      readonly path: string,\n      readonly targetFactory: (proxy: JsonRpcProxy<T>) => any,\n      readonly factoryConstructor: new () => JsonRpcProxyFactory<T> = JsonRpcProxyFactory\n  ) {\n  }\n\n  onConnection(connection: any): void {\n    const factory = new this.factoryConstructor();\n    const proxy = factory.createProxy();\n    factory.target = this.targetFactory(proxy);\n    factory.listen(connection);\n  }\n}\n\n/**\n * Factory for JSON-RPC proxy objects.\n *\n * A JSON-RPC proxy exposes the programmatic interface of an object through\n * JSON-RPC.  This allows remote programs to call methods of this objects by\n * sending JSON-RPC requests.  This takes place over a bi-directional stream,\n * where both ends can expose an object and both can call methods each other's\n * exposed object.\n *\n * For example, assuming we have an object of the following type on one end:\n *\n *     class Foo {\n *         bar(baz: number): number { return baz + 1 }\n *     }\n *\n * which we want to expose through a JSON-RPC interface.  We would do:\n *\n *     let target = new Foo()\n *     let factory = new JsonRpcProxyFactory<Foo>('/foo', target)\n *     factory.onConnection(connection)\n *\n * The party at the other end of the `connection`, in order to remotely call\n * methods on this object would do:\n *\n *     let factory = new JsonRpcProxyFactory<Foo>('/foo')\n *     factory.onConnection(connection)\n *     let proxy = factory.createProxy();\n *     let result = proxy.bar(42)\n *     // result is equal to 43\n *\n * One the wire, it would look like this:\n *\n *     --> {\"jsonrpc\": \"2.0\", \"id\": 0, \"method\": \"bar\", \"params\": {\"baz\": 42}}\n *     <-- {\"jsonrpc\": \"2.0\", \"id\": 0, \"result\": 43}\n *\n * Note that in the code of the caller, we didn't pass a target object to\n * JsonRpcProxyFactory, because we don't want/need to expose an object.\n * If we had passed a target object, the other side could've called methods on\n * it.\n *\n * @param <T> - The type of the object to expose to JSON-RPC.\n */\nexport class JsonRpcProxyFactory<T extends object> implements ProxyHandler<T> {\n\n  protected readonly onDidOpenConnectionEmitter = new Emitter<void>();\n  protected readonly onDidCloseConnectionEmitter = new Emitter<void>();\n\n  protected connectionPromiseResolve: (connection: any) => void;\n  protected connectionPromise: Promise<any>;\n\n  /**\n   * Build a new JsonRpcProxyFactory.\n   *\n   * @param target - The object to expose to JSON-RPC methods calls.  If this\n   *   is omitted, the proxy won't be able to handle requests, only send them.\n   */\n  constructor(public target?: any) {\n    this.waitForConnection();\n  }\n\n  /**\n   * Connect a MessageConnection to the factory.\n   *\n   * This connection will be used to send/receive JSON-RPC requests and\n   * response.\n   */\n  listen(connection: any): void {\n    connection.onRequest((prop, ...args) => this.onRequest(prop, ...args));\n    connection.onNotification((prop, ...args) => this.onNotification(prop, ...args));\n    connection.onDispose(() => this.waitForConnection());\n    connection.listen();\n    this.connectionPromiseResolve(connection);\n  }\n\n  /**\n   * Create a Proxy exposing the interface of an object of type T.  This Proxy\n   * can be used to do JSON-RPC method calls on the remote target object as\n   * if it was local.\n   *\n   * If `T` implements `JsonRpcServer` then a client is used as a target object for a remote target object.\n   */\n  createProxy(): JsonRpcProxy<T> {\n    const result = new Proxy<T>(this as any, this);\n    return result as any;\n  }\n\n  /**\n   * Get a callable object that executes a JSON-RPC method call.\n   *\n   * Getting a property on the Proxy object returns a callable that, when\n   * called, executes a JSON-RPC call.  The name of the property defines the\n   * method to be called.  The callable takes a variable number of arguments,\n   * which are passed in the JSON-RPC method call.\n   *\n   * For example, if you have a Proxy object:\n   *\n   *     let fooProxyFactory = JsonRpcProxyFactory<Foo>('/foo')\n   *     let fooProxy = fooProxyFactory.createProxy()\n   *\n   * accessing `fooProxy.bar` will return a callable that, when called,\n   * executes a JSON-RPC method call to method `bar`.  Therefore, doing\n   * `fooProxy.bar()` will call the `bar` method on the remote Foo object.\n   *\n   * @param target - unused.\n   * @param p - The property accessed on the Proxy object.\n   * @param receiver - unused.\n   * @returns A callable that executes the JSON-RPC call.\n   */\n  get(target: T, p: PropertyKey, receiver: any): any {\n    if (p === 'setClient') {\n      return (client: any) => {\n        this.target = client;\n      };\n    }\n    if (p === 'getClient') {\n      return () => this.target;\n    }\n    if (p === 'onDidOpenConnection') {\n      return this.onDidOpenConnectionEmitter.event;\n    }\n    if (p === 'onDidCloseConnection') {\n      return this.onDidCloseConnectionEmitter.event;\n    }\n    const isNotify = this.isNotification(p);\n    return (...args: any[]) => {\n      const method = p.toString();\n      const capturedError = new Error(`Request '${method}' failed`);\n      return this.connectionPromise.then(connection =>\n          new Promise((resolve, reject) => {\n            try {\n              if (isNotify) {\n                connection.sendNotification(method, ...args);\n                resolve(0);\n              } else {\n                const resultPromise = connection.sendRequest(method, ...args) as Promise<any>;\n                resultPromise\n                    .catch((err: any) => reject(this.deserializeError(capturedError, err)))\n                    .then((result: any) => resolve(result));\n              }\n            } catch (err) {\n              reject(err);\n            }\n          })\n      );\n    };\n  }\n\n  protected waitForConnection(): void {\n    this.connectionPromise = new Promise(resolve =>\n        this.connectionPromiseResolve = resolve\n    );\n    this.connectionPromise.then(connection => {\n      connection.onClose(() =>\n          this.onDidCloseConnectionEmitter.fire(undefined)\n      );\n      this.onDidOpenConnectionEmitter.fire(undefined);\n    });\n  }\n\n  /**\n   * Process an incoming JSON-RPC method call.\n   *\n   * onRequest is called when the JSON-RPC connection received a method call\n   * request.  It calls the corresponding method on [[target]].\n   *\n   * The return value is a Promise object that is resolved with the return\n   * value of the method call, if it is successful.  The promise is rejected\n   * if the called method does not exist or if it throws.\n   *\n   * @returns A promise of the method call completion.\n   */\n  protected async onRequest(method: string, ...args: any[]): Promise<any> {\n    try {\n      if (this.target) {\n        return await this.target[method](...args);\n      } else {\n        throw new Error(`no target was set to handle ${method}`);\n      }\n    } catch (error) {\n      const e = this.serializeError(error);\n      if (e) {\n        throw e;\n      }\n      const reason = e.message || '';\n      const stack = e.stack || '';\n      console.error(`Request ${method} failed with error: ${reason}`, stack);\n      throw e;\n    }\n  }\n\n  /**\n   * Process an incoming JSON-RPC notification.\n   *\n   * Same as [[onRequest]], but called on incoming notifications rather than\n   * methods calls.\n   */\n  protected onNotification(method: string, ...args: any[]): void {\n    if (this.target) {\n      this.target[method](...args);\n    }\n  }\n\n  /**\n   * Return whether the given property represents a notification.\n   *\n   * A property leads to a notification rather than a method call if its name\n   * begins with `notify` or `on`.\n   *\n   * @param p - The property being called on the proxy.\n   * @return Whether `p` represents a notification.\n   */\n  protected isNotification(p: PropertyKey): boolean {\n    return p.toString().startsWith('notify') || p.toString().startsWith('on');\n  }\n\n  protected serializeError(e: any): any {\n    if (ApplicationError.is(e)) {\n      return e;\n    }\n    return e;\n  }\n\n  protected deserializeError(capturedError: Error, e: any): any {\n    if (e) {\n      const capturedStack = capturedError.stack || '';\n      if (e.data && e.data.kind === 'application') {\n        const {stack, data, message} = e.data;\n        return ApplicationError.fromJson(e.code, {\n          message: message || capturedError.message,\n          data,\n          stack: `${capturedStack}\\nCaused by: ${stack}`\n        });\n      }\n      e.stack = capturedStack;\n    }\n    return e;\n  }\n\n}\n"]}