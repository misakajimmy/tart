{"version":3,"sources":["common/reference.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAElF,OAAO,EAAC,UAAU,EAAE,oBAAoB,EAAC,MAAM,cAAc,CAAC;AAC9D,OAAO,EAAC,KAAK,EAAC,MAAM,SAAS,CAAC;AAC9B,OAAO,EAAC,YAAY,EAAC,MAAM,SAAS,CAAC;AACrC,OAAO,EAAC,OAAO,EAAC,MAAM,WAAW,CAAC;AAElC,MAAM,WAAW,SAAS,CAAC,CAAC,CAAE,SAAQ,UAAU;IAC9C,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAA;CACnB;AAED,8BAAsB,2BAA2B,CAAC,CAAC,EAAE,CAAC,SAAS,UAAU,CAAE,YAAW,UAAU;IAE9F,SAAS,CAAC,QAAQ,CAAC,KAAK,iBAAwB;IAChD,SAAS,CAAC,QAAQ,CAAC,OAAO,iBAAwB;IAClD,SAAS,CAAC,QAAQ,CAAC,UAAU,oCAA2C;IAExE,SAAS,CAAC,QAAQ,CAAC,kBAAkB,aAAoB;IACzD,QAAQ,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC,CAAiC;IAE/D,SAAS,CAAC,QAAQ,CAAC,oBAAoB,aAAoB;IAC3D,QAAQ,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC,CAAC,CAAmC;IAEnE,SAAS,CAAC,QAAQ,CAAC,SAAS,uBAA8B;;IAQ1D,OAAO,IAAI,IAAI;IAIf,KAAK,IAAI,IAAI;IAUb,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,OAAO;IAKrB,IAAI,IAAI,CAAC,EAAE;IAIX,MAAM,IAAI,CAAC,EAAE;IAIb,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS;IAK3B,QAAQ,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAErD,SAAS,CAAC,SAAS,CAAC,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;IAWzD,SAAS,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,GAAG,MAAM;IAIhC,SAAS,CAAC,gBAAgB,CAAC,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,GAAG,oBAAoB;CAgBxE;AAGD,qBAAa,mBAAmB,CAAC,CAAC,EAAE,CAAC,SAAS,UAAU,CAAE,SAAQ,2BAA2B,CAAC,CAAC,EAAE,CAAC,CAAC;IAIrF,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,YAAY,CAAC,CAAC,CAAC;IAFnE,SAAS,CAAC,QAAQ,CAAC,aAAa,+BAAsC;gBAEvC,OAAO,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,YAAY,CAAC,CAAC,CAAC;IAI7D,OAAO,CAAC,IAAI,EAAE,CAAC,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;cAU7B,gBAAgB,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;CAqBnE;AAED,qBAAa,uBAAuB,CAAC,CAAC,EAAE,CAAC,SAAS,UAAU,CAAE,SAAQ,2BAA2B,CAAC,CAAC,EAAE,CAAC,CAAC;IAEzF,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC;gBAAtB,OAAO,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,CAAC;IAIrD,OAAO,CAAC,IAAI,EAAE,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;IAM9B,SAAS,CAAC,gBAAgB,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,GAAG,CAAC;CAYpD","file":"../../src/common/reference.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {Disposable, DisposableCollection} from './disposable';\nimport {Event} from './event';\nimport {MaybePromise} from './types';\nimport {Emitter} from './emitter';\n\nexport interface Reference<T> extends Disposable {\n  readonly object: T\n}\n\nexport abstract class AbstractReferenceCollection<K, V extends Disposable> implements Disposable {\n\n  protected readonly _keys = new Map<string, K>();\n  protected readonly _values = new Map<string, V>();\n  protected readonly references = new Map<string, DisposableCollection>();\n\n  protected readonly onDidCreateEmitter = new Emitter<V>();\n  readonly onDidCreate: Event<V> = this.onDidCreateEmitter.event;\n\n  protected readonly onWillDisposeEmitter = new Emitter<V>();\n  readonly onWillDispose: Event<V> = this.onWillDisposeEmitter.event;\n\n  protected readonly toDispose = new DisposableCollection();\n\n  constructor() {\n    this.toDispose.push(this.onDidCreateEmitter);\n    this.toDispose.push(this.onWillDisposeEmitter);\n    this.toDispose.push(Disposable.create(() => this.clear()));\n  }\n\n  dispose(): void {\n    this.toDispose.dispose();\n  }\n\n  clear(): void {\n    for (const value of this._values.values()) {\n      try {\n        value.dispose();\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n  has(args: K): boolean {\n    const key = this.toKey(args);\n    return this.references.has(key);\n  }\n\n  keys(): K[] {\n    return [...this._keys.values()];\n  }\n\n  values(): V[] {\n    return [...this._values.values()];\n  }\n\n  get(args: K): V | undefined {\n    const key = this.toKey(args);\n    return this._values.get(key);\n  }\n\n  abstract acquire(args: K): MaybePromise<Reference<V>>;\n\n  protected doAcquire(key: string, object: V): Reference<V> {\n    const references = this.references.get(key) || this.createReferences(key, object);\n    const reference: Reference<V> = {\n      object,\n      dispose: () => {\n      }\n    };\n    references.push(reference);\n    return reference;\n  }\n\n  protected toKey(args: K): string {\n    return JSON.stringify(args);\n  }\n\n  protected createReferences(key: string, value: V): DisposableCollection {\n    const references = new DisposableCollection();\n    references.onDispose(() => value.dispose());\n    const disposeObject = value.dispose.bind(value);\n    value.dispose = () => {\n      this.onWillDisposeEmitter.fire(value);\n      disposeObject();\n      this._values.delete(key);\n      this._keys.delete(key);\n      this.references.delete(key);\n      references!.dispose();\n    };\n    this.references.set(key, references);\n    return references;\n  }\n\n}\n\n\nexport class ReferenceCollection<K, V extends Disposable> extends AbstractReferenceCollection<K, V> {\n\n  protected readonly pendingValues = new Map<string, MaybePromise<V>>();\n\n  constructor(protected readonly factory: (key: K) => MaybePromise<V>) {\n    super();\n  }\n\n  async acquire(args: K): Promise<Reference<V>> {\n    const key = this.toKey(args);\n    const existing = this._values.get(key);\n    if (existing) {\n      return this.doAcquire(key, existing);\n    }\n    const object = await this.getOrCreateValue(key, args);\n    return this.doAcquire(key, object);\n  }\n\n  protected async getOrCreateValue(key: string, args: K): Promise<V> {\n    const existing = this.pendingValues.get(key);\n    if (existing) {\n      return existing;\n    }\n    const pending = this.factory(args);\n    this._keys.set(key, args);\n    this.pendingValues.set(key, pending);\n    try {\n      const value = await pending;\n      this._values.set(key, value);\n      this.onDidCreateEmitter.fire(value);\n      return value;\n    } catch (e) {\n      this._keys.delete(key);\n      throw e;\n    } finally {\n      this.pendingValues.delete(key);\n    }\n  }\n\n}\n\nexport class SyncReferenceCollection<K, V extends Disposable> extends AbstractReferenceCollection<K, V> {\n\n  constructor(protected readonly factory: (key: K) => V) {\n    super();\n  }\n\n  acquire(args: K): Reference<V> {\n    const key = this.toKey(args);\n    const object = this.getOrCreateValue(key, args);\n    return this.doAcquire(key, object);\n  }\n\n  protected getOrCreateValue(key: string, args: K): V {\n    const existing = this._values.get(key);\n    if (existing) {\n      return existing;\n    }\n    const value = this.factory(args);\n    this._keys.set(key, args);\n    this._values.set(key, value);\n    this.onDidCreateEmitter.fire(value);\n    return value;\n  }\n\n}\n"]}