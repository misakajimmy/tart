{"version":3,"sources":["common/cancellation.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAQlF,OAAO,EAAC,KAAK,EAAC,MAAM,SAAS,CAAC;AAE9B,MAAM,WAAW,iBAAiB;IAChC,QAAQ,CAAC,uBAAuB,EAAE,OAAO,CAAC;IAK1C,QAAQ,CAAC,uBAAuB,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;CAC/C;AAYD,yBAAiB,iBAAiB,CAAC;IAE1B,MAAM,SAAS,EAAE,iBAGtB,CAAC;IAEI,MAAM,IAAI,EAAE,iBAGjB,CAAC;CAEJ;AAED,qBAAa,iBAAkB,SAAQ,KAAK;;CAK3C;AAgCD,qBAAa,uBAAuB;IAElC,OAAO,CAAC,MAAM,CAAoB;IAElC,IAAI,KAAK,IAAI,iBAAiB,CAO7B;IAED,MAAM,IAAI,IAAI;IAWd,OAAO,IAAI,IAAI;CAGhB;AAID,wBAAgB,SAAS,IAAI,KAAK,CAEjC;AAED,wBAAgB,WAAW,CAAC,GAAG,EAAE,KAAK,GAAG,SAAS,GAAG,OAAO,CAE3D;AAED,wBAAgB,cAAc,CAAC,KAAK,CAAC,EAAE,iBAAiB,GAAG,IAAI,CAI9D","file":"../../src/common/cancellation.d.ts","sourcesContent":["/********************************************************************************\r\n * Copyright (C) 2017 TypeFox and others.\r\n *\r\n * This program and the accompanying materials are made available under the\r\n * terms of the Eclipse Public License v. 2.0 which is available at\r\n * http://www.eclipse.org/legal/epl-2.0.\r\n *\r\n * This Source Code may also be made available under the following Secondary\r\n * Licenses when the conditions for such availability set forth in the Eclipse\r\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\r\n * with the GNU Classpath Exception which is available at\r\n * https://www.gnu.org/software/classpath/license.html.\r\n *\r\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\r\n ********************************************************************************/\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation and others. All rights reserved.\r\n *  Licensed under the MIT License. See https://github.com/Microsoft/vscode/blob/master/LICENSE.txt for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nimport {Emitter} from './emitter';\r\n\r\nimport {Event} from './event';\r\n\r\nexport interface CancellationToken {\r\n  readonly isCancellationRequested: boolean;\r\n  /*\r\n   * An event emitted when cancellation is requested\r\n   * @event\r\n   */\r\n  readonly onCancellationRequested: Event<void>;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst shortcutEvent: Event<void> = Object.freeze(Object.assign(function (callback: any, context?: any): any {\r\n  const handle = setTimeout(callback.bind(context), 0);\r\n  return {\r\n    dispose(): void {\r\n      clearTimeout(handle);\r\n    }\r\n  };\r\n}, {maxListeners: 0}));\r\n\r\nexport namespace CancellationToken {\r\n\r\n  export const Cancelled: CancellationToken = Object.freeze({\r\n    isCancellationRequested: true,\r\n    onCancellationRequested: shortcutEvent\r\n  });\r\n\r\n  export const None: CancellationToken = Object.freeze({\r\n    isCancellationRequested: false,\r\n    onCancellationRequested: Event.None,\r\n  });\r\n\r\n}\r\n\r\nexport class CancellationError extends Error {\r\n  constructor() {\r\n    super('Canceled');\r\n    this.name = this.message;\r\n  }\r\n}\r\n\r\nclass MutableToken implements CancellationToken {\r\n\r\n  private _isCancelled: boolean = false;\r\n  private _emitter: Emitter<void> | undefined;\r\n\r\n  get isCancellationRequested(): boolean {\r\n    return this._isCancelled;\r\n  }\r\n\r\n  get onCancellationRequested(): Event<void> {\r\n    if (this._isCancelled) {\r\n      return shortcutEvent;\r\n    }\r\n    if (!this._emitter) {\r\n      this._emitter = new Emitter<void>();\r\n    }\r\n    return this._emitter.event;\r\n  }\r\n\r\n  public cancel(): void {\r\n    if (!this._isCancelled) {\r\n      this._isCancelled = true;\r\n      if (this._emitter) {\r\n        this._emitter.fire(undefined);\r\n        this._emitter = undefined;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class CancellationTokenSource {\r\n\r\n  private _token: CancellationToken;\r\n\r\n  get token(): CancellationToken {\r\n    if (!this._token) {\r\n      // be lazy and create the token only when\r\n      // actually needed\r\n      this._token = new MutableToken();\r\n    }\r\n    return this._token;\r\n  }\r\n\r\n  cancel(): void {\r\n    if (!this._token) {\r\n      // save an object by returning the default\r\n      // cancelled token when cancellation happens\r\n      // before someone asks for the token\r\n      this._token = CancellationToken.Cancelled;\r\n    } else if (this._token !== CancellationToken.Cancelled) {\r\n      (<MutableToken>this._token).cancel();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    this.cancel();\r\n  }\r\n}\r\n\r\nconst cancelledMessage = 'Cancelled';\r\n\r\nexport function cancelled(): Error {\r\n  return new Error(cancelledMessage);\r\n}\r\n\r\nexport function isCancelled(err: Error | undefined): boolean {\r\n  return !!err && err.message === cancelledMessage;\r\n}\r\n\r\nexport function checkCancelled(token?: CancellationToken): void {\r\n  if (!!token && token.isCancellationRequested) {\r\n    throw cancelled();\r\n  }\r\n}\r\n"]}