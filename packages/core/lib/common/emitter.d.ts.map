{"version":3,"sources":["common/emitter.ts"],"names":[],"mappings":"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","file":"../../src/common/emitter.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {Event} from './event';\nimport {Disposable} from './disposable';\nimport {MaybePromise} from './types';\nimport {CancellationToken} from './cancellation';\n\ntype Callback = (...args: any[]) => any;\n\nclass CallbackList implements Iterable<Callback> {\n\n  private _callbacks: Function[] | undefined;\n  private _contexts: any[] | undefined;\n\n  get length(): number {\n    return this._callbacks && this._callbacks.length || 0;\n  }\n\n  public add(callback: Function, context: any = undefined, bucket?: Disposable[]): void {\n    if (!this._callbacks) {\n      this._callbacks = [];\n      this._contexts = [];\n    }\n    this._callbacks.push(callback);\n    this._contexts!.push(context);\n\n    if (Array.isArray(bucket)) {\n      bucket.push({dispose: () => this.remove(callback, context)});\n    }\n  }\n\n  public remove(callback: Function, context: any = undefined): void {\n    if (!this._callbacks) {\n      return;\n    }\n\n    let foundCallbackWithDifferentContext = false;\n    for (let i = 0; i < this._callbacks.length; i++) {\n      if (this._callbacks[i] === callback) {\n        if (this._contexts![i] === context) {\n          // callback & context match => remove it\n          this._callbacks.splice(i, 1);\n          this._contexts!.splice(i, 1);\n          return;\n        } else {\n          foundCallbackWithDifferentContext = true;\n        }\n      }\n    }\n\n    if (foundCallbackWithDifferentContext) {\n      throw new Error('When adding a listener with a context, you should remove it with the same context');\n    }\n  }\n\n  // tslint:disable-next-line:typedef\n  public [Symbol.iterator]() {\n    if (!this._callbacks) {\n      return [][Symbol.iterator]();\n    }\n    const callbacks = this._callbacks.slice(0);\n    const contexts = this._contexts!.slice(0);\n\n    return callbacks.map((callback, i) =>\n        (...args: any[]) => callback.apply(contexts[i], args)\n    )[Symbol.iterator]();\n  }\n\n  public invoke(...args: any[]): any[] {\n    const ret: any[] = [];\n    for (const callback of this) {\n      try {\n        ret.push(callback(...args));\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return ret;\n  }\n\n  public isEmpty(): boolean {\n    return !this._callbacks || this._callbacks.length === 0;\n  }\n\n  public dispose(): void {\n    this._callbacks = undefined;\n    this._contexts = undefined;\n  }\n}\n\nexport interface EmitterOptions {\n  onFirstListenerAdd?: Function;\n  onLastListenerRemove?: Function;\n}\n\nexport class Emitter<T = any> {\n\n  private static LEAK_WARNING_THRESHHOLD = 175;\n  protected _callbacks: CallbackList | undefined;\n  private _disposed = false;\n  private _leakingStacks: Map<string, number> | undefined;\n  private _leakWarnCountdown = 0;\n\n  constructor(\n      private _options?: EmitterOptions\n  ) {\n  }\n\n  private _event: Event<T>;\n\n  /**\n   * For the public to allow to subscribe\n   * to events from this Emitter\n   */\n  get event(): Event<T> {\n    if (!this._event) {\n      this._event = Object.assign((listener: (e: T) => any, thisArgs?: any, disposables?: Disposable[]) => {\n            if (!this._callbacks) {\n              this._callbacks = new CallbackList();\n            }\n            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n              this._options.onFirstListenerAdd(this);\n            }\n            this._callbacks.add(listener, thisArgs);\n            const removeMaxListenersCheck = this.checkMaxListeners(this._event.maxListeners);\n\n            const result: Disposable = {\n              dispose: () => {\n                if (removeMaxListenersCheck) {\n                  removeMaxListenersCheck();\n                }\n                result.dispose = Emitter._noop;\n                if (!this._disposed) {\n                  this._callbacks!.remove(listener, thisArgs);\n                  result.dispose = Emitter._noop;\n                  if (this._options && this._options.onLastListenerRemove && this._callbacks!.isEmpty()) {\n                    this._options.onLastListenerRemove(this);\n                  }\n                }\n              }\n            };\n            if (Array.isArray(disposables)) {\n              disposables.push(result);\n            }\n\n            return result;\n          }, {\n            maxListeners: Emitter.LEAK_WARNING_THRESHHOLD\n          }\n      );\n    }\n    return this._event;\n  }\n\n  private static _noop = function (): void {\n  };\n\n  /**\n   * To be kept private to fire an event to\n   * subscribers\n   */\n  fire(event: T): any {\n    if (this._callbacks) {\n      this._callbacks.invoke(event);\n    }\n  }\n\n  /**\n   * Process each listener one by one.\n   * Return `false` to stop iterating over the listeners, `true` to continue.\n   */\n  async sequence(processor: (listener: (e: T) => any) => MaybePromise<boolean>): Promise<void> {\n    if (this._callbacks) {\n      for (const listener of this._callbacks) {\n        if (!await processor(listener)) {\n          break;\n        }\n      }\n    }\n  }\n\n  dispose(): void {\n    if (this._leakingStacks) {\n      this._leakingStacks.clear();\n      this._leakingStacks = undefined;\n    }\n    if (this._callbacks) {\n      this._callbacks.dispose();\n      this._callbacks = undefined;\n    }\n    this._disposed = true;\n  }\n\n  protected checkMaxListeners(maxListeners: number): (() => void) | undefined {\n    if (maxListeners === 0 || !this._callbacks) {\n      return undefined;\n    }\n    const listenerCount = this._callbacks.length;\n    if (listenerCount <= maxListeners) {\n      return undefined;\n    }\n\n    const popStack = this.pushLeakingStack();\n\n    this._leakWarnCountdown -= 1;\n    if (this._leakWarnCountdown <= 0) {\n      // only warn on first exceed and then every time the limit\n      // is exceeded by 50% again\n      this._leakWarnCountdown = maxListeners * 0.5;\n\n      let topStack: string;\n      let topCount = 0;\n      this._leakingStacks!.forEach((stackCount, stack) => {\n        if (!topStack || topCount < stackCount) {\n          topStack = stack;\n          topCount = stackCount;\n        }\n      });\n\n      // eslint-disable-next-line max-len\n      console.warn(`Possible Emitter memory leak detected. ${listenerCount} listeners added. Use event.maxListeners to increase the limit (${maxListeners}). MOST frequent listener (${topCount}):`);\n      console.warn(topStack!);\n    }\n\n    return popStack;\n  }\n\n  protected pushLeakingStack(): () => void {\n    if (!this._leakingStacks) {\n      this._leakingStacks = new Map();\n    }\n    const stack = new Error().stack!.split('\\n').slice(3).join('\\n');\n    const count = (this._leakingStacks.get(stack) || 0);\n    this._leakingStacks.set(stack, count + 1);\n    return () => this.popLeakingStack(stack);\n  }\n\n  protected popLeakingStack(stack: string): void {\n    if (!this._leakingStacks) {\n      return;\n    }\n    const count = (this._leakingStacks.get(stack) || 0);\n    this._leakingStacks.set(stack, count - 1);\n  }\n}\n\nexport interface WaitUntilEvent {\n  /**\n   * Allows to pause the event loop until the provided thenable resolved.\n   *\n   * *Note:* It can only be called during event dispatch and not in an asynchronous manner\n   *\n   * @param thenable A thenable that delays execution.\n   */\n  waitUntil(thenable: Promise<any>): void;\n}\n\nexport namespace WaitUntilEvent {\n  /**\n   * Fire all listeners in the same tick.\n   *\n   * Use `AsyncEmitter.fire` to fire listeners async one after another.\n   */\n  export async function fire<T extends WaitUntilEvent>(\n      emitter: Emitter<T>,\n      event: Omit<T, 'waitUntil'>,\n      timeout: number | undefined = undefined\n  ): Promise<void> {\n    const waitables: Promise<void>[] = [];\n    const asyncEvent = Object.assign(event, {\n      waitUntil: (thenable: Promise<any>) => {\n        if (Object.isFrozen(waitables)) {\n          throw new Error('waitUntil cannot be called asynchronously.');\n        }\n        waitables.push(thenable);\n      }\n    }) as T;\n    try {\n      emitter.fire(asyncEvent);\n      // Asynchronous calls to `waitUntil` should fail.\n      Object.freeze(waitables);\n    } finally {\n      delete asyncEvent['waitUntil'];\n    }\n    if (!waitables.length) {\n      return;\n    }\n    if (timeout !== undefined) {\n      await Promise.race([Promise.all(waitables), new Promise(resolve => setTimeout(resolve, timeout))]);\n    } else {\n      await Promise.all(waitables);\n    }\n  }\n}\n\nexport class AsyncEmitter<T extends WaitUntilEvent> extends Emitter<T> {\n\n  protected deliveryQueue: Promise<void> | undefined;\n\n  /**\n   * Fire listeners async one after another.\n   */\n  fire(event: Omit<T, 'waitUntil'>, token: CancellationToken = CancellationToken.None,\n       promiseJoin?: (p: Promise<any>, listener: Function) => Promise<any>): Promise<void> {\n    const callbacks = this._callbacks;\n    if (!callbacks) {\n      return Promise.resolve();\n    }\n    const listeners = [...callbacks];\n    if (this.deliveryQueue) {\n      return this.deliveryQueue = this.deliveryQueue.then(() => this.deliver(listeners, event, token, promiseJoin));\n    }\n    return this.deliveryQueue = this.deliver(listeners, event, token, promiseJoin);\n  }\n\n  protected async deliver(listeners: Callback[], event: Omit<T, 'waitUntil'>, token: CancellationToken,\n                          promiseJoin?: (p: Promise<any>, listener: Function) => Promise<any>): Promise<void> {\n    for (const listener of listeners) {\n      if (token.isCancellationRequested) {\n        return;\n      }\n      const waitables: Promise<void>[] = [];\n      const asyncEvent = Object.assign(event, {\n        waitUntil: (thenable: Promise<any>) => {\n          if (Object.isFrozen(waitables)) {\n            throw new Error('waitUntil cannot be called asynchronously.');\n          }\n          if (promiseJoin) {\n            thenable = promiseJoin(thenable, listener);\n          }\n          waitables.push(thenable);\n        }\n      }) as T;\n      try {\n        listener(event);\n        // Asynchronous calls to `waitUntil` should fail.\n        Object.freeze(waitables);\n      } catch (e) {\n        console.error(e);\n      } finally {\n        delete asyncEvent['waitUntil'];\n      }\n      if (!waitables.length) {\n        return;\n      }\n      try {\n        await Promise.all(waitables);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }\n\n}\n"]}