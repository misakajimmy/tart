{"version":3,"sources":["common/logger.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;;;;;;;AAElF,OAAO,EAAC,UAAU,EAAC,MAAM,WAAW,CAAC;AACrC,OAAO,EAAC,QAAQ,EAAE,cAAc,EAAC,MAAM,mBAAmB,CAAC;AAE3D,uDAAuD;AAEvD,OAAO,EACL,QAAQ,EAAE,cAAc,EACzB,CAAC;AAiCF,MAAM,CAAC,MAAM,aAAa,GAAG,MAAM,CAAC,eAAe,CAAC,CAAC;AA4KrD,IAAa,MAAM,GAAnB,MAAa,MAAM;IAEjB,gCAAgC;IACtB,SAAS,CAAkB;IAErC,0EAA0E;IAChE,OAAO,CAAgB;IAEjC;;OAEG;IACH;IACI,mEAAmE;IACnE,0EAA0E;IAC1E,oEAAoE;IACpE,6CAA6C;;QAE/C,EAAE;QACF,iCAAiC;QACjC,sCAAsC;QACtC,yCAAyC;QACzC,WAAW;QACX,sEAAsE;QACtE,wCAAwC;QACxC,IAAI;QACJ,EAAE;QACF,6DAA6D;QAC7D,0EAA0E;QAC1E,EAAE;QACF,2DAA2D;QAC3D,6CAA6C;QAC7C,gCAAgC;QAChC,2CAA2C;QAC3C,mEAAmE;QACnE,YAAY;QACZ,UAAU;QACV,MAAM;IACR,CAAC;CAyHF,CAAA;AA9JY,MAAM;IADlB,UAAU,EAAE;GACA,MAAM,CA8JlB;SA9JY,MAAM","file":"../../src/common/logger.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {injectable} from 'inversify';\nimport {LogLevel, rootLoggerName} from './logger-protocol';\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport {\n  LogLevel, rootLoggerName\n};\n\n/* This is to be initialized from container composition root. It can be used outside of the inversify context.  */\n// export let logger: ILogger;\n\n/**\n * Counterpart of the `#setRootLogger(ILogger)`. Restores the `console.xxx` bindings to the original one.\n * Invoking has no side-effect if `setRootLogger` was not called before. Multiple function invocation has\n * no side-effect either.\n */\n// export function unsetRootLogger(): void {\n//     if (logger !== undefined) {\n//         ConsoleLogger.reset();\n//         (<any>logger) = undefined;\n//     }\n// }\n\n// export function setRootLogger(aLogger: ILogger): void {\n//     logger = aLogger;\n//     const log = (logLevel: number, message?: any, ...optionalParams: any[]) =>\n//         logger.log(logLevel, message, ...optionalParams);\n//\n//     console.error = log.bind(undefined, LogLevel.ERROR);\n//     console.warn = log.bind(undefined, LogLevel.WARN);\n//     console.info = log.bind(undefined, LogLevel.INFO);\n//     console.debug = log.bind(undefined, LogLevel.DEBUG);\n//     console.trace = log.bind(undefined, LogLevel.TRACE);\n//     console.log = log.bind(undefined, LogLevel.INFO);\n// }\n\nexport type Log = (message: any, ...params: any[]) => void;\nexport type Loggable = (log: Log) => void;\n\nexport const LoggerFactory = Symbol('LoggerFactory');\nexport type LoggerFactory = (name: string) => ILogger;\n\n// export const LoggerName = Symbol('LoggerName');\n\n// export const ILogger = Symbol('ILogger');\n\nexport interface ILogger {\n  // /**\n  //  * Set the log level.\n  //  *\n  //  * @param loglevel - The loglevel to set. see Logger.LogLevel for\n  //  * possible options.\n  //  */\n  // setLogLevel(logLevel: number): Promise<void>\n  // /**\n  //  * Get the log level.\n  //  *\n  //  * @returns a Promise to the log level.\n  //  */\n  // getLogLevel(): Promise<number>;\n  //\n  // /**\n  //  * Test whether the given log level is enabled.\n  //  */\n  // isEnabled(logLevel: number): Promise<boolean>;\n  // /**\n  //  * Resolve if the given log is enabled.\n  //  */\n  // ifEnabled(logLevel: number): Promise<void>;\n  // /**\n  //  * Log a loggable with the given level if it is enabled.\n  //  */\n  // log(logLevel: number, loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the given level if it is enabled.\n  //  *\n  //  * @param logLevel - The loglevel to use.\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // log(logLevel: number, message: any, ...params: any[]): void;\n  //\n  // /**\n  //  * Test whether the trace level is enabled.\n  //  */\n  // isTrace(): Promise<boolean>;\n  // /**\n  //  * Resolve if the trace level is enabled.\n  //  */\n  // ifTrace(): Promise<void>;\n  // /**\n  //  * Log a loggable with the trace level if it is enabled.\n  //  */\n  // trace(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the trace level if it is enabled.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // trace(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Test whether the debug level is enabled.\n  //  */\n  // isDebug(): Promise<boolean>;\n  // /**\n  //  * Resolve if the debug level is enabled.\n  //  */\n  // ifDebug(): Promise<void>;\n  // /**\n  //  * Log a loggable with the debug level if it is enabled.\n  //  */\n  // debug(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the debug level if it is enabled.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // debug(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Test whether the info level is enabled.\n  //  */\n  // isInfo(): Promise<boolean>;\n  // /**\n  //  * Resolve if the info level is enabled.\n  //  */\n  // ifInfo(): Promise<void>;\n  // /**\n  //  * Log a loggable with the info level if it is enabled.\n  //  */\n  // info(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the info level if it is enabled.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // info(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Test whether the warn level is enabled.\n  //  */\n  // isWarn(): Promise<boolean>;\n  // /**\n  //  * Resolve if the warn level is enabled.\n  //  */\n  // ifWarn(): Promise<void>;\n  // /**\n  //  * Log a loggable with the warn level if it is enabled.\n  //  */\n  // warn(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the warn level if it is enabled.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // warn(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Test whether the error level is enabled.\n  //  */\n  // isError(): Promise<boolean>;\n  // /**\n  //  * Resolve if the error level is enabled.\n  //  */\n  // ifError(): Promise<void>;\n  // /**\n  //  * Log a loggable with the error level if it is enabled.\n  //  */\n  // error(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the error level.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // error(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Test whether the fatal level is enabled.\n  //  */\n  // isFatal(): Promise<boolean>;\n  // /**\n  //  * Resolve if the fatal level is enabled.\n  //  */\n  // ifFatal(): Promise<void>;\n  // /**\n  //  * Log a loggable with the fatal level if it is enabled.\n  //  */\n  // fatal(loggable: Loggable): Promise<void>;\n  // /**\n  //  * Log a message with the fatal level if it is enabled.\n  //  *\n  //  * @param message - The message format string.\n  //  * @param params - The format string variables.\n  //  */\n  // fatal(message: any, ...params: any[]): Promise<void>;\n  //\n  // /**\n  //  * Create a child logger from this logger.\n  //  *\n  //  * @param name - The name of the child logger.\n  //  */\n  // child(name: string): ILogger;\n}\n\n@injectable()\nexport class Logger implements ILogger {\n\n  /* Log level for the logger.  */\n  protected _logLevel: Promise<number>;\n\n  /* A promise resolved when the logger has been created by the backend.  */\n  protected created: Promise<void>;\n\n  /**\n   * Build a new Logger.\n   */\n  constructor(\n      // @inject(ILoggerServer) protected readonly server: ILoggerServer,\n      // @inject(LoggerWatcher) protected readonly loggerWatcher: LoggerWatcher,\n      // @inject(LoggerFactory) protected readonly factory: LoggerFactory,\n      // @inject(LoggerName) protected name: string\n  ) {\n    //\n    // if (name !== rootLoggerName) {\n    //     /* Creating a child logger.  */\n    //     this.created = server.child(name);\n    // } else {\n    //     /* Creating the root logger (it already exists at startup).  */\n    //     this.created = Promise.resolve();\n    // }\n    //\n    // /* Fetch the log level so it's cached in the frontend.  */\n    // this._logLevel = this.created.then(_ => this.server.getLogLevel(name));\n    //\n    // /* Update the log level if it changes in the backend. */\n    // loggerWatcher.onLogLevelChanged(event => {\n    //     this.created.then(() => {\n    //         if (event.loggerName === name) {\n    //             this._logLevel = Promise.resolve(event.newLogLevel);\n    //         }\n    //     });\n    // });\n  }\n\n  //\n  // setLogLevel(logLevel: number): Promise<void> {\n  //     return new Promise<void>(resolve => {\n  //         this.created.then(() => {\n  //             this._logLevel.then(oldLevel => {\n  //                 this.server.setLogLevel(this.name, logLevel).then(() => {\n  //                     this._logLevel = Promise.resolve(logLevel);\n  //                     resolve();\n  //                 });\n  //             });\n  //         });\n  //     });\n  // }\n  // getLogLevel(): Promise<number> {\n  //     return this._logLevel;\n  // }\n  //\n  // isEnabled(logLevel: number): Promise<boolean> {\n  //     return this._logLevel.then(level =>\n  //         logLevel >= level\n  //     );\n  // }\n  // ifEnabled(logLevel: number): Promise<void> {\n  //     return new Promise<void>(resolve =>\n  //         this.isEnabled(logLevel).then(enabled => {\n  //             if (enabled) {\n  //                 resolve();\n  //             }\n  //         })\n  //     );\n  // }\n  // log(logLevel: number, arg2: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.getLog(logLevel).then(log => {\n  //         if (typeof arg2 === 'function') {\n  //             const loggable = arg2;\n  //             loggable(log);\n  //         } else if (arg2) {\n  //             log(arg2, ...params);\n  //         }\n  //     });\n  // }\n  // protected getLog(logLevel: number): Promise<Log> {\n  //     return this.ifEnabled(logLevel).then(() =>\n  //         this.created.then(() =>\n  //             (message: any, ...params: any[]) =>\n  //                 this.server.log(this.name, logLevel, this.format(message), params.map(p => this.format(p)))\n  //         )\n  //     );\n  // }\n  // protected format(value: any): any {\n  //     if (value instanceof Error) {\n  //         return value.stack || value.toString();\n  //     }\n  //     return value;\n  // }\n  //\n  // isTrace(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.TRACE);\n  // }\n  // ifTrace(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.TRACE);\n  // }\n  // trace(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.TRACE, arg, ...params);\n  // }\n  //\n  // isDebug(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.DEBUG);\n  // }\n  // ifDebug(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.DEBUG);\n  // }\n  // debug(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.DEBUG, arg, ...params);\n  // }\n  //\n  // isInfo(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.INFO);\n  // }\n  // ifInfo(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.INFO);\n  // }\n  // info(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.INFO, arg, ...params);\n  // }\n  //\n  // isWarn(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.WARN);\n  // }\n  // ifWarn(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.WARN);\n  // }\n  // warn(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.WARN, arg, ...params);\n  // }\n  //\n  // isError(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.ERROR);\n  // }\n  // ifError(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.ERROR);\n  // }\n  // error(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.ERROR, arg, ...params);\n  // }\n  //\n  // isFatal(): Promise<boolean> {\n  //     return this.isEnabled(LogLevel.FATAL);\n  // }\n  // ifFatal(): Promise<void> {\n  //     return this.ifEnabled(LogLevel.FATAL);\n  // }\n  // fatal(arg: any | Loggable, ...params: any[]): Promise<void> {\n  //     return this.log(LogLevel.FATAL, arg, ...params);\n  // }\n  //\n  // child(name: string): ILogger {\n  //     return this.factory(name);\n  // }\n}\n"]}