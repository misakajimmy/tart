{"version":3,"sources":["common/resource.ts"],"names":[],"mappings":"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","file":"../../src/common/resource.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {TextDocumentContentChangeEvent} from 'vscode-languageserver-protocol';\nimport URI from '../common/uri';\nimport {ContributionProvider} from './contribution-provider';\nimport {Event} from './event';\nimport {Emitter} from './emitter';\nimport {Disposable} from './disposable';\nimport {MaybePromise} from './types';\nimport {CancellationToken} from './cancellation';\nimport {ApplicationError} from './application-error';\nimport {Readable, ReadableStream} from './stream';\nimport {Reference, SyncReferenceCollection} from './reference';\n\nexport interface ResourceVersion {\n}\n\nexport interface ResourceReadOptions {\n  encoding?: string\n}\n\nexport interface ResourceSaveOptions {\n  encoding?: string\n  overwriteEncoding?: boolean\n  version?: ResourceVersion\n}\n\nexport interface Resource extends Disposable {\n  readonly uri: URI;\n  /**\n   * Latest read version of this resource.\n   *\n   * Optional if a resource does not support versioning, check with `in` operator`.\n   * Undefined if a resource did not read content yet.\n   */\n  readonly version?: ResourceVersion | undefined;\n  /**\n   * Latest read encoding of this resource.\n   *\n   * Optional if a resource does not support encoding, check with `in` operator`.\n   * Undefined if a resource did not read content yet.\n   */\n  readonly encoding?: string | undefined;\n  readonly onDidChangeContents?: Event<void>;\n\n  /**\n   * Reads latest content of this resource.\n   *\n   * If a resource supports versioning it updates version to latest.\n   * If a resource supports encoding it updates encoding to latest.\n   *\n   * @throws `ResourceError.NotFound` if a resource not found\n   */\n  readContents(options?: ResourceReadOptions): Promise<string>;\n\n  /**\n   * Stream latest content of this resource.\n   *\n   * If a resource supports versioning it updates version to latest.\n   * If a resource supports encoding it updates encoding to latest.\n   *\n   * @throws `ResourceError.NotFound` if a resource not found\n   */\n  readStream?(options?: ResourceReadOptions): Promise<ReadableStream<string>>;\n\n  /**\n   * Rewrites the complete content for this resource.\n   * If a resource does not exist it will be created.\n   *\n   * If a resource supports versioning clients can pass some version\n   * to check against it, if it is not provided latest version is used.\n   *\n   * It updates version and encoding to latest.\n   *\n   * @throws `ResourceError.OutOfSync` if latest resource version is out of sync with the given\n   */\n  saveContents?(content: string, options?: ResourceSaveOptions): Promise<void>;\n\n  /**\n   * Rewrites the complete content for this resource.\n   * If a resource does not exist it will be created.\n   *\n   * If a resource supports versioning clients can pass some version\n   * to check against it, if it is not provided latest version is used.\n   *\n   * It updates version and encoding to latest.\n   *\n   * @throws `ResourceError.OutOfSync` if latest resource version is out of sync with the given\n   */\n  saveStream?(content: Readable<string>, options?: ResourceSaveOptions): Promise<void>;\n\n  /**\n   * Applies incremental content changes to this resource.\n   *\n   * If a resource supports versioning clients can pass some version\n   * to check against it, if it is not provided latest version is used.\n   * It updates version to latest.\n   *\n   * @throws `ResourceError.NotFound` if a resource not found or was not read yet\n   * @throws `ResourceError.OutOfSync` if latest resource version is out of sync with the given\n   */\n  saveContentChanges?(changes: TextDocumentContentChangeEvent[], options?: ResourceSaveOptions): Promise<void>;\n\n  guessEncoding?(): Promise<string | undefined>\n}\n\nexport namespace Resource {\n  export interface SaveContext {\n    contentLength: number\n    content: string | Readable<string>\n    changes?: TextDocumentContentChangeEvent[]\n    options?: ResourceSaveOptions\n  }\n\n  export async function save(resource: Resource, context: SaveContext, token?: CancellationToken): Promise<void> {\n    if (!resource.saveContents) {\n      return;\n    }\n    if (await trySaveContentChanges(resource, context)) {\n      return;\n    }\n    if (token && token.isCancellationRequested) {\n      return;\n    }\n    if (typeof context.content !== 'string' && resource.saveStream) {\n      await resource.saveStream(context.content, context.options);\n    } else {\n      const content = typeof context.content === 'string' ? context.content : Readable.toString(context.content);\n      await resource.saveContents(content, context.options);\n    }\n  }\n\n  export async function trySaveContentChanges(resource: Resource, context: SaveContext): Promise<boolean> {\n    if (!context.changes || !resource.saveContentChanges || shouldSaveContent(resource, context)) {\n      return false;\n    }\n    try {\n      await resource.saveContentChanges(context.changes, context.options);\n      return true;\n    } catch (e) {\n      if (!ResourceError.NotFound.is(e) && !ResourceError.OutOfSync.is(e)) {\n        console.error(`Failed to apply incremental changes to '${resource.uri.toString()}':`, e);\n      }\n      return false;\n    }\n  }\n\n  export function shouldSaveContent(resource: Resource, {contentLength, changes}: SaveContext): boolean {\n    if (!changes || (resource.saveStream && contentLength > 32 * 1024 * 1024)) {\n      return true;\n    }\n    let contentChangesLength = 0;\n    for (const change of changes) {\n      contentChangesLength += JSON.stringify(change).length;\n      if (contentChangesLength > contentLength) {\n        return true;\n      }\n    }\n    return contentChangesLength > contentLength;\n  }\n}\n\nexport namespace ResourceError {\n  export const NotFound = ApplicationError.declare(-40000, (raw: ApplicationError.Literal<{ uri: URI }>) => raw);\n  export const OutOfSync = ApplicationError.declare(-40001, (raw: ApplicationError.Literal<{ uri: URI }>) => raw);\n}\n\nexport const ResourceResolver = Symbol('ResourceResolver');\n\nexport interface ResourceResolver {\n  /**\n   * Reject if a resource cannot be provided.\n   */\n  resolve(uri: URI): MaybePromise<Resource>;\n}\n\nexport const ResourceProvider = Symbol('ResourceProvider');\nexport type ResourceProvider = (uri: URI) => Promise<Resource>;\n\n@injectable()\nexport class DefaultResourceProvider {\n\n  constructor(\n      @inject(ContributionProvider) @named(ResourceResolver)\n      protected readonly resolversProvider: ContributionProvider<ResourceResolver>\n  ) {\n  }\n\n  /**\n   * Reject if a resource cannot be provided.\n   */\n  async get(uri: URI): Promise<Resource> {\n    const resolvers = this.resolversProvider.getContributions();\n    for (const resolver of resolvers) {\n      try {\n        return await resolver.resolve(uri);\n      } catch (err) {\n        // no-op\n      }\n    }\n    return Promise.reject(new Error(`A resource provider for '${uri.toString()}' is not registered.`));\n  }\n\n}\n\nexport class MutableResource implements Resource {\n  protected readonly onDidChangeContentsEmitter = new Emitter<void>();\n  readonly onDidChangeContents = this.onDidChangeContentsEmitter.event;\n  private contents: string = '';\n\n  constructor(readonly uri: URI) {\n  }\n\n  dispose(): void {\n  }\n\n  async readContents(): Promise<string> {\n    return this.contents;\n  }\n\n  async saveContents(contents: string): Promise<void> {\n    this.contents = contents;\n    this.fireDidChangeContents();\n  }\n\n  protected fireDidChangeContents(): void {\n    this.onDidChangeContentsEmitter.fire(undefined);\n  }\n}\n\nexport class ReferenceMutableResource implements Resource {\n  constructor(protected reference: Reference<MutableResource>) {\n  }\n\n  get uri(): URI {\n    return this.reference.object.uri;\n  }\n\n  get onDidChangeContents(): Event<void> {\n    return this.reference.object.onDidChangeContents;\n  }\n\n  dispose(): void {\n    this.reference.dispose();\n  }\n\n  readContents(): Promise<string> {\n    return this.reference.object.readContents();\n  }\n\n  saveContents(contents: string): Promise<void> {\n    return this.reference.object.saveContents(contents);\n  }\n}\n\n@injectable()\nexport class InMemoryResources implements ResourceResolver {\n\n  protected readonly resources = new SyncReferenceCollection<string, MutableResource>(uri => new MutableResource(new URI(uri)));\n\n  add(uri: URI, contents: string): Resource {\n    const resourceUri = uri.toString();\n    if (this.resources.has(resourceUri)) {\n      throw new Error(`Cannot add already existing in-memory resource '${resourceUri}'`);\n    }\n    const resource = this.acquire(resourceUri);\n    resource.saveContents(contents);\n    return resource;\n  }\n\n  update(uri: URI, contents: string): Resource {\n    const resourceUri = uri.toString();\n    const resource = this.resources.get(resourceUri);\n    if (!resource) {\n      throw new Error(`Cannot update non-existed in-memory resource '${resourceUri}'`);\n    }\n    resource.saveContents(contents);\n    return resource;\n  }\n\n  resolve(uri: URI): Resource {\n    const uriString = uri.toString();\n    if (!this.resources.has(uriString)) {\n      throw new Error(`In memory '${uriString}' resource does not exist.`);\n    }\n    return this.acquire(uriString);\n  }\n\n  protected acquire(uri: string): ReferenceMutableResource {\n    const reference = this.resources.acquire(uri);\n    return new ReferenceMutableResource(reference);\n  }\n}\n\nexport const MEMORY_TEXT = 'mem-txt';\n\n/**\n * Resource implementation for 'mem-txt' URI scheme where content is saved in URI query.\n */\nexport class InMemoryTextResource implements Resource {\n  constructor(readonly uri: URI) {\n  }\n\n  async readContents(options?: { encoding?: string | undefined; } | undefined): Promise<string> {\n    return this.uri.query;\n  }\n\n  dispose(): void {\n  }\n}\n\n/**\n * ResourceResolver implementation for 'mem-txt' URI scheme.\n */\n@injectable()\nexport class InMemoryTextResourceResolver implements ResourceResolver {\n  resolve(uri: URI): MaybePromise<Resource> {\n    if (uri.scheme !== MEMORY_TEXT) {\n      throw new Error(`Expected a URI with ${MEMORY_TEXT} scheme. Was: ${uri}.`);\n    }\n    return new InMemoryTextResource(uri);\n  }\n}\n"]}