{"version":3,"sources":["common/strings.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAUlF;;GAEG;AACH,wBAAgB,QAAQ,CAAC,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,OAAO,CASlE;AAED,wBAAgB,kBAAkB,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAExD;AAED,wBAAgB,kBAAkB,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAExD;AAMD,wBAAgB,gBAAgB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,GAAG,OAAO,CAS9D;AAmCD;;GAEG;AACH,wBAAgB,kBAAkB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,GAAG,MAAM,CAY/D;AAED;;GAEG;AACH,wBAAgB,sBAAsB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAE5D;AAED,wBAAgB,oBAAoB,CAAC,GAAG,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,GAAG,OAAO,CAO5E;AAED,wBAAiB,KAAK,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAW5E;AAED,wBAAgB,oBAAoB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAE1D;AAED,wBAAgB,sBAAsB,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAE5D;AAED,wBAAgB,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,GAAG,MAAM,CAQpD;AAED,wBAAgB,gBAAgB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,GAAE,MAAU,EAAE,IAAI,GAAE,MAAiB,EAAE,MAAM,GAAE,MAAU,EAAE,IAAI,GAAE,MAAiB,GAAG,MAAM,CAkBvJ;AAED,wBAAgB,iBAAiB,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,GAAG,MAAM,CAE9D;AAED,wBAAgB,0BAA0B,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,GAAE,MAAU,EAAE,IAAI,GAAE,MAAiB,EAAE,MAAM,GAAE,MAAU,EAAE,IAAI,GAAE,MAAiB,GAAG,MAAM,CAuCjK","file":"../../src/common/strings.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/strings.ts\n\nimport {CharCode} from './char-code';\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n  const diff = haystack.length - needle.length;\n  if (diff > 0) {\n    return haystack.indexOf(needle, diff) === diff;\n  } else if (diff === 0) {\n    return haystack === needle;\n  } else {\n    return false;\n  }\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n  return code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n  return code >= CharCode.A && code <= CharCode.Z;\n}\n\nfunction isAsciiLetter(code: number): boolean {\n  return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n  const len1 = a ? a.length : 0;\n  const len2 = b ? b.length : 0;\n\n  if (len1 !== len2) {\n    return false;\n  }\n\n  return doEqualsIgnoreCase(a, b);\n}\n\nfunction doEqualsIgnoreCase(a: string, b: string, stopAt = a.length): boolean {\n  if (typeof a !== 'string' || typeof b !== 'string') {\n    return false;\n  }\n\n  for (let i = 0; i < stopAt; i++) {\n    const codeA = a.charCodeAt(i);\n    const codeB = b.charCodeAt(i);\n\n    if (codeA === codeB) {\n      continue;\n    }\n\n    // a-z A-Z\n    if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {\n      const diff = Math.abs(codeA - codeB);\n      if (diff !== 0 && diff !== 32) {\n        return false;\n      }\n    }\n\n        // Any other charcode\n    // tslint:disable-next-line:one-line\n    else {\n      if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n  let i: number;\n  const len = Math.min(a.length, b.length);\n\n  for (i = 0; i < len; i++) {\n    if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n      return i;\n    }\n  }\n\n  return len;\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)\\#]/g, '\\\\$&');\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n  const candidateLength = candidate.length;\n  if (candidate.length > str.length) {\n    return false;\n  }\n\n  return doEqualsIgnoreCase(str, candidate, candidateLength);\n}\n\nexport function* split(s: string, splitter: string): IterableIterator<string> {\n  let start = 0;\n  while (start < s.length) {\n    let end = s.indexOf(splitter, start);\n    if (end === -1) {\n      end = s.length;\n    }\n\n    yield s.substring(start, end);\n    start = end + splitter.length;\n  }\n}\n\nexport function escapeInvisibleChars(value: string): string {\n  return value.replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r');\n}\n\nexport function unescapeInvisibleChars(value: string): string {\n  return value.replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r');\n}\n\nexport function compare(a: string, b: string): number {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n    const codeA = a.charCodeAt(aStart);\n    const codeB = b.charCodeAt(bStart);\n    if (codeA < codeB) {\n      return -1;\n    } else if (codeA > codeB) {\n      return 1;\n    }\n  }\n  const aLen = aEnd - aStart;\n  const bLen = bEnd - bStart;\n  if (aLen < bLen) {\n    return -1;\n  } else if (aLen > bLen) {\n    return 1;\n  }\n  return 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n  return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n  for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n    const codeA = a.charCodeAt(aStart);\n    const codeB = b.charCodeAt(bStart);\n\n    if (codeA === codeB) {\n      // equal\n      continue;\n    }\n\n    const diff = codeA - codeB;\n    if (diff === 32 && isUpperAsciiLetter(codeB)) { // codeB =[65-90] && codeA =[97-122]\n      continue;\n\n    } else if (diff === -32 && isUpperAsciiLetter(codeA)) {  // codeB =[97-122] && codeA =[65-90]\n      continue;\n    }\n\n    if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {\n      //\n      return diff;\n\n    } else {\n      return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n    }\n  }\n\n  const aLen = aEnd - aStart;\n  const bLen = bEnd - bStart;\n\n  if (aLen < bLen) {\n    return -1;\n  } else if (aLen > bLen) {\n    return 1;\n  }\n\n  return 0;\n}\n"]}