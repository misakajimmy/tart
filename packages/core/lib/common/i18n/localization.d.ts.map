{"version":3,"sources":["common/i18n/localization.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAElF,eAAO,MAAM,gBAAgB,mBAAmB,CAAC;AAEjD,eAAO,MAAM,yBAAyB,eAAsC,CAAC;AAE7E,MAAM,WAAW,yBAAyB;IACxC,kBAAkB,IAAI,OAAO,CAAC,MAAM,CAAC,CAAA;IAErC,kBAAkB,CAAC,UAAU,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAA;IAErD,qBAAqB,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC,CAAA;IAE1C,gBAAgB,CAAC,UAAU,EAAE,MAAM,GAAG,OAAO,CAAC,YAAY,CAAC,CAAA;CAC5D;AAED,MAAM,WAAW,YAAY;IAC3B,UAAU,EAAE,MAAM,CAAC;IACnB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,YAAY,CAAC,EAAE,OAAO,CAAC;IACvB,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAC/B,YAAY,EAAE;QAAE,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAAA;KAAE,CAAC;CACzC;AAED,oBAAY,UAAU,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,SAAS,CAAC;AAE/D,yBAAiB,YAAY,CAAC;IAE5B,SAAgB,MAAM,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,MAAM,CAgBlE;IAED,SAAgB,QAAQ,CAAC,YAAY,EAAE,YAAY,GAAG,SAAS,EAAE,GAAG,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,EAAE,GAAG,IAAI,EAAE,UAAU,EAAE,GAAG,MAAM,CASjI;IAED;;;;;;OAMG;IACH,SAAgB,SAAS,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,CAE/C;IAED,SAAgB,YAAY,CAAC,GAAG,EAAE,MAAM,GAAG,MAAM,CAOhD;CACF","file":"../../../src/common/i18n/localization.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2021 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nexport const localizationPath = '/services/i18n';\n\nexport const AsyncLocalizationProvider = Symbol('AsyncLocalizationProvider');\n\nexport interface AsyncLocalizationProvider {\n  getCurrentLanguage(): Promise<string>\n\n  setCurrentLanguage(languageId: string): Promise<void>\n\n  getAvailableLanguages(): Promise<string[]>\n\n  loadLocalization(languageId: string): Promise<Localization>\n}\n\nexport interface Localization {\n  languageId: string;\n  languageName?: string;\n  languagePack?: boolean;\n  localizedLanguageName?: string;\n  translations: { [key: string]: string };\n}\n\nexport type FormatType = string | number | boolean | undefined;\n\nexport namespace Localization {\n\n  export function format(message: string, args: FormatType[]): string {\n    let result = message;\n    if (args.length > 0) {\n      result = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n        const index = rest[0];\n        const arg = args[index];\n        let replacement = match;\n        if (typeof arg === 'string') {\n          replacement = arg;\n        } else if (typeof arg === 'number' || typeof arg === 'boolean' || !arg) {\n          replacement = String(arg);\n        }\n        return replacement;\n      });\n    }\n    return result;\n  }\n\n  export function localize(localization: Localization | undefined, key: string, defaultValue: string, ...args: FormatType[]): string {\n    let value = defaultValue;\n    if (localization) {\n      const translation = localization.translations[key];\n      if (translation) {\n        value = normalize(translation);\n      }\n    }\n    return format(value, args);\n  }\n\n  /**\n   * This function normalizes values from VSCode's localizations, which often contain additional mnemonics (`&&`).\n   * The normalization removes the mnemonics from the input string.\n   *\n   * @param value Localization value coming from VSCode\n   * @returns A normalized localized value\n   */\n  export function normalize(value: string): string {\n    return value.replace(/&&/g, '');\n  }\n\n  export function transformKey(key: string): string {\n    let nlsKey = key;\n    const keySlashIndex = key.lastIndexOf('/');\n    if (keySlashIndex >= 0) {\n      nlsKey = key.substring(keySlashIndex + 1);\n    }\n    return nlsKey;\n  }\n}\n"]}