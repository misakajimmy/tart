{"version":3,"sources":["common/buffer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAWlF,OAAO,KAAK,OAAO,MAAM,UAAU,CAAC;AASpC,qBAAa,YAAY;IAEvB,QAAQ,CAAC,MAAM,EAAE,UAAU,CAAC;IAC5B,QAAQ,CAAC,UAAU,EAAE,MAAM,CAAC;IAE5B,OAAO;IAKP,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,MAAM,GAAG,YAAY;IAQ9C,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,GAAG,YAAY;IAS7C,MAAM,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,GAAG,YAAY;IAa/C,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,YAAY,EAAE,EAAE,WAAW,CAAC,EAAE,MAAM,GAAG,YAAY;IAmB1E,QAAQ,IAAI,MAAM;IAalB,KAAK,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,EAAE,MAAM,GAAG,YAAY;IAOjD,GAAG,CAAC,KAAK,EAAE,YAAY,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,IAAI;IAC/C,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,MAAM,CAAC,EAAE,MAAM,GAAG,IAAI;IAS7C,YAAY,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM;IASpC,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,IAAI;IAUlD,YAAY,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM;IASpC,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,IAAI;IAUlD,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM;IAIjC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,IAAI;CAIhD;AAED,MAAM,WAAW,oBAAqB,SAAQ,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAC;CAC3E;AAED,yBAAiB,oBAAoB,CAAC;IACpC,SAAgB,QAAQ,CAAC,QAAQ,EAAE,oBAAoB,GAAG,YAAY,CAErE;IAED,SAAgB,UAAU,CAAC,MAAM,EAAE,YAAY,GAAG,oBAAoB,CAErE;IAED,SAAgB,YAAY,CAAC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,oBAAoB,CAYrF;CACF;AAED,MAAM,WAAW,0BAA2B,SAAQ,OAAO,CAAC,cAAc,CAAC,YAAY,CAAC;CACvF;AAED,yBAAiB,0BAA0B,CAAC;IAC1C,SAAgB,QAAQ,CAAC,MAAM,EAAE,0BAA0B,GAAG,OAAO,CAAC,YAAY,CAAC,CAElF;IAED,SAAgB,UAAU,CAAC,MAAM,EAAE,YAAY,GAAG,0BAA0B,CAE3E;CACF;AAED,MAAM,WAAW,kCAAmC,SAAQ,OAAO,CAAC,sBAAsB,CAAC,YAAY,CAAC;CACvG;AAED,yBAAiB,kCAAkC,CAAC;IAClD,SAAsB,QAAQ,CAAC,cAAc,EAAE,OAAO,CAAC,sBAAsB,CAAC,YAAY,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAalH;CACF;AAED,MAAM,WAAW,2BAA4B,SAAQ,OAAO,CAAC,eAAe,CAAC,YAAY,CAAC;CACzF;AAED,yBAAiB,2BAA2B,CAAC;IAC3C,SAAgB,MAAM,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,sBAAsB,GAAG,2BAA2B,CAE5F;CACF","file":"../../src/common/buffer.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/buffer.ts\n\n/* eslint-disable no-null/no-null */\n\nimport {Buffer as SaferBuffer} from 'safer-buffer';\nimport * as iconv from 'iconv-lite';\nimport * as streams from './stream';\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst hasTextEncoder = (typeof TextEncoder !== 'undefined');\nconst hasTextDecoder = (typeof TextDecoder !== 'undefined');\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class BinaryBuffer {\n\n  readonly buffer: Uint8Array;\n  readonly byteLength: number;\n\n  private constructor(buffer: Uint8Array) {\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n\n  static alloc(byteLength: number): BinaryBuffer {\n    if (hasBuffer) {\n      return new BinaryBuffer(Buffer.allocUnsafe(byteLength));\n    } else {\n      return new BinaryBuffer(new Uint8Array(byteLength));\n    }\n  }\n\n  static wrap(actual: Uint8Array): BinaryBuffer {\n    if (hasBuffer && !(Buffer.isBuffer(actual))) {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n      // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n    }\n    return new BinaryBuffer(actual);\n  }\n\n  static fromString(source: string): BinaryBuffer {\n    if (hasBuffer) {\n      return new BinaryBuffer(Buffer.from(source));\n    } else if (hasTextEncoder) {\n      if (!textEncoder) {\n        textEncoder = new TextEncoder();\n      }\n      return new BinaryBuffer(textEncoder.encode(source));\n    } else {\n      return new BinaryBuffer(iconv.encode(source, 'utf8'));\n    }\n  }\n\n  static concat(buffers: BinaryBuffer[], totalLength?: number): BinaryBuffer {\n    if (typeof totalLength === 'undefined') {\n      totalLength = 0;\n      for (let i = 0, len = buffers.length; i < len; i++) {\n        totalLength += buffers[i].byteLength;\n      }\n    }\n\n    const ret = BinaryBuffer.alloc(totalLength);\n    let offset = 0;\n    for (let i = 0, len = buffers.length; i < len; i++) {\n      const element = buffers[i];\n      ret.set(element, offset);\n      offset += element.byteLength;\n    }\n\n    return ret;\n  }\n\n  toString(): string {\n    if (hasBuffer) {\n      return this.buffer.toString();\n    } else if (hasTextDecoder) {\n      if (!textDecoder) {\n        textDecoder = new TextDecoder();\n      }\n      return textDecoder.decode(this.buffer);\n    } else {\n      return iconv.decode(SaferBuffer.from(this.buffer), 'utf8');\n    }\n  }\n\n  slice(start?: number, end?: number): BinaryBuffer {\n    // IMPORTANT: use subarray instead of slice because TypedArray#slice\n    // creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n    // ensures the same, performant, behaviour.\n    return new BinaryBuffer(this.buffer.subarray(start, end));\n  }\n\n  set(array: BinaryBuffer, offset?: number): void;\n  set(array: Uint8Array, offset?: number): void;\n  set(array: BinaryBuffer | Uint8Array, offset?: number): void {\n    if (array instanceof BinaryBuffer) {\n      this.buffer.set(array.buffer, offset);\n    } else {\n      this.buffer.set(array, offset);\n    }\n  }\n\n  readUInt32BE(offset: number): number {\n    return (\n        this.buffer[offset] * 2 ** 24\n        + this.buffer[offset + 1] * 2 ** 16\n        + this.buffer[offset + 2] * 2 ** 8\n        + this.buffer[offset + 3]\n    );\n  }\n\n  writeUInt32BE(value: number, offset: number): void {\n    this.buffer[offset + 3] = value;\n    value = value >>> 8;\n    this.buffer[offset + 2] = value;\n    value = value >>> 8;\n    this.buffer[offset + 1] = value;\n    value = value >>> 8;\n    this.buffer[offset] = value;\n  }\n\n  readUInt32LE(offset: number): number {\n    return (\n        ((this.buffer[offset + 0] << 0) >>> 0) |\n        ((this.buffer[offset + 1] << 8) >>> 0) |\n        ((this.buffer[offset + 2] << 16) >>> 0) |\n        ((this.buffer[offset + 3] << 24) >>> 0)\n    );\n  }\n\n  writeUInt32LE(value: number, offset: number): void {\n    this.buffer[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    this.buffer[offset + 1] = (value & 0b11111111);\n    value = value >>> 8;\n    this.buffer[offset + 2] = (value & 0b11111111);\n    value = value >>> 8;\n    this.buffer[offset + 3] = (value & 0b11111111);\n  }\n\n  readUInt8(offset: number): number {\n    return this.buffer[offset];\n  }\n\n  writeUInt8(value: number, offset: number): void {\n    this.buffer[offset] = value;\n  }\n\n}\n\nexport interface BinaryBufferReadable extends streams.Readable<BinaryBuffer> {\n}\n\nexport namespace BinaryBufferReadable {\n  export function toBuffer(readable: BinaryBufferReadable): BinaryBuffer {\n    return streams.consumeReadable<BinaryBuffer>(readable, chunks => BinaryBuffer.concat(chunks));\n  }\n\n  export function fromBuffer(buffer: BinaryBuffer): BinaryBufferReadable {\n    return streams.toReadable<BinaryBuffer>(buffer);\n  }\n\n  export function fromReadable(readable: streams.Readable<string>): BinaryBufferReadable {\n    return {\n      read(): BinaryBuffer | null {\n        const value = readable.read();\n\n        if (typeof value === 'string') {\n          return BinaryBuffer.fromString(value);\n        }\n\n        return null;\n      }\n    };\n  }\n}\n\nexport interface BinaryBufferReadableStream extends streams.ReadableStream<BinaryBuffer> {\n}\n\nexport namespace BinaryBufferReadableStream {\n  export function toBuffer(stream: BinaryBufferReadableStream): Promise<BinaryBuffer> {\n    return streams.consumeStream<BinaryBuffer>(stream, chunks => BinaryBuffer.concat(chunks));\n  }\n\n  export function fromBuffer(buffer: BinaryBuffer): BinaryBufferReadableStream {\n    return streams.toStream<BinaryBuffer>(buffer, chunks => BinaryBuffer.concat(chunks));\n  }\n}\n\nexport interface BinaryBufferReadableBufferedStream extends streams.ReadableBufferedStream<BinaryBuffer> {\n}\n\nexport namespace BinaryBufferReadableBufferedStream {\n  export async function toBuffer(bufferedStream: streams.ReadableBufferedStream<BinaryBuffer>): Promise<BinaryBuffer> {\n    if (bufferedStream.ended) {\n      return BinaryBuffer.concat(bufferedStream.buffer);\n    }\n\n    return BinaryBuffer.concat([\n\n      // Include already read chunks...\n      ...bufferedStream.buffer,\n\n      // ...and all additional chunks\n      await BinaryBufferReadableStream.toBuffer(bufferedStream.stream)\n    ]);\n  }\n}\n\nexport interface BinaryBufferWriteableStream extends streams.WriteableStream<BinaryBuffer> {\n}\n\nexport namespace BinaryBufferWriteableStream {\n  export function create(options?: streams.WriteableStreamOptions): BinaryBufferWriteableStream {\n    return streams.newWriteableStream<BinaryBuffer>(chunks => BinaryBuffer.concat(chunks), options);\n  }\n}\n"]}