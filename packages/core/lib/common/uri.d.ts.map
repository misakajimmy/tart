{"version":3,"sources":["common/uri.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAElF,OAAO,EAAC,GAAG,IAAI,GAAG,EAAC,MAAM,YAAY,CAAC;AACtC,OAAO,EAAC,IAAI,EAAC,MAAM,QAAQ,CAAC;AAE5B,MAAM,CAAC,OAAO,OAAO,GAAG;IAEtB,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAM;gBAElB,GAAG,GAAE,MAAM,GAAG,GAAQ;IAQlC,OAAO,CAAC,KAAK,CAAmB;IAEhC,IAAI,IAAI,IAAI,IAAI,CAKf;IAED;;;;OAIG;IACH,IAAI,WAAW,IAAI,MAAM,CASxB;IAED;;OAEG;IACH,IAAI,YAAY,IAAI,GAAG,EAAE,CASxB;IAED,IAAI,MAAM,IAAI,GAAG,CAKhB;IAED,IAAI,MAAM,IAAI,MAAM,CAEnB;IAED,IAAI,SAAS,IAAI,MAAM,CAEtB;IAED,IAAI,KAAK,IAAI,MAAM,CAElB;IAED,IAAI,QAAQ,IAAI,MAAM,CAErB;IAED,MAAM,CAAC,kBAAkB,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE;IAU7C,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,GAAG,SAAS;IAOpC,OAAO,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,GAAG,GAAG;IAIjC;;OAEG;IACH,UAAU,CAAC,MAAM,EAAE,MAAM,GAAG,GAAG;IAQ/B;;OAEG;IACH,aAAa,CAAC,SAAS,EAAE,MAAM,GAAG,GAAG;IASrC;;OAEG;IACH,gBAAgB,IAAI,GAAG;IAIvB;;OAEG;IACH,QAAQ,CAAC,IAAI,EAAE,MAAM,GAAG,IAAI,GAAG,GAAG;IASlC;;OAEG;IACH,WAAW,IAAI,GAAG;IAIlB;;OAEG;IACH,SAAS,CAAC,KAAK,EAAE,MAAM,GAAG,GAAG;IAS7B;;OAEG;IACH,YAAY,IAAI,GAAG;IAInB;;OAEG;IACH,YAAY,CAAC,QAAQ,EAAE,MAAM,GAAG,GAAG;IASnC;;OAEG;IACH,eAAe,IAAI,GAAG;IAItB;;OAEG;IACH,aAAa,IAAI,GAAG;IAIpB,QAAQ,CAAC,YAAY,CAAC,EAAE,OAAO,GAAG,MAAM;IAIxC,OAAO,CAAC,GAAG,EAAE,GAAG,EAAE,aAAa,GAAE,OAAc,GAAG,OAAO;IAUzD,eAAe,CAAC,GAAG,EAAE,GAAG,EAAE,aAAa,GAAE,OAAc,GAAG,OAAO;IAajE,OAAO,CAAC,aAAa;CAGtB","file":"../../src/common/uri.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {URI as Uri} from 'vscode-uri';\nimport {Path} from './path';\n\nexport default class URI {\n\n  private readonly codeUri: Uri;\n\n  constructor(uri: string | Uri = '') {\n    if (uri instanceof Uri) {\n      this.codeUri = uri;\n    } else {\n      this.codeUri = Uri.parse(uri);\n    }\n  }\n\n  private _path: Path | undefined;\n\n  get path(): Path {\n    if (this._path === undefined) {\n      this._path = new Path(this.codeUri.path);\n    }\n    return this._path;\n  }\n\n  /**\n   * TODO move implementation to `DefaultUriLabelProviderContribution.getName`\n   *\n   * @deprecated use `LabelProvider.getName` instead\n   */\n  get displayName(): string {\n    const base = this.path.base;\n    if (base) {\n      return base;\n    }\n    if (this.path.isRoot) {\n      return this.path.toString();\n    }\n    return '';\n  }\n\n  /**\n   * Return all uri from the current to the top most.\n   */\n  get allLocations(): URI[] {\n    const locations = [];\n    let location: URI = this;\n    while (!location.path.isRoot && location.path.hasDir) {\n      locations.push(location);\n      location = location.parent;\n    }\n    locations.push(location);\n    return locations;\n  }\n\n  get parent(): URI {\n    if (this.path.isRoot) {\n      return this;\n    }\n    return this.withPath(this.path.dir);\n  }\n\n  get scheme(): string {\n    return this.codeUri.scheme;\n  }\n\n  get authority(): string {\n    return this.codeUri.authority;\n  }\n\n  get query(): string {\n    return this.codeUri.query;\n  }\n\n  get fragment(): string {\n    return this.codeUri.fragment;\n  }\n\n  static getDistinctParents(uris: URI[]): URI[] {\n    const result: URI[] = [];\n    uris.forEach((uri, i) => {\n      if (!uris.some((otherUri, index) => index !== i && otherUri.isEqualOrParent(uri))) {\n        result.push(uri);\n      }\n    });\n    return result;\n  }\n\n  relative(uri: URI): Path | undefined {\n    if (this.authority !== uri.authority || this.scheme !== uri.scheme) {\n      return undefined;\n    }\n    return this.path.relative(uri.path);\n  }\n\n  resolve(path: string | Path): URI {\n    return this.withPath(this.path.join(path.toString()));\n  }\n\n  /**\n   * return a new URI replacing the current with the given scheme\n   */\n  withScheme(scheme: string): URI {\n    const newCodeUri = Uri.from({\n      ...this.codeUri.toJSON(),\n      scheme\n    });\n    return new URI(newCodeUri);\n  }\n\n  /**\n   * return a new URI replacing the current with the given authority\n   */\n  withAuthority(authority: string): URI {\n    const newCodeUri = Uri.from({\n      ...this.codeUri.toJSON(),\n      scheme: this.codeUri.scheme,\n      authority\n    });\n    return new URI(newCodeUri);\n  }\n\n  /**\n   * return this URI without a authority\n   */\n  withoutAuthority(): URI {\n    return this.withAuthority('');\n  }\n\n  /**\n   * return a new URI replacing the current with the given path\n   */\n  withPath(path: string | Path): URI {\n    const newCodeUri = Uri.from({\n      ...this.codeUri.toJSON(),\n      scheme: this.codeUri.scheme,\n      path: path.toString()\n    });\n    return new URI(newCodeUri);\n  }\n\n  /**\n   * return this URI without a path\n   */\n  withoutPath(): URI {\n    return this.withPath('');\n  }\n\n  /**\n   * return a new URI replacing the current with the given query\n   */\n  withQuery(query: string): URI {\n    const newCodeUri = Uri.from({\n      ...this.codeUri.toJSON(),\n      scheme: this.codeUri.scheme,\n      query\n    });\n    return new URI(newCodeUri);\n  }\n\n  /**\n   * return this URI without a query\n   */\n  withoutQuery(): URI {\n    return this.withQuery('');\n  }\n\n  /**\n   * return a new URI replacing the current with the given fragment\n   */\n  withFragment(fragment: string): URI {\n    const newCodeUri = Uri.from({\n      ...this.codeUri.toJSON(),\n      scheme: this.codeUri.scheme,\n      fragment\n    });\n    return new URI(newCodeUri);\n  }\n\n  /**\n   * return this URI without a fragment\n   */\n  withoutFragment(): URI {\n    return this.withFragment('');\n  }\n\n  /**\n   * return a new URI replacing the current with its normalized path, resolving '..' and '.' segments\n   */\n  normalizePath(): URI {\n    return this.withPath(this.path.normalize());\n  }\n\n  toString(skipEncoding?: boolean): string {\n    return this.codeUri.toString(skipEncoding);\n  }\n\n  isEqual(uri: URI, caseSensitive: boolean = true): boolean {\n    if (!this.hasSameOrigin(uri)) {\n      return false;\n    }\n\n    return caseSensitive\n        ? this.toString() === uri.toString()\n        : this.toString().toLowerCase() === uri.toString().toLowerCase();\n  }\n\n  isEqualOrParent(uri: URI, caseSensitive: boolean = true): boolean {\n    if (!this.hasSameOrigin(uri)) {\n      return false;\n    }\n    let left = this.path;\n    let right = uri.path;\n    if (!caseSensitive) {\n      left = new Path(left.toString().toLowerCase());\n      right = new Path(right.toString().toLowerCase());\n    }\n    return left.isEqualOrParent(right);\n  }\n\n  private hasSameOrigin(uri: URI): boolean {\n    return (this.authority === uri.authority) && (this.scheme === uri.scheme);\n  }\n}\n"]}