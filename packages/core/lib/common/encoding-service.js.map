{"version":3,"sources":["common/encoding-service.ts"],"names":[],"mappings":"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","file":"../../src/common/encoding-service.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/common/encoding.ts\n\n/* eslint-disable no-null/no-null */\n\nimport * as iconv from 'iconv-lite';\nimport {Buffer} from 'safer-buffer';\nimport {injectable} from 'inversify';\nimport {BinaryBuffer, BinaryBufferReadable, BinaryBufferReadableStream} from './buffer';\nimport {UTF16be, UTF16be_BOM, UTF16le, UTF16le_BOM, UTF8, UTF8_BOM, UTF8_with_bom} from './encodings';\nimport {newWriteableStream, Readable, ReadableStream} from './stream';\n\nconst ZERO_BYTE_DETECTION_BUFFER_MAX_LEN = 512;   // number of bytes to look at to decide about a file being binary or not\nconst NO_ENCODING_GUESS_MIN_BYTES = 512;          // when not auto guessing the encoding, small number of bytes are enough\nconst AUTO_ENCODING_GUESS_MIN_BYTES = 512 * 8;    // with auto guessing we want a lot more content to be read for guessing\nconst AUTO_ENCODING_GUESS_MAX_BYTES = 512 * 128;  // set an upper limit for the number of bytes we pass on to jschardet\n\n// we explicitly ignore a specific set of encodings from auto guessing\n// - ASCII: we never want this encoding (most UTF-8 files would happily detect as\n//          ASCII files and then you could not type non-ASCII characters anymore)\n// - UTF-16: we have our own detection logic for UTF-16\n// - UTF-32: we do not support this encoding in VSCode\nconst IGNORE_ENCODINGS = ['ascii', 'utf-16', 'utf-32'];\n\nexport interface ResourceEncoding {\n  encoding: string\n  hasBOM: boolean\n}\n\nexport interface DetectedEncoding {\n  encoding?: string\n  seemsBinary?: boolean\n}\n\nexport interface DecodeStreamOptions {\n  guessEncoding?: boolean;\n  minBytesRequiredForDetection?: number;\n\n  overwriteEncoding(detectedEncoding: string | undefined): Promise<string>;\n}\n\nexport interface DecodeStreamResult {\n  stream: ReadableStream<string>;\n  detected: DetectedEncoding;\n}\n\n@injectable()\nexport class EncodingService {\n\n  encode(value: string, options?: ResourceEncoding): BinaryBuffer {\n    let encoding = options?.encoding;\n    const addBOM = options?.hasBOM;\n    encoding = this.toIconvEncoding(encoding);\n    if (encoding === UTF8 && !addBOM) {\n      return BinaryBuffer.fromString(value);\n    }\n    const buffer = iconv.encode(value, encoding, {addBOM});\n    return BinaryBuffer.wrap(buffer);\n  }\n\n  decode(value: BinaryBuffer, encoding?: string): string {\n    const buffer = Buffer.from(value.buffer);\n    encoding = this.toIconvEncoding(encoding);\n    return iconv.decode(buffer, encoding);\n  }\n\n  exists(encoding: string): boolean {\n    encoding = this.toIconvEncoding(encoding);\n    return iconv.encodingExists(encoding);\n  }\n\n  toIconvEncoding(encoding?: string): string {\n    if (encoding === UTF8_with_bom || !encoding) {\n      return UTF8; // iconv does not distinguish UTF 8 with or without BOM, so we need to help it\n    }\n    return encoding;\n  }\n\n  async toResourceEncoding(encoding: string, options: {\n    overwriteEncoding?: boolean,\n    read: (length: number) => Promise<Uint8Array>\n  }): Promise<ResourceEncoding> {\n    // Some encodings come with a BOM automatically\n    if (encoding === UTF16be || encoding === UTF16le || encoding === UTF8_with_bom) {\n      return {encoding, hasBOM: true};\n    }\n\n    // Ensure that we preserve an existing BOM if found for UTF8\n    // unless we are instructed to overwrite the encoding\n    const overwriteEncoding = options?.overwriteEncoding;\n    if (!overwriteEncoding && encoding === UTF8) {\n      try {\n        // stream here to avoid fetching the whole content on write\n        const buffer = await options.read(UTF8_BOM.length);\n        if (this.detectEncodingByBOMFromBuffer(Buffer.from(buffer), buffer.byteLength) === UTF8_with_bom) {\n          return {encoding, hasBOM: true};\n        }\n      } catch (error) {\n        // ignore - file might not exist\n      }\n    }\n\n    return {encoding, hasBOM: false};\n  }\n\n  async detectEncoding(data: BinaryBuffer, autoGuessEncoding?: boolean): Promise<DetectedEncoding> {\n    const buffer = Buffer.from(data.buffer);\n    const bytesRead = data.byteLength;\n    // Always first check for BOM to find out about encoding\n    let encoding = this.detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n    // Detect 0 bytes to see if file is binary or UTF-16 LE/BEÏ\n    // unless we already know that this file has a UTF-16 encoding\n    let seemsBinary = false;\n    if (encoding !== UTF16be && encoding !== UTF16le && buffer) {\n      let couldBeUTF16LE = true; // e.g. 0xAA 0x00\n      let couldBeUTF16BE = true; // e.g. 0x00 0xAA\n      let containsZeroByte = false;\n\n      // This is a simplified guess to detect UTF-16 BE or LE by just checking if\n      // the first 512 bytes have the 0-byte at a specific location. For UTF-16 LE\n      // this would be the odd byte index and for UTF-16 BE the even one.\n      // Note: this can produce false positives (a binary file that uses a 2-byte\n      // encoding of the same format as UTF-16) and false negatives (a UTF-16 file\n      // that is using 4 bytes to encode a character).\n      for (let i = 0; i < bytesRead && i < ZERO_BYTE_DETECTION_BUFFER_MAX_LEN; i++) {\n        const isEndian = (i % 2 === 1); // assume 2-byte sequences typical for UTF-16\n        const isZeroByte = (buffer.readUInt8(i) === 0);\n\n        if (isZeroByte) {\n          containsZeroByte = true;\n        }\n\n        // UTF-16 LE: expect e.g. 0xAA 0x00\n        if (couldBeUTF16LE && (isEndian && !isZeroByte || !isEndian && isZeroByte)) {\n          couldBeUTF16LE = false;\n        }\n\n        // UTF-16 BE: expect e.g. 0x00 0xAA\n        if (couldBeUTF16BE && (isEndian && isZeroByte || !isEndian && !isZeroByte)) {\n          couldBeUTF16BE = false;\n        }\n\n        // Return if this is neither UTF16-LE nor UTF16-BE and thus treat as binary\n        if (isZeroByte && !couldBeUTF16LE && !couldBeUTF16BE) {\n          break;\n        }\n      }\n\n      // Handle case of 0-byte included\n      if (containsZeroByte) {\n        if (couldBeUTF16LE) {\n          encoding = UTF16le;\n        } else if (couldBeUTF16BE) {\n          encoding = UTF16be;\n        } else {\n          seemsBinary = true;\n        }\n      }\n    }\n\n    // Auto guess encoding if configured\n    if (autoGuessEncoding && !seemsBinary && !encoding && buffer) {\n      const guessedEncoding = await this.guessEncodingByBuffer(buffer.slice(0, bytesRead));\n      return {\n        seemsBinary: false,\n        encoding: guessedEncoding\n      };\n    }\n\n    return {seemsBinary, encoding};\n  }\n\n  decodeStream(source: BinaryBufferReadableStream, options: DecodeStreamOptions): Promise<DecodeStreamResult> {\n    const minBytesRequiredForDetection = options.minBytesRequiredForDetection ?? options.guessEncoding ? AUTO_ENCODING_GUESS_MIN_BYTES : NO_ENCODING_GUESS_MIN_BYTES;\n\n    return new Promise<DecodeStreamResult>((resolve, reject) => {\n      const target = newWriteableStream<string>(strings => strings.join(''));\n\n      const bufferedChunks: BinaryBuffer[] = [];\n      let bytesBuffered = 0;\n\n      let decoder: iconv.DecoderStream | undefined = undefined;\n\n      const createDecoder = async () => {\n        try {\n\n          // detect encoding from buffer\n          const detected = await this.detectEncoding(BinaryBuffer.concat(bufferedChunks), options.guessEncoding);\n\n          // ensure to respect overwrite of encoding\n          detected.encoding = await options.overwriteEncoding(detected.encoding);\n\n          // decode and write buffered content\n          decoder = iconv.getDecoder(this.toIconvEncoding(detected.encoding));\n          const decoded = decoder.write(Buffer.from(BinaryBuffer.concat(bufferedChunks).buffer));\n          target.write(decoded);\n\n          bufferedChunks.length = 0;\n          bytesBuffered = 0;\n\n          // signal to the outside our detected encoding and final decoder stream\n          resolve({\n            stream: target,\n            detected\n          });\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      // Stream error: forward to target\n      source.on('error', error => target.error(error));\n\n      // Stream data\n      source.on('data', async chunk => {\n\n        // if the decoder is ready, we just write directly\n        if (decoder) {\n          target.write(decoder.write(Buffer.from(chunk.buffer)));\n        } else {\n          bufferedChunks.push(chunk);\n          bytesBuffered += chunk.byteLength;\n\n          // buffered enough data for encoding detection, create stream\n          if (bytesBuffered >= minBytesRequiredForDetection) {\n\n            // pause stream here until the decoder is ready\n            source.pause();\n\n            await createDecoder();\n\n            // resume stream now that decoder is ready but\n            // outside of this stack to reduce recursion\n            setTimeout(() => source.resume());\n          }\n        }\n      });\n\n      // Stream end\n      source.on('end', async () => {\n\n        // we were still waiting for data to do the encoding\n        // detection. thus, wrap up starting the stream even\n        // without all the data to get things going\n        if (!decoder) {\n          await createDecoder();\n        }\n\n        // end the target with the remainders of the decoder\n        target.end(decoder?.end());\n      });\n    });\n  }\n\n  encodeStream(value: string | Readable<string>, options?: ResourceEncoding): Promise<BinaryBuffer | BinaryBufferReadable>\n\n  encodeStream(value?: string | Readable<string>, options?: ResourceEncoding): Promise<BinaryBuffer | BinaryBufferReadable | undefined>;\n\n  async encodeStream(value: string | Readable<string> | undefined, options?: ResourceEncoding): Promise<BinaryBuffer | BinaryBufferReadable | undefined> {\n    let encoding = options?.encoding;\n    const addBOM = options?.hasBOM;\n    encoding = this.toIconvEncoding(encoding);\n    if (encoding === UTF8 && !addBOM) {\n      return value === undefined ? undefined : typeof value === 'string' ?\n          BinaryBuffer.fromString(value) : BinaryBufferReadable.fromReadable(value);\n    }\n\n    value = value || '';\n    const readable = typeof value === 'string' ? Readable.fromString(value) : value;\n    const encoder = iconv.getEncoder(encoding, {addBOM});\n\n    let bytesWritten = false;\n    let done = false;\n\n    return {\n      read(): BinaryBuffer | null {\n        if (done) {\n          return null;\n        }\n\n        const chunk = readable.read();\n        if (typeof chunk !== 'string') {\n          done = true;\n\n          // If we are instructed to add a BOM but we detect that no\n          // bytes have been written, we must ensure to return the BOM\n          // ourselves so that we comply with the contract.\n          if (!bytesWritten && addBOM) {\n            switch (encoding) {\n              case UTF8:\n              case UTF8_with_bom:\n                return BinaryBuffer.wrap(Uint8Array.from(UTF8_BOM));\n              case UTF16be:\n                return BinaryBuffer.wrap(Uint8Array.from(UTF16be_BOM));\n              case UTF16le:\n                return BinaryBuffer.wrap(Uint8Array.from(UTF16le_BOM));\n            }\n          }\n\n          const leftovers = encoder.end();\n          if (leftovers && leftovers.length > 0) {\n            bytesWritten = true;\n            return BinaryBuffer.wrap(leftovers);\n          }\n\n          return null;\n        }\n\n        bytesWritten = true;\n\n        return BinaryBuffer.wrap(encoder.write(chunk));\n      }\n    };\n  }\n\n  protected detectEncodingByBOMFromBuffer(buffer: Buffer, bytesRead: number): typeof UTF8_with_bom | typeof UTF16le | typeof UTF16be | undefined {\n    if (!buffer || bytesRead < UTF16be_BOM.length) {\n      return undefined;\n    }\n\n    const b0 = buffer.readUInt8(0);\n    const b1 = buffer.readUInt8(1);\n\n    // UTF-16 BE\n    if (b0 === UTF16be_BOM[0] && b1 === UTF16be_BOM[1]) {\n      return UTF16be;\n    }\n\n    // UTF-16 LE\n    if (b0 === UTF16le_BOM[0] && b1 === UTF16le_BOM[1]) {\n      return UTF16le;\n    }\n\n    if (bytesRead < UTF8_BOM.length) {\n      return undefined;\n    }\n\n    const b2 = buffer.readUInt8(2);\n\n    // UTF-8\n    if (b0 === UTF8_BOM[0] && b1 === UTF8_BOM[1] && b2 === UTF8_BOM[2]) {\n      return UTF8_with_bom;\n    }\n\n    return undefined;\n  }\n\n  protected async guessEncodingByBuffer(buffer: Buffer): Promise<string | undefined> {\n    const jschardet = await import('jschardet');\n\n    const guessed = jschardet.detect(buffer.slice(0, AUTO_ENCODING_GUESS_MAX_BYTES)); // ensure to limit buffer for guessing due to https://github.com/aadsm/jschardet/issues/53\n    if (!guessed || !guessed.encoding) {\n      return undefined;\n    }\n\n    const enc = guessed.encoding.toLowerCase();\n    if (0 <= IGNORE_ENCODINGS.indexOf(enc)) {\n      return undefined; // see comment above why we ignore some encodings\n    }\n\n    return this.toIconvEncoding(guessed.encoding);\n  }\n\n}\n"]}