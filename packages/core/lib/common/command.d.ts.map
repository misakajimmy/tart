{"version":3,"sources":["common/command.ts"],"names":[],"mappings":"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","file":"../../src/common/command.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {Event,} from './event';\nimport {Emitter, WaitUntilEvent} from './emitter';\nimport {Disposable, DisposableCollection} from './disposable';\nimport {ContributionProvider} from './contribution-provider';\nimport {nls} from './nls';\n\n/**\n * A command is a unique identifier of a function\n * which can be executed by a user via a keyboard shortcut,\n * a menu action or directly.\n */\nexport interface Command {\n  /**\n   * A unique identifier of this command.\n   */\n  id: string;\n  /**\n   * A label of this command.\n   */\n  label?: string;\n  originalLabel?: string;\n  /**\n   * An icon class of this command.\n   */\n  iconClass?: string;\n  /**\n   * A category of this command.\n   */\n  category?: string;\n  originalCategory?: string;\n}\n\nexport namespace Command {\n  /* Determine whether object is a Command */\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is(arg: Command | any): arg is Command {\n    return !!arg && arg === Object(arg) && 'id' in arg;\n  }\n\n  /** Utility function to easily translate commands */\n  export function toLocalizedCommand(command: Command, nlsLabelKey: string = command.id, nlsCategoryKey?: string): Command {\n    return {\n      ...command,\n      label: command.label && nls.localize(nlsLabelKey, command.label),\n      originalLabel: command.label,\n      category: nlsCategoryKey && command.category && nls.localize(nlsCategoryKey, command.category) || command.category,\n      originalCategory: command.category,\n    };\n  }\n\n  export function toDefaultLocalizedCommand(command: Command): Command {\n    return {\n      ...command,\n      label: command.label && nls.localizeByDefault(command.label),\n      originalLabel: command.label,\n      category: command.category && nls.localizeByDefault(command.category),\n      originalCategory: command.category,\n    };\n  }\n\n  /** Comparator function for when sorting commands */\n  export function compareCommands(a: Command, b: Command): number {\n    if (a.label && b.label) {\n      const aCommand = (a.category ? `${a.category}: ${a.label}` : a.label).toLowerCase();\n      const bCommand = (b.category ? `${b.category}: ${b.label}` : b.label).toLowerCase();\n      return (aCommand).localeCompare(bCommand);\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * Determine if two commands are equal.\n   *\n   * @param a the first command for comparison.\n   * @param b the second command for comparison.\n   */\n  export function equals(a: Command, b: Command): boolean {\n    return (\n        a.id === b.id &&\n        a.label === b.label &&\n        a.iconClass === b.iconClass &&\n        a.category === b.category\n    );\n  }\n}\n\n/**\n * A command handler is an implementation of a command.\n *\n * A command can have multiple handlers\n * but they should be active in different contexts,\n * otherwise first active will be executed.\n */\nexport interface CommandHandler {\n  /**\n   * Execute this handler.\n   *\n   * Don't call it directly, use `CommandService.executeCommand` instead.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  execute(...args: any[]): any;\n\n  /**\n   * Test whether this handler is enabled (active).\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isEnabled?(...args: any[]): boolean;\n\n  /**\n   * Test whether menu items for this handler should be visible.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isVisible?(...args: any[]): boolean;\n\n  /**\n   * Test whether menu items for this handler should be toggled.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isToggled?(...args: any[]): boolean;\n}\n\nexport const CommandContribution = Symbol('CommandContribution');\n\n/**\n * The command contribution should be implemented to register custom commands and handler.\n */\nexport interface CommandContribution {\n  /**\n   * Register commands and handlers.\n   */\n  registerCommands(commands: CommandRegistry): void;\n}\n\nexport interface CommandEvent {\n  commandId: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any[]\n}\n\nexport interface WillExecuteCommandEvent extends WaitUntilEvent, CommandEvent {\n}\n\nexport const commandServicePath = '/services/commands';\nexport const CommandService = Symbol('CommandService');\n\n/**\n * The command service should be used to execute commands.\n */\nexport interface CommandService {\n  /**\n   * An event is emitted when a command is about to be executed.\n   *\n   * It can be used to install or activate a command handler.\n   */\n  readonly onWillExecuteCommand: Event<WillExecuteCommandEvent>;\n  /**\n   * An event is emitted when a command was executed.\n   */\n  readonly onDidExecuteCommand: Event<CommandEvent>;\n\n  /**\n   * Execute the active handler for the given command and arguments.\n   *\n   * Reject if a command cannot be executed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  executeCommand<T>(command: string, ...args: any[]): Promise<T | undefined>;\n}\n\n/**\n * The command registry manages commands and handlers.\n */\n@injectable()\nexport class CommandRegistry implements CommandService {\n\n  protected readonly _commands: { [id: string]: Command } = {};\n  protected readonly _handlers: { [id: string]: CommandHandler[] } = {};\n\n  protected readonly toUnregisterCommands = new Map<string, Disposable>();\n  protected readonly onWillExecuteCommandEmitter = new Emitter<WillExecuteCommandEvent>();\n  readonly onWillExecuteCommand = this.onWillExecuteCommandEmitter.event;\n  protected readonly onDidExecuteCommandEmitter = new Emitter<CommandEvent>();\n  readonly onDidExecuteCommand = this.onDidExecuteCommandEmitter.event;\n\n  constructor(\n      @inject(ContributionProvider) @named(CommandContribution)\n      protected readonly contributionProvider: ContributionProvider<CommandContribution>\n  ) {\n  }\n\n  // List of recently used commands.\n  protected _recent: Command[] = [];\n\n  /**\n   * Get the list of recently used commands.\n   */\n  get recent(): Command[] {\n    return this._recent;\n  }\n\n  /**\n   * Set the list of recently used commands.\n   * @param commands the list of recently used commands.\n   */\n  set recent(commands: Command[]) {\n    this._recent = commands;\n  }\n\n  /**\n   * Get all registered commands.\n   */\n  get commands(): Command[] {\n    const commands: Command[] = [];\n    for (const id of this.commandIds) {\n      const cmd = this.getCommand(id);\n      if (cmd) {\n        commands.push(cmd);\n      }\n    }\n    return commands;\n  }\n\n  /**\n   * Get all registered commands identifiers.\n   */\n  get commandIds(): string[] {\n    return Object.keys(this._commands);\n  }\n\n  onStart(): void {\n    const contributions = this.contributionProvider.getContributions();\n    for (const contrib of contributions) {\n      contrib.registerCommands(this);\n    }\n  }\n\n  /**\n   * Register the given command and handler if present.\n   *\n   * Throw if a command is already registered for the given command identifier.\n   */\n  registerCommand(command: Command, handler?: CommandHandler): Disposable {\n    if (this._commands[command.id]) {\n      console.warn(`A command ${command.id} is already registered.`);\n      return Disposable.NULL;\n    }\n    const toDispose = new DisposableCollection(this.doRegisterCommand(command));\n    if (handler) {\n      toDispose.push(this.registerHandler(command.id, handler));\n    }\n    this.toUnregisterCommands.set(command.id, toDispose);\n    toDispose.push(Disposable.create(() => this.toUnregisterCommands.delete(command.id)));\n    return toDispose;\n  }\n\n  /**\n   * Unregister command from the registry\n   *\n   * @param command\n   */\n  unregisterCommand(command: Command): void;\n\n  /**\n   * Unregister command from the registry\n   *\n   * @param id\n   */\n  unregisterCommand(id: string): void;\n\n  unregisterCommand(commandOrId: Command | string): void {\n    const id = Command.is(commandOrId) ? commandOrId.id : commandOrId;\n    const toUnregister = this.toUnregisterCommands.get(id);\n    if (toUnregister) {\n      toUnregister.dispose();\n    }\n  }\n\n  /**\n   * Register the given handler for the given command identifier.\n   *\n   * If there is already a handler for the given command\n   * then the given handler is registered as more specific, and\n   * has higher priority during enablement, visibility and toggle state evaluations.\n   */\n  registerHandler(commandId: string, handler: CommandHandler): Disposable {\n    let handlers = this._handlers[commandId];\n    if (!handlers) {\n      this._handlers[commandId] = handlers = [];\n    }\n    handlers.unshift(handler);\n    return {\n      dispose: () => {\n        const idx = handlers.indexOf(handler);\n        if (idx >= 0) {\n          handlers.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Test whether there is an active handler for the given command.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isEnabled(command: string, ...args: any[]): boolean {\n    return typeof this.getActiveHandler(command, ...args) !== 'undefined';\n  }\n\n  /**\n   * Test whether there is a visible handler for the given command.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isVisible(command: string, ...args: any[]): boolean {\n    return typeof this.getVisibleHandler(command, ...args) !== 'undefined';\n  }\n\n  /**\n   * Test whether there is a toggled handler for the given command.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isToggled(command: string, ...args: any[]): boolean {\n    return typeof this.getToggledHandler(command, ...args) !== 'undefined';\n  }\n\n  /**\n   * Execute the active handler for the given command and arguments.\n   *\n   * Reject if a command cannot be executed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async executeCommand<T>(commandId: string, ...args: any[]): Promise<T | undefined> {\n    const handler = this.getActiveHandler(commandId, ...args);\n    if (handler) {\n      await this.fireWillExecuteCommand(commandId, args);\n      const result = await handler.execute(...args);\n      this.onDidExecuteCommandEmitter.fire({commandId, args});\n      return result;\n    }\n    throw Object.assign(new Error(`The command '${commandId}' cannot be executed. There are no active handlers available for the command.`), {code: 'NO_ACTIVE_HANDLER'});\n  }\n\n  /**\n   * Get a visible handler for the given command or `undefined`.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getVisibleHandler(commandId: string, ...args: any[]): CommandHandler | undefined {\n    const handlers = this._handlers[commandId];\n    if (handlers) {\n      for (const handler of handlers) {\n        try {\n          if (!handler.isVisible || handler.isVisible(...args)) {\n            return handler;\n          }\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get an active handler for the given command or `undefined`.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getActiveHandler(commandId: string, ...args: any[]): CommandHandler | undefined {\n    const handlers = this._handlers[commandId];\n    if (handlers) {\n      for (const handler of handlers) {\n        try {\n          if (!handler.isEnabled || handler.isEnabled(...args)) {\n            return handler;\n          }\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get a toggled handler for the given command or `undefined`.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getToggledHandler(commandId: string, ...args: any[]): CommandHandler | undefined {\n    const handlers = this._handlers[commandId];\n    if (handlers) {\n      for (const handler of handlers) {\n        try {\n          if (handler.isToggled && handler.isToggled(...args)) {\n            return handler;\n          }\n        } catch (error) {\n          console.error(error);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns with all handlers for the given command. If the command does not have any handlers,\n   * or the command is not registered, returns an empty array.\n   */\n  getAllHandlers(commandId: string): CommandHandler[] {\n    const handlers = this._handlers[commandId];\n    return handlers ? handlers.slice() : [];\n  }\n\n  /**\n   * Get a command for the given command identifier.\n   */\n  getCommand(id: string): Command | undefined {\n    return this._commands[id];\n  }\n\n  /**\n   * Adds a command to recently used list.\n   * Prioritizes commands that were recently executed to be most recent.\n   *\n   * @param recent a recent command, or array of recent commands.\n   */\n  addRecentCommand(recent: Command | Command[]): void {\n    if (Array.isArray(recent)) {\n      recent.forEach((command: Command) => this.addRecentCommand(command));\n    } else {\n      // Determine if the command currently exists in the recently used list.\n      const index = this._recent.findIndex((command: Command) => Command.equals(recent, command));\n      // If the command exists, remove it from the array so it can later be placed at the top.\n      if (index >= 0) {\n        this._recent.splice(index, 1);\n      }\n      // Add the recent command to the beginning of the array (most recent).\n      this._recent.unshift(recent);\n    }\n  }\n\n  /**\n   * Clear the list of recently used commands.\n   */\n  clearCommandHistory(): void {\n    this.recent = [];\n  }\n\n  protected doRegisterCommand(command: Command): Disposable {\n    this._commands[command.id] = command;\n    return {\n      dispose: () => {\n        delete this._commands[command.id];\n      }\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected async fireWillExecuteCommand(commandId: string, args: any[] = []): Promise<void> {\n    await WaitUntilEvent.fire(this.onWillExecuteCommandEmitter, {commandId, args}, 30000);\n  }\n\n}\n"]}