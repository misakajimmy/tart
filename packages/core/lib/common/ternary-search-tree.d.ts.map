{"version":3,"sources":["common/ternary-search-tree.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAWlF,OAAO,GAAG,MAAM,OAAO,CAAC;AAIxB,MAAM,WAAW,YAAY,CAAC,CAAC;IAC7B,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC;IAEpB,IAAI,IAAI,IAAI,CAAC;IAEb,OAAO,IAAI,OAAO,CAAC;IAEnB,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,MAAM,CAAC;IAEvB,KAAK,IAAI,MAAM,CAAC;CACjB;AAED,qBAAa,YAAa,YAAW,YAAY,CAAC,MAAM,CAAC;IAOnD,OAAO,CAAC,QAAQ,CAAC,iBAAiB;IAClC,OAAO,CAAC,QAAQ,CAAC,cAAc;IANnC,OAAO,CAAC,MAAM,CAAU;IACxB,OAAO,CAAC,KAAK,CAAU;IACvB,OAAO,CAAC,GAAG,CAAU;gBAGA,iBAAiB,GAAE,OAAc,EACjC,cAAc,GAAE,OAAc;IAInD,KAAK,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAOxB,OAAO,IAAI,OAAO;IAIlB,IAAI,IAAI,IAAI;IAmBZ,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,MAAM;IAMtB,KAAK,IAAI,MAAM;CAGhB;AAMD,qBAAa,WAAY,YAAW,YAAY,CAAC,GAAG,CAAC;IAQ/C,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,OAAO;IAN7C,OAAO,CAAC,aAAa,CAAgB;IACrC,OAAO,CAAC,MAAM,CAAO;IACrB,OAAO,CAAC,OAAO,CAA0B;IACzC,OAAO,CAAC,SAAS,CAAa;gBAGP,aAAa,EAAE,OAAO;IAI7C,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI;IA0BrB,IAAI,IAAI,IAAI;IASZ,OAAO,IAAI,OAAO;IAKlB,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,MAAM;IAetB,KAAK,IAAI,MAAM;CAchB;AAeD,qBAAa,iBAAiB,CAAC,CAAC,EAAE,CAAC;IAEjC,OAAO,CAAC,KAAK,CAAkB;IAC/B,OAAO,CAAC,KAAK,CAA0C;gBAE3C,QAAQ,EAAE,YAAY,CAAC,CAAC,CAAC;IAIrC,MAAM,CAAC,OAAO,CAAC,CAAC,EAAE,aAAa,EAAE,OAAO,GAAG,iBAAiB,CAAC,GAAG,EAAE,CAAC,CAAC;IAIpE,MAAM,CAAC,QAAQ,CAAC,CAAC,KAAK,iBAAiB,CAAC,MAAM,EAAE,CAAC,CAAC;IAIlD,KAAK,IAAI,IAAI;IAIb,GAAG,CAAC,GAAG,EAAE,CAAC,EAAE,OAAO,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS;IA8CtC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS;IAsB1B,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI;IA+CpB,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,SAAS;IAwBjC,YAAY,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS;IA2B7C,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,KAAK,GAAG;IAI7C,OAAO,CAAC,aAAa;IAyBrB,OAAO,CAAC,QAAQ;CAiBjB","file":"../../src/common/ternary-search-tree.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/map.ts#L251\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/tslint/config */\n\nimport URI from './uri';\nimport {CharCode} from './char-code';\nimport {compare, compareSubstring, compareSubstringIgnoreCase} from './strings';\n\nexport interface IKeyIterator<K> {\n  reset(key: K): this;\n\n  next(): this;\n\n  hasNext(): boolean;\n\n  cmp(a: string): number;\n\n  value(): string;\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n  private _value!: string;\n  private _from!: number;\n  private _to!: number;\n\n  constructor(\n      private readonly _splitOnBackslash: boolean = true,\n      private readonly _caseSensitive: boolean = true\n  ) {\n  }\n\n  reset(key: string): this {\n    this._value = key.replace(/\\\\$|\\/$/, '');\n    this._from = 0;\n    this._to = 0;\n    return this.next();\n  }\n\n  hasNext(): boolean {\n    return this._to < this._value.length;\n  }\n\n  next(): this {\n    // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n    this._from = this._to;\n    let justSeps = true;\n    for (; this._to < this._value.length; this._to++) {\n      const ch = this._value.charCodeAt(this._to);\n      if (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n        if (justSeps) {\n          this._from++;\n        } else {\n          break;\n        }\n      } else {\n        justSeps = false;\n      }\n    }\n    return this;\n  }\n\n  cmp(a: string): number {\n    return this._caseSensitive\n        ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n        : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n  }\n\n  value(): string {\n    return this._value.substring(this._from, this._to);\n  }\n}\n\nconst enum UriIteratorState {\n  Scheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n  private _pathIterator!: PathIterator;\n  private _value!: URI;\n  private _states: UriIteratorState[] = [];\n  private _stateIdx: number = 0;\n\n  constructor(\n      protected readonly caseSensitive: boolean\n  ) {\n  }\n\n  reset(key: URI): this {\n    this._value = key;\n    this._states = [];\n    if (this._value.scheme) {\n      this._states.push(UriIteratorState.Scheme);\n    }\n    if (this._value.authority) {\n      this._states.push(UriIteratorState.Authority);\n    }\n    if (this._value.path) {\n      this._pathIterator = new PathIterator(false, this.caseSensitive);\n      this._pathIterator.reset(key.path.toString());\n      if (this._pathIterator.value()) {\n        this._states.push(UriIteratorState.Path);\n      }\n    }\n    if (this._value.query) {\n      this._states.push(UriIteratorState.Query);\n    }\n    if (this._value.fragment) {\n      this._states.push(UriIteratorState.Fragment);\n    }\n    this._stateIdx = 0;\n    return this;\n  }\n\n  next(): this {\n    if (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n      this._pathIterator.next();\n    } else {\n      this._stateIdx += 1;\n    }\n    return this;\n  }\n\n  hasNext(): boolean {\n    return (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n        || this._stateIdx < this._states.length - 1;\n  }\n\n  cmp(a: string): number {\n    if (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n      return compareSubstringIgnoreCase(a, this._value.scheme);\n    } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n      return compareSubstringIgnoreCase(a, this._value.authority);\n    } else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n      return this._pathIterator.cmp(a);\n    } else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n      return compare(a, this._value.query);\n    } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n      return compare(a, this._value.fragment);\n    }\n    throw new Error();\n  }\n\n  value(): string {\n    if (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n      return this._value.scheme;\n    } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n      return this._value.authority;\n    } else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n      return this._pathIterator.value();\n    } else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n      return this._value.query;\n    } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n      return this._value.fragment;\n    }\n    throw new Error();\n  }\n}\n\nclass TernarySearchTreeNode<K, V> {\n  segment!: string;\n  value: V | undefined;\n  key!: K;\n  left: TernarySearchTreeNode<K, V> | undefined;\n  mid: TernarySearchTreeNode<K, V> | undefined;\n  right: TernarySearchTreeNode<K, V> | undefined;\n\n  isEmpty(): boolean {\n    return !this.left && !this.mid && !this.right && !this.value;\n  }\n}\n\nexport class TernarySearchTree<K, V> {\n\n  private _iter: IKeyIterator<K>;\n  private _root: TernarySearchTreeNode<K, V> | undefined;\n\n  constructor(segments: IKeyIterator<K>) {\n    this._iter = segments;\n  }\n\n  static forUris<E>(caseSensitive: boolean): TernarySearchTree<URI, E> {\n    return new TernarySearchTree<URI, E>(new UriIterator(caseSensitive));\n  }\n\n  static forPaths<E>(): TernarySearchTree<string, E> {\n    return new TernarySearchTree<string, E>(new PathIterator());\n  }\n\n  clear(): void {\n    this._root = undefined;\n  }\n\n  set(key: K, element: V): V | undefined {\n    const iter = this._iter.reset(key);\n    let node: TernarySearchTreeNode<K, V>;\n\n    if (!this._root) {\n      this._root = new TernarySearchTreeNode<K, V>();\n      this._root.segment = iter.value();\n    }\n\n    node = this._root;\n    while (true) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        if (!node.left) {\n          node.left = new TernarySearchTreeNode<K, V>();\n          node.left.segment = iter.value();\n        }\n        node = node.left;\n\n      } else if (val < 0) {\n        // right\n        if (!node.right) {\n          node.right = new TernarySearchTreeNode<K, V>();\n          node.right.segment = iter.value();\n        }\n        node = node.right;\n\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        if (!node.mid) {\n          node.mid = new TernarySearchTreeNode<K, V>();\n          node.mid.segment = iter.value();\n        }\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    const oldElement = node.value;\n    node.value = element;\n    node.key = key;\n    return oldElement;\n  }\n\n  get(key: K): V | undefined {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node ? node.value : undefined;\n  }\n\n  delete(key: K): void {\n\n    const iter = this._iter.reset(key);\n    const stack: [-1 | 0 | 1, TernarySearchTreeNode<K, V>][] = [];\n    let node = this._root;\n\n    // find and unset node\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        stack.push([1, node]);\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        stack.push([-1, node]);\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        stack.push([0, node]);\n        node = node.mid;\n      } else {\n        // remove element\n        node.value = undefined;\n\n        // clean up empty nodes\n        while (stack.length > 0 && node.isEmpty()) {\n          const [dir, parent] = stack.pop()!;\n          switch (dir) {\n            case 1:\n              parent.left = undefined;\n              break;\n            case 0:\n              parent.mid = undefined;\n              break;\n            case -1:\n              parent.right = undefined;\n              break;\n          }\n          node = parent;\n        }\n        break;\n      }\n    }\n  }\n\n  findSubstr(key: K): V | undefined {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    let candidate: V | undefined = undefined;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        candidate = node.value || candidate;\n        node = node.mid;\n      } else {\n        break;\n      }\n    }\n    return node && node.value || candidate;\n  }\n\n  findSuperstr(key: K): Iterator<V> | undefined {\n    const iter = this._iter.reset(key);\n    let node = this._root;\n    while (node) {\n      const val = iter.cmp(node.segment);\n      if (val > 0) {\n        // left\n        node = node.left;\n      } else if (val < 0) {\n        // right\n        node = node.right;\n      } else if (iter.hasNext()) {\n        // mid\n        iter.next();\n        node = node.mid;\n      } else {\n        // collect\n        if (!node.mid) {\n          return undefined;\n        } else {\n          return this._nodeIterator(node.mid);\n        }\n      }\n    }\n    return undefined;\n  }\n\n  forEach(callback: (value: V, index: K) => any) {\n    this._forEach(this._root, callback);\n  }\n\n  private _nodeIterator(node: TernarySearchTreeNode<K, V>): Iterator<V> {\n    let res: { done: false; value: V; };\n    let idx: number;\n    let data: V[];\n    const next = (): IteratorResult<V> => {\n      if (!data) {\n        // lazy till first invocation\n        data = [];\n        idx = 0;\n        this._forEach(node, value => data.push(value));\n      }\n      if (idx >= data.length) {\n        return {done: true, value: undefined};\n      }\n\n      if (!res) {\n        res = {done: false, value: data[idx++]};\n      } else {\n        res.value = data[idx++];\n      }\n      return res;\n    };\n    return {next};\n  }\n\n  private _forEach(node: TernarySearchTreeNode<K, V> | undefined, callback: (value: V, index: K) => any) {\n    if (node) {\n      // left\n      this._forEach(node.left, callback);\n\n      // node\n      if (node.value) {\n        // callback(node.value, this._iter.join(parts));\n        callback(node.value, node.key);\n      }\n      // mid\n      this._forEach(node.mid, callback);\n\n      // right\n      this._forEach(node.right, callback);\n    }\n  }\n}\n"]}