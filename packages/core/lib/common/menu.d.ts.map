{"version":3,"sources":["common/menu.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AAGlF,OAAO,EAAC,UAAU,EAAC,MAAM,cAAc,CAAC;AACxC,OAAO,EAAC,OAAO,EAAE,eAAe,EAAC,MAAM,WAAW,CAAC;AACnD,OAAO,EAAC,oBAAoB,EAAC,MAAM,yBAAyB,CAAC;AAE7D;;GAEG;AACH,MAAM,WAAW,UAAU;IACzB;;OAEG;IACH,SAAS,EAAE,MAAM,CAAA;IACjB;;;OAGG;IACH,GAAG,CAAC,EAAE,MAAM,CAAC;IACb;;OAEG;IACH,KAAK,CAAC,EAAE,MAAM,CAAA;IACd;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAA;IACb;;;OAGG;IACH,KAAK,CAAC,EAAE,MAAM,CAAA;IACd;;;OAGG;IACH,IAAI,CAAC,EAAE,MAAM,CAAA;CACd;AAED,yBAAiB,UAAU,CAAC;IAI1B,SAAgB,EAAE,CAAC,GAAG,EAAE,UAAU,GAAG,GAAG,GAAG,GAAG,IAAI,UAAU,CAE3D;CACF;AAED;;GAEG;AACH,MAAM,WAAW,cAAc;IAC7B;;OAEG;IACH,SAAS,CAAC,EAAE,MAAM,CAAA;IAClB;;;OAGG;IACH,KAAK,CAAC,EAAE,MAAM,CAAA;CACf;AAED,oBAAY,QAAQ,GAAG,MAAM,EAAE,CAAC;AAEhC,eAAO,MAAM,aAAa,EAAE,QAAsB,CAAC;AAEnD,eAAO,MAAM,aAAa,EAAE,QAA4B,CAAC;AACzD,eAAO,MAAM,aAAa,EAAE,QAA4B,CAAC;AACzD,eAAO,MAAM,gBAAgB,UAA2C,CAAC;AAEzE,eAAO,MAAM,gBAAgB,eAA6B,CAAC;AAE3D;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,MAAM,WAAW,gBAAgB;IAC/B;;;OAGG;IACH,aAAa,CAAC,KAAK,EAAE,iBAAiB,GAAG,IAAI,CAAC;CAC/C;AAED;;;;GAIG;AACH,qBACa,iBAAiB;IAKxB,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,oBAAoB,CAAC,gBAAgB,CAAC;IAC/C,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,eAAe;IALzE,SAAS,CAAC,QAAQ,CAAC,IAAI,oBAA6B;gBAI7B,aAAa,EAAE,oBAAoB,CAAC,gBAAgB,CAAC,EAC5B,QAAQ,EAAE,eAAe;IAIzE,OAAO,IAAI,IAAI;IAMf;;;;OAIG;IACH,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,GAAG,UAAU;IAKpE;;;;OAIG;IACH,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,GAAG,UAAU;IAKpE;;;;;;;;;;;;;;OAcG;IACH,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,cAAc,GAAG,UAAU;IAiCxF;;;;;OAKG;IACH,oBAAoB,CAAC,IAAI,EAAE,UAAU,EAAE,QAAQ,CAAC,EAAE,QAAQ,GAAG,IAAI;IACjE;;;;;OAKG;IACH,oBAAoB,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,QAAQ,GAAG,IAAI;IACjE;;;;;OAKG;IACH,oBAAoB,CAAC,EAAE,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,QAAQ,GAAG,IAAI;IAe3D;;;;OAIG;IACH,kBAAkB,CAAC,EAAE,EAAE,MAAM,GAAG,IAAI;IAYpC;;;;;;;OAOG;IACH,OAAO,CAAC,QAAQ,GAAE,QAAa,GAAG,iBAAiB;IAInD,SAAS,CAAC,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,EAAE,cAAc,GAAG,iBAAiB;IAQpF,SAAS,CAAC,WAAW,CAAC,OAAO,EAAE,iBAAiB,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,cAAc,GAAG,iBAAiB;CAY/G;AAED;;GAEG;AACH,MAAM,WAAW,QAAQ;IACvB;;OAEG;IACH,QAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,CAAA;IACvB;;OAEG;IACH,QAAQ,CAAC,EAAE,EAAE,MAAM,CAAA;IACnB;;OAEG;IACH,QAAQ,CAAC,UAAU,EAAE,MAAM,CAAA;CAC5B;AAED;;GAEG;AACH,qBAAa,iBAAkB,YAAW,QAAQ;aAM5B,EAAE,EAAE,MAAM;IACnB,KAAK,CAAC,EAAE,MAAM;IANlB,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,KAAK,CAAC,EAAE,MAAM,CAAC;IACtB,SAAS,CAAC,QAAQ,CAAC,SAAS,EAAE,QAAQ,EAAE,CAAM;gBAG1B,EAAE,EAAE,MAAM,EACnB,KAAK,CAAC,EAAE,MAAM,EACrB,OAAO,CAAC,EAAE,cAAc;IAQ5B,IAAI,QAAQ,IAAI,aAAa,CAAC,QAAQ,CAAC,CAEtC;IAED,IAAI,UAAU,IAAI,MAAM,CAEvB;IAED,IAAI,SAAS,IAAI,OAAO,CAEvB;IAED;;;;;;OAMG;IACH,MAAM,CAAC,iBAAiB,CAAC,IAAI,EAAE,QAAQ,GAAG,IAAI,IAAI,iBAAiB;IAInE;;;;OAIG;IACI,OAAO,CAAC,IAAI,EAAE,QAAQ,GAAG,UAAU;IA4B1C;;;;OAIG;IACI,UAAU,CAAC,EAAE,EAAE,MAAM,GAAG,IAAI;CASpC;AAED;;;;GAIG;AACH,qBAAa,cAAe,YAAW,QAAQ;aAKzB,MAAM,EAAE,UAAU;IAClC,SAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,eAAe;IAJhD,QAAQ,CAAC,OAAO,EAAE,cAAc,GAAG,SAAS,CAAC;gBAGzB,MAAM,EAAE,UAAU,EACf,QAAQ,EAAE,eAAe;IAOhD,IAAI,EAAE,IAAI,MAAM,CAEf;IAED,IAAI,KAAK,IAAI,MAAM,CAUlB;IAED,IAAI,IAAI,IAAI,MAAM,GAAG,SAAS,CAM7B;IAED,IAAI,UAAU,IAAI,MAAM,CAEvB;CACF","file":"../../src/common/menu.d.ts","sourcesContent":["/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport {inject, injectable, named} from 'inversify';\nimport {Disposable} from './disposable';\nimport {Command, CommandRegistry} from './command';\nimport {ContributionProvider} from './contribution-provider';\n\n/**\n * A menu entry representing an action, e.g. \"New File\".\n */\nexport interface MenuAction {\n  /**\n   * The command to execute.\n   */\n  commandId: string\n  /**\n   * In addition to the mandatory command property, an alternative command can be defined.\n   * It will be shown and invoked when pressing Alt while opening a menu.\n   */\n  alt?: string;\n  /**\n   * A specific label for this action. If not specified the command label or command id will be used.\n   */\n  label?: string\n  /**\n   * Icon class(es). If not specified the icon class associated with the specified command\n   * (i.e. `command.iconClass`) will be used if it exists.\n   */\n  icon?: string\n  /**\n   * Menu entries are sorted in ascending order based on their `order` strings. If omitted the determined\n   * label will be used instead.\n   */\n  order?: string\n  /**\n   * Optional expression which will be evaluated by the {@link ContextKeyService} to determine visibility\n   * of the action, e.g. `resourceLangId == markdown`.\n   */\n  when?: string\n}\n\nexport namespace MenuAction {\n  /* Determine whether object is a MenuAction */\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  export function is(arg: MenuAction | any): arg is MenuAction {\n    return !!arg && arg === Object(arg) && 'commandId' in arg;\n  }\n}\n\n/**\n * Additional options when creating a new submenu.\n */\nexport interface SubMenuOptions {\n  /**\n   * The class to use for the submenu icon.\n   */\n  iconClass?: string\n  /**\n   * Menu entries are sorted in ascending order based on their `order` strings. If omitted the determined\n   * label will be used instead.\n   */\n  order?: string\n}\n\nexport type MenuPath = string[];\n\nexport const MAIN_MENU_BAR: MenuPath = ['menubar'];\n\nexport const SETTINGS_MENU: MenuPath = ['settings_menu'];\nexport const ACCOUNTS_MENU: MenuPath = ['accounts_menu'];\nexport const ACCOUNTS_SUBMENU = [...ACCOUNTS_MENU, '1_accounts_submenu'];\n\nexport const MenuContribution = Symbol('MenuContribution');\n\n/**\n * Representation of a menu contribution.\n *\n * Note that there are also convenience classes which combine multiple contributions into one.\n * For example to register a view together with a menu and keybinding you could use\n * {@link AbstractViewContribution} instead.\n *\n * ### Example usage\n *\n * ```ts\n * import { MenuContribution, MenuModelRegistry, MAIN_MENU_BAR } from '@tart/core';\n *\n * @injectable()\n * export class NewMenuContribution implements MenuContribution {\n *    registerMenus(menus: MenuModelRegistry): void {\n *         const menuPath = [...MAIN_MENU_BAR, '99_mymenu'];\n *         menus.registerSubmenu(menuPath, 'My Menu');\n *\n *         menus.registerMenuAction(menuPath, {\n *            commandId: MyCommand.id,\n *            label: 'My Action'\n *         });\n *     }\n * }\n * ```\n */\nexport interface MenuContribution {\n  /**\n   * Registers menus.\n   * @param menus the menu model registry.\n   */\n  registerMenus(menus: MenuModelRegistry): void;\n}\n\n/**\n * The MenuModelRegistry allows to register and unregister menus, submenus and actions\n * via strings and {@link MenuAction}s without the need to access the underlying UI\n * representation.\n */\n@injectable()\nexport class MenuModelRegistry {\n  protected readonly root = new CompositeMenuNode('');\n\n  constructor(\n      @inject(ContributionProvider) @named(MenuContribution)\n      protected readonly contributions: ContributionProvider<MenuContribution>,\n      @inject(CommandRegistry) protected readonly commands: CommandRegistry\n  ) {\n  }\n\n  onStart(): void {\n    for (const contrib of this.contributions.getContributions()) {\n      contrib.registerMenus(this);\n    }\n  }\n\n  /**\n   * Adds the given menu action to the menu denoted by the given path.\n   *\n   * @returns a disposable which, when called, will remove the menu action again.\n   */\n  registerMenuAction(menuPath: MenuPath, item: MenuAction): Disposable {\n    const menuNode = new ActionMenuNode(item, this.commands);\n    return this.registerMenuNode(menuPath, menuNode);\n  }\n\n  /**\n   * Adds the given menu node to the menu denoted by the given path.\n   *\n   * @returns a disposable which, when called, will remove the menu node again.\n   */\n  registerMenuNode(menuPath: MenuPath, menuNode: MenuNode): Disposable {\n    const parent = this.findGroup(menuPath);\n    return parent.addNode(menuNode);\n  }\n\n  /**\n   * Register a new menu at the given path with the given label.\n   * (If the menu already exists without a label, iconClass or order this method can be used to set them.)\n   *\n   * @param menuPath the path for which a new submenu shall be registered.\n   * @param label the label to be used for the new submenu.\n   * @param options optionally allows to set an icon class and specify the order of the new menu.\n   *\n   * @returns if the menu was successfully created a disposable will be returned which,\n   * when called, will remove the menu again. If the menu already existed a no-op disposable\n   * will be returned.\n   *\n   * Note that if the menu already existed and was registered with a different label an error\n   * will be thrown.\n   */\n  registerSubmenu(menuPath: MenuPath, label: string, options?: SubMenuOptions): Disposable {\n    if (menuPath.length === 0) {\n      throw new Error('The sub menu path cannot be empty.');\n    }\n    const index = menuPath.length - 1;\n    const menuId = menuPath[index];\n    const groupPath = index === 0 ? [] : menuPath.slice(0, index);\n    const parent = this.findGroup(groupPath, options);\n    let groupNode = this.findSubMenu(parent, menuId, options);\n    if (!groupNode) {\n      groupNode = new CompositeMenuNode(menuId, label, options);\n      return parent.addNode(groupNode);\n    } else {\n      if (!groupNode.label) {\n        groupNode.label = label;\n      } else if (groupNode.label !== label) {\n        throw new Error(\"The group '\" + menuPath.join('/') + \"' already has a different label.\");\n      }\n      if (options) {\n        if (!groupNode.iconClass) {\n          groupNode.iconClass = options.iconClass;\n        }\n        if (!groupNode.order) {\n          groupNode.order = options.order;\n        }\n      }\n      return {\n        dispose: () => {\n        }\n      };\n    }\n  }\n\n  /**\n   * Unregister all menu nodes with the same id as the given menu action.\n   *\n   * @param item the item whose id will be used.\n   * @param menuPath if specified only nodes within the path will be unregistered.\n   */\n  unregisterMenuAction(item: MenuAction, menuPath?: MenuPath): void;\n  /**\n   * Unregister all menu nodes with the same id as the given command.\n   *\n   * @param command the command whose id will be used.\n   * @param menuPath if specified only nodes within the path will be unregistered.\n   */\n  unregisterMenuAction(command: Command, menuPath?: MenuPath): void;\n  /**\n   * Unregister all menu nodes with the given id.\n   *\n   * @param id the id which shall be removed.\n   * @param menuPath if specified only nodes within the path will be unregistered.\n   */\n  unregisterMenuAction(id: string, menuPath?: MenuPath): void;\n  unregisterMenuAction(itemOrCommandOrId: MenuAction | Command | string, menuPath?: MenuPath): void {\n    const id = MenuAction.is(itemOrCommandOrId) ? itemOrCommandOrId.commandId\n        : Command.is(itemOrCommandOrId) ? itemOrCommandOrId.id\n            : itemOrCommandOrId;\n\n    if (menuPath) {\n      const parent = this.findGroup(menuPath);\n      parent.removeNode(id);\n      return;\n    }\n\n    this.unregisterMenuNode(id);\n  }\n\n  /**\n   * Recurse all menus, removing any menus matching the `id`.\n   *\n   * @param id technical identifier of the `MenuNode`.\n   */\n  unregisterMenuNode(id: string): void {\n    const recurse = (root: CompositeMenuNode) => {\n      root.children.forEach(node => {\n        if (node instanceof CompositeMenuNode) {\n          node.removeNode(id);\n          recurse(node);\n        }\n      });\n    };\n    recurse(this.root);\n  }\n\n  /**\n   * Returns the menu at the given path.\n   *\n   * @param menuPath the path specifying the menu to return. If not given the empty path will be used.\n   *\n   * @returns the root menu when `menuPath` is empty. If `menuPath` is not empty the specified menu is\n   * returned if it exists, otherwise an error is thrown.\n   */\n  getMenu(menuPath: MenuPath = []): CompositeMenuNode {\n    return this.findGroup(menuPath);\n  }\n\n  protected findGroup(menuPath: MenuPath, options?: SubMenuOptions): CompositeMenuNode {\n    let currentMenu = this.root;\n    for (const segment of menuPath) {\n      currentMenu = this.findSubMenu(currentMenu, segment, options);\n    }\n    return currentMenu;\n  }\n\n  protected findSubMenu(current: CompositeMenuNode, menuId: string, options?: SubMenuOptions): CompositeMenuNode {\n    const sub = current.children.find(e => e.id === menuId);\n    if (sub instanceof CompositeMenuNode) {\n      return sub;\n    }\n    if (sub) {\n      throw new Error(`'${menuId}' is not a menu group.`);\n    }\n    const newSub = new CompositeMenuNode(menuId, undefined, options);\n    current.addNode(newSub);\n    return newSub;\n  }\n}\n\n/**\n * Base interface of the nodes used in the menu tree structure.\n */\nexport interface MenuNode {\n  /**\n   * the optional label for this specific node.\n   */\n  readonly label?: string\n  /**\n   * technical identifier.\n   */\n  readonly id: string\n  /**\n   * Menu nodes are sorted in ascending order based on their `sortString`.\n   */\n  readonly sortString: string\n}\n\n/**\n * Node representing a (sub)menu in the menu tree structure.\n */\nexport class CompositeMenuNode implements MenuNode {\n  public iconClass?: string;\n  public order?: string;\n  protected readonly _children: MenuNode[] = [];\n\n  constructor(\n      public readonly id: string,\n      public label?: string,\n      options?: SubMenuOptions\n  ) {\n    if (options) {\n      this.iconClass = options.iconClass;\n      this.order = options.order;\n    }\n  }\n\n  get children(): ReadonlyArray<MenuNode> {\n    return this._children;\n  }\n\n  get sortString(): string {\n    return this.order || this.id;\n  }\n\n  get isSubmenu(): boolean {\n    return this.label !== undefined;\n  }\n\n  /**\n   * Indicates whether the given node is the special `navigation` menu.\n   *\n   * @param node the menu node to check.\n   * @returns `true` when the given node is a {@link CompositeMenuNode} with id `navigation`,\n   * `false` otherwise.\n   */\n  static isNavigationGroup(node: MenuNode): node is CompositeMenuNode {\n    return node instanceof CompositeMenuNode && node.id === 'navigation';\n  }\n\n  /**\n   * Inserts the given node at the position indicated by `sortString`.\n   *\n   * @returns a disposable which, when called, will remove the given node again.\n   */\n  public addNode(node: MenuNode): Disposable {\n    this._children.push(node);\n    this._children.sort((m1, m2) => {\n      // The navigation group is special as it will always be sorted to the top/beginning of a menu.\n      if (CompositeMenuNode.isNavigationGroup(m1)) {\n        return -1;\n      }\n      if (CompositeMenuNode.isNavigationGroup(m2)) {\n        return 1;\n      }\n      if (m1.sortString < m2.sortString) {\n        return -1;\n      } else if (m1.sortString > m2.sortString) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    return {\n      dispose: () => {\n        const idx = this._children.indexOf(node);\n        if (idx >= 0) {\n          this._children.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Removes the first node with the given id.\n   *\n   * @param id node id.\n   */\n  public removeNode(id: string): void {\n    const node = this._children.find(n => n.id === id);\n    if (node) {\n      const idx = this._children.indexOf(node);\n      if (idx >= 0) {\n        this._children.splice(idx, 1);\n      }\n    }\n  }\n}\n\n/**\n * Node representing an action in the menu tree structure.\n * It's based on {@link MenuAction} for which it tries to determine the\n * best label, icon and sortString with the given data.\n */\nexport class ActionMenuNode implements MenuNode {\n\n  readonly altNode: ActionMenuNode | undefined;\n\n  constructor(\n      public readonly action: MenuAction,\n      protected readonly commands: CommandRegistry\n  ) {\n    if (action.alt) {\n      this.altNode = new ActionMenuNode({commandId: action.alt}, commands);\n    }\n  }\n\n  get id(): string {\n    return this.action.commandId;\n  }\n\n  get label(): string {\n    if (this.action.label) {\n      return this.action.label;\n    }\n    const cmd = this.commands.getCommand(this.action.commandId);\n    if (!cmd) {\n      console.debug(`No label for action menu node: No command \"${this.action.commandId}\" exists.`);\n      return '';\n    }\n    return cmd.label || cmd.id;\n  }\n\n  get icon(): string | undefined {\n    if (this.action.icon) {\n      return this.action.icon;\n    }\n    const command = this.commands.getCommand(this.action.commandId);\n    return command && command.iconClass;\n  }\n\n  get sortString(): string {\n    return this.action.order || this.label;\n  }\n}\n"]}