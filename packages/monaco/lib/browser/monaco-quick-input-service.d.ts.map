{"version":3,"sources":["browser/monaco-quick-input-service.ts"],"names":[],"mappings":";AACA,OAAO,EAAC,iBAAiB,EAAE,KAAK,EAAC,MAAM,uBAAuB,CAAC;AAC/D,OAAO,EACL,QAAQ,EACR,YAAY,EACZ,WAAW,EAEX,iBAAiB,EACjB,SAAS,EACT,aAAa,EAEb,uBAAuB,EACvB,gBAAgB,EAEjB,MAAM,0CAA0C,CAAC;AAClD,OAAO,EAAC,kBAAkB,EAAC,MAAM,mCAAmC,CAAC;AAGrE,qBACa,8BAA+B,YAAW,MAAM,CAAC,UAAU,CAAC,kBAAkB;IAEvF,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,oBAAoB,CAAC;IACnD,WAAW,EAAE,MAAM,CAAC,UAAU,CAAC,sBAAsB,CAAC;IAGtD,SAAS,CAAC,QAAQ,CAAC,iBAAiB,EAAE,MAAM,CAAC,iBAAiB,CAAC,iBAAiB,CAAC;IAEjF,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC;IACjC,OAAO,CAAC,cAAc,CAA6C;;IAQnE,IAAI,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,CAEpD;IAED,IAAI,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAExB;IAED,IAAI,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAExB;IAED,aAAa,CAAC,GAAG,EAAE,MAAM,GAAG,SAAS,GAAG,IAAI;IAM5C,eAAe,CAAC,CAAC,SAAS,MAAM,CAAC,UAAU,CAAC,cAAc,KAAK,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC;IAI9F,cAAc,IAAI,MAAM,CAAC,UAAU,CAAC,SAAS;IAI7C,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI;IAO1B,KAAK,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,aAAa,EAAE,KAAK,CAAC,EAAE,iBAAiB,GAAG,OAAO,CAAC,MAAM,GAAG,SAAS,CAAC;IAIxG,IAAI,CAAC,CAAC,SAAS,MAAM,CAAC,UAAU,CAAC,cAAc,EAAE,CAAC,SAAS,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,EACxF,KAAK,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,GAAE,CAAS,EAAE,KAAK,CAAC,EAAE,iBAAiB,GAAG,OAAO,CAAC,CAAC,CAAC,SAAS;QAAE,WAAW,EAAE,IAAI,CAAA;KAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;IAI/I,IAAI,IAAI,IAAI;IAIZ,KAAK,IAAI,IAAI;IAIb,MAAM,IAAI,IAAI;IAId,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,iBAAiB,GAAG,IAAI;IAI9D,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE,cAAc,EAAE,MAAM,GAAG,IAAI;IAIzE,QAAQ,CAAC,CAAC,IAAI,EAAE,OAAO,EAAE,aAAa,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,2BAA2B,GAAG,IAAI;IAI7F,OAAO,IAAI,IAAI;IAIT,MAAM,IAAI,OAAO,CAAC,IAAI,CAAC;IAIvB,IAAI,IAAI,OAAO,CAAC,IAAI,CAAC;IAIrB,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;IAIlE,OAAO,CAAC,aAAa;IAYrB,OAAO,CAAC,cAAc;IAKtB,OAAO,CAAC,UAAU;CAwBrB;AAkLD,qBACa,uBAAwB,YAAW,iBAAiB;IAE7D,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,oBAAoB,CAAC;IAEnD,SAAS,CAAC,QAAQ,CAAC,kBAAkB,EAAE,kBAAkB,CAAC;IAE1D,OAAO,CAAC,aAAa,CAAiC;IAEtD,IAAI,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,iBAAiB,CAEpD;IAED,IAAI,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAExB;IAED,IAAI,MAAM,IAAI,KAAK,CAAC,IAAI,CAAC,CAExB;IAED,IAAI,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI;IAI1B,cAAc,IAAI,QAAQ;IAI1B,KAAK,CAAC,OAAO,CAAC,EAAE,YAAY,EAAE,KAAK,CAAC,EAAE,iBAAiB,GAAG,OAAO,CAAC,MAAM,GAAG,SAAS,CAAC;IAYrF,IAAI,CAAC,CAAC,SAAS,aAAa,EAAE,CAAC,SAAS,WAAW,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,GAAG,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE,iBAAiB,GACrH,OAAO,CAAC,CAAC,CAAC,SAAS;QAAE,WAAW,EAAE,IAAI,CAAC;KAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,SAAS,CAAC;IAIrE,aAAa,CAAC,CAAC,SAAS,aAAa,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;IAkF7F,aAAa,CAAC,CAAC,SAAS,aAAa,EAAE,OAAO,EAAE,MAAM,CAAC,UAAU,CAAC,UAAU,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;IAInH,eAAe,CAAC,CAAC,SAAS,aAAa,KAAK,SAAS,CAAC,CAAC,CAAC;IAKxD,IAAI,IAAI,IAAI;CAGf;AAED,qBAAa,mBAAmB,CAAC,CAAC,SAAS,aAAa,CAAE,YAAW,MAAM,CAAC,UAAU,CAAC,cAAc;IAcrF,QAAQ,CAAC,IAAI,EAAE,CAAC;IAb5B,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC;IACrC,QAAQ,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC;IACrB,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC;IACvB,QAAQ,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC;IAC5B,QAAQ,CAAC,WAAW,CAAC,EAAE,MAAM,CAAC;IAC9B,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC;IACzB,QAAQ,CAAC,UAAU,CAAC,EAAE,MAAM,CAAC,WAAW,CAAC,kBAAkB,CAAC;IAC5D,QAAQ,CAAC,WAAW,CAAC,EAAE,MAAM,EAAE,CAAC;IAChC,OAAO,CAAC,EAAE,MAAM,CAAC,UAAU,CAAC,iBAAiB,EAAE,CAAC;IAChD,QAAQ,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;IAC9B,QAAQ,CAAC,UAAU,CAAC,EAAE,uBAAuB,CAAC;gBAEzB,IAAI,EAAE,CAAC,EAAE,UAAU,EAAE,kBAAkB;IAe5D,MAAM,IAAI,IAAI;CAKjB","file":"../../src/browser/monaco-quick-input-service.d.ts","sourcesContent":["import {inject, injectable} from 'inversify';\r\nimport {CancellationToken, Event} from '@tart/core/lib/common';\r\nimport {\r\n  InputBox,\r\n  InputOptions,\r\n  PickOptions,\r\n  QuickInputButton,\r\n  QuickInputService,\r\n  QuickPick,\r\n  QuickPickItem,\r\n  QuickPickItemButtonEvent,\r\n  QuickPickItemHighlights,\r\n  QuickPickOptions,\r\n  QuickPickSeparator\r\n} from '@tart/core/lib/common/quick-pick-service';\r\nimport {KeybindingRegistry} from '@tart/core/lib/browser/keybinding';\r\nimport {MonacoResolvedKeybinding} from './monaco-resolved-keybinding';\r\n\r\n@injectable()\r\nexport class MonacoQuickInputImplementation implements monaco.quickInput.IQuickInputService {\r\n\r\n    controller: monaco.quickInput.QuickInputController;\r\n    quickAccess: monaco.quickInput.IQuickAccessController;\r\n\r\n    @inject(monaco.contextKeyService.ContextKeyService)\r\n    protected readonly contextKeyService: monaco.contextKeyService.ContextKeyService;\r\n\r\n    protected container: HTMLElement;\r\n    private quickInputList: monaco.list.List<monaco.list.IListElement>;\r\n\r\n    constructor() {\r\n        this.initContainer();\r\n        this.initController();\r\n        this.quickAccess = new monaco.quickInput.QuickAccessController(this, monaco.services.StaticServices.instantiationService.get());\r\n    }\r\n\r\n    get backButton(): monaco.quickInput.IQuickInputButton {\r\n        return this.controller.backButton;\r\n    }\r\n\r\n    get onShow(): Event<void> {\r\n        return this.controller.onShow;\r\n    }\r\n\r\n    get onHide(): Event<void> {\r\n        return this.controller.onHide;\r\n    }\r\n\r\n    setContextKey(key: string | undefined): void {\r\n        if (key) {\r\n            this.contextKeyService.createKey<string>(key, undefined);\r\n        }\r\n    }\r\n\r\n    createQuickPick<T extends monaco.quickInput.IQuickPickItem>(): monaco.quickInput.IQuickPick<T> {\r\n        return this.controller.createQuickPick<T>();\r\n    }\r\n\r\n    createInputBox(): monaco.quickInput.IInputBox {\r\n        return this.controller.createInputBox();\r\n    }\r\n\r\n    open(filter: string): void {\r\n        this.quickAccess.show(filter);\r\n        setTimeout(() => {\r\n            this.quickInputList.focusNth(0);\r\n        }, 300);\r\n    }\r\n\r\n    input(options?: monaco.quickInput.IInputOptions, token?: CancellationToken): Promise<string | undefined> {\r\n        return this.controller.input(options, token);\r\n    }\r\n\r\n    pick<T extends monaco.quickInput.IQuickPickItem, O extends monaco.quickInput.IPickOptions<T>>(\r\n        picks: Promise<T[]> | T[], options: O = <O>{}, token?: CancellationToken): Promise<(O extends { canPickMany: true } ? T[] : T) | undefined> {\r\n        return this.controller.pick(picks, options, token);\r\n    }\r\n\r\n    hide(): void {\r\n        this.controller.hide();\r\n    }\r\n\r\n    focus(): void {\r\n        this.controller.focus();\r\n    }\r\n\r\n    toggle(): void {\r\n        this.controller.toggle();\r\n    }\r\n\r\n    applyStyles(styles: monaco.quickInput.IQuickInputStyles): void {\r\n        this.controller.applyStyles(styles);\r\n    }\r\n\r\n    layout(dimension: monaco.editor.IDimension, titleBarOffset: number): void {\r\n        this.controller.layout(dimension, titleBarOffset);\r\n    }\r\n\r\n    navigate?(next: boolean, quickNavigate?: monaco.quickInput.IQuickNavigateConfiguration): void {\r\n        this.controller.navigate(next, quickNavigate);\r\n    }\r\n\r\n    dispose(): void {\r\n        this.controller.dispose();\r\n    }\r\n\r\n    async cancel(): Promise<void> {\r\n        this.controller.cancel();\r\n    }\r\n\r\n    async back(): Promise<void> {\r\n        this.controller.back();\r\n    }\r\n\r\n    async accept?(keyMods?: monaco.quickInput.IKeyMods): Promise<void> {\r\n        this.controller.accept(keyMods);\r\n    }\r\n\r\n    private initContainer(): void {\r\n        const overlayWidgets = document.createElement('div');\r\n        overlayWidgets.classList.add('quick-input-overlay');\r\n        document.body.appendChild(overlayWidgets);\r\n        const container = this.container = document.createElement('quick-input-container');\r\n        container.style.position = 'absolute';\r\n        container.style.top = '0px';\r\n        container.style.right = '50%';\r\n        container.style.zIndex = '1000000';\r\n        overlayWidgets.appendChild(container);\r\n    }\r\n\r\n    private initController(): void {\r\n        this.controller = new monaco.quickInput.QuickInputController(this.getOptions());\r\n        this.controller.layout({width: 600, height: 1200}, 0);\r\n    }\r\n\r\n    private getOptions(): monaco.quickInput.IQuickInputOptions {\r\n        return {\r\n            idPrefix: 'quickInput_',\r\n            container: this.container,\r\n            ignoreFocusOut: () => false,\r\n            isScreenReaderOptimized: () => true,\r\n            backKeybindingLabel: () => undefined,\r\n            setContextKey: (id?: string) => this.setContextKey(id),\r\n            returnFocus: () => this.container.focus(),\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            createList: (user: string, container: HTMLElement, delegate: any, renderers: any, options: any) => {\r\n                this.quickInputList = new monaco.list.List(user, container, delegate, renderers, options);\r\n                return this.quickInputList;\r\n            },\r\n            styles: {\r\n                widget: {},\r\n                list: {},\r\n                inputBox: {},\r\n                countBadge: {},\r\n                button: {},\r\n                progressBar: {}\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\nclass MonacoQuickInput {\r\n    onDidHide: Event<void>;\r\n    onDispose: Event<void>;\r\n\r\n    constructor(protected readonly wrapped: monaco.quickInput.IQuickInput) {\r\n        this.onDidHide = this.wrapped.onDidHide;\r\n        this.onDispose = this.wrapped.onDispose;\r\n    }\r\n\r\n    get title(): string | undefined {\r\n        return this.wrapped.title;\r\n    }\r\n\r\n    set title(v: string | undefined) {\r\n        this.wrapped.title = v;\r\n    }\r\n\r\n    get description(): string | undefined {\r\n        return this.wrapped.description;\r\n    }\r\n\r\n    set description(v: string | undefined) {\r\n        this.wrapped.description = v;\r\n    }\r\n\r\n    get step(): number | undefined {\r\n        return this.wrapped.step;\r\n    }\r\n\r\n    set step(v: number | undefined) {\r\n        this.wrapped.step = v;\r\n    }\r\n\r\n    get enabled(): boolean {\r\n        return this.wrapped.enabled;\r\n    }\r\n\r\n    set enabled(v: boolean) {\r\n        this.wrapped.enabled = v;\r\n    }\r\n\r\n    get totalSteps(): number | undefined {\r\n        return this.wrapped.totalSteps;\r\n    }\r\n\r\n    set totalSteps(v: number | undefined) {\r\n        this.wrapped.totalSteps = v;\r\n    }\r\n\r\n    get contextKey(): string | undefined {\r\n        return this.wrapped.contextKey;\r\n    }\r\n\r\n    set contextKey(v: string | undefined) {\r\n        this.wrapped.contextKey = v;\r\n    }\r\n\r\n    get busy(): boolean {\r\n        return this.wrapped.busy;\r\n    }\r\n\r\n    set busy(v: boolean) {\r\n        this.wrapped.busy = v;\r\n    }\r\n\r\n    get ignoreFocusOut(): boolean {\r\n        return this.wrapped.ignoreFocusOut;\r\n    }\r\n\r\n    set ignoreFocusOut(v: boolean) {\r\n        this.wrapped.ignoreFocusOut = v;\r\n    }\r\n\r\n    show(): void {\r\n        this.wrapped.show();\r\n    }\r\n\r\n    hide(): void {\r\n        this.wrapped.hide();\r\n    }\r\n\r\n    dispose(): void {\r\n        this.wrapped.dispose();\r\n    }\r\n\r\n}\r\n\r\nclass MonacoQuickPick<T extends QuickPickItem> extends MonacoQuickInput implements QuickPick<T> {\r\n    readonly onDidAccept: Event<void>;\r\n    readonly onDidChangeValue: Event<string>;\r\n    readonly onDidTriggerButton: Event<QuickInputButton>;\r\n    readonly onDidTriggerItemButton: Event<QuickPickItemButtonEvent<T>>;\r\n    readonly onDidChangeActive: Event<T[]>;\r\n    readonly onDidChangeSelection: Event<T[]>;\r\n\r\n    constructor(protected readonly wrapped: monaco.quickInput.IQuickPick<MonacoQuickPickItem<T>>, protected readonly keybindingRegistry: KeybindingRegistry) {\r\n        super(wrapped);\r\n        this.onDidAccept = this.wrapped.onDidAccept;\r\n        this.onDidChangeValue = this.wrapped.onDidChangeValue;\r\n        this.onDidTriggerButton = this.wrapped.onDidTriggerButton;\r\n        this.onDidTriggerItemButton =\r\n            Event.map(this.wrapped.onDidTriggerItemButton, (evt: monaco.quickInput.IQuickPickItemButtonEvent<MonacoQuickPickItem<T>>) => ({\r\n                item: evt.item.item,\r\n                button: evt.button\r\n            }));\r\n        this.onDidChangeActive = Event.map(this.wrapped.onDidChangeActive, (items: MonacoQuickPickItem<T>[]) => items.map(item => item.item));\r\n        this.onDidChangeSelection = Event.map(this.wrapped.onDidChangeSelection, (items: MonacoQuickPickItem<T>[]) => items.map(item => item.item));\r\n\r\n    }\r\n\r\n    get value(): string {\r\n        return this.wrapped.value;\r\n    };\r\n\r\n    set value(v: string) {\r\n        this.wrapped.value = v;\r\n    }\r\n\r\n    get placeholder(): string | undefined {\r\n        return this.wrapped.placeholder;\r\n    }\r\n\r\n    set placeholder(v: string | undefined) {\r\n        this.wrapped.placeholder = v;\r\n    }\r\n\r\n    get canSelectMany(): boolean {\r\n        return this.wrapped.canSelectMany;\r\n    }\r\n\r\n    set canSelectMany(v: boolean) {\r\n        this.wrapped.canSelectMany = v;\r\n    }\r\n\r\n    get matchOnDescription(): boolean {\r\n        return this.wrapped.matchOnDescription;\r\n    }\r\n\r\n    set matchOnDescription(v: boolean) {\r\n        this.wrapped.matchOnDescription = v;\r\n    }\r\n\r\n    get matchOnDetail(): boolean {\r\n        return this.wrapped.matchOnDetail;\r\n    }\r\n\r\n    set matchOnDetail(v: boolean) {\r\n        this.wrapped.matchOnDetail = v;\r\n    }\r\n\r\n    get items(): readonly (T | QuickPickSeparator)[] {\r\n        return this.wrapped.items.map(item => QuickPickSeparator.is(item) ? item : item.item);\r\n    }\r\n\r\n    set items(itms: readonly (T | QuickPickSeparator)[]) {\r\n        this.wrapped.items = itms.map(item => QuickPickSeparator.is(item) ? item : new MonacoQuickPickItem<T>(item, this.keybindingRegistry));\r\n    }\r\n\r\n    get activeItems(): readonly (T)[] {\r\n        return this.wrapped.activeItems.map(item => item.item);\r\n    }\r\n\r\n    set activeItems(itms: readonly T[]) {\r\n        this.wrapped.activeItems = itms.map(item => new MonacoQuickPickItem<T>(item, this.keybindingRegistry));\r\n    }\r\n\r\n    get selectedItems(): readonly (T)[] {\r\n        return this.wrapped.selectedItems.map(item => item.item);\r\n    }\r\n\r\n    set selectedItems(itms: readonly T[]) {\r\n        this.wrapped.selectedItems = itms.map(item => new MonacoQuickPickItem<T>(item, this.keybindingRegistry));\r\n    }\r\n\r\n}\r\n\r\n@injectable()\r\nexport class MonacoQuickInputService implements QuickInputService {\r\n\r\n    controller: monaco.quickInput.QuickInputController;\r\n    @inject(KeybindingRegistry)\r\n    protected readonly keybindingRegistry: KeybindingRegistry;\r\n    @inject(MonacoQuickInputImplementation)\r\n    private monacoService: MonacoQuickInputImplementation;\r\n\r\n    get backButton(): monaco.quickInput.IQuickInputButton {\r\n        return this.controller.backButton;\r\n    }\r\n\r\n    get onShow(): Event<void> {\r\n        return this.monacoService.onShow;\r\n    }\r\n\r\n    get onHide(): Event<void> {\r\n        return this.monacoService.onHide;\r\n    }\r\n\r\n    open(filter: string): void {\r\n        this.monacoService.open(filter);\r\n    }\r\n\r\n    createInputBox(): InputBox {\r\n        return this.monacoService.createInputBox();\r\n    }\r\n\r\n    input(options?: InputOptions, token?: CancellationToken): Promise<string | undefined> {\r\n        let inputOptions: monaco.quickInput.IInputOptions | undefined;\r\n        if (options) {\r\n            const {validateInput, ...props} = options;\r\n            inputOptions = {...props};\r\n            if (validateInput) {\r\n                inputOptions.validateInput = async input => validateInput(input);\r\n            }\r\n        }\r\n        return this.monacoService.input(inputOptions, token);\r\n    }\r\n\r\n    pick<T extends QuickPickItem, O extends PickOptions<T>>(picks: T[] | Promise<T[]>, options?: O, token?: CancellationToken):\r\n        Promise<(O extends { canPickMany: true; } ? T[] : T) | undefined> {\r\n        return this.monacoService.pick(picks, options, token);\r\n    }\r\n\r\n    showQuickPick<T extends QuickPickItem>(items: T[], options?: QuickPickOptions<T>): Promise<T> {\r\n        return new Promise<T>((resolve, reject) => {\r\n            const quickPick = this.monacoService.createQuickPick<MonacoQuickPickItem<T>>();\r\n            const wrapped = this.wrapQuickPick(quickPick);\r\n\r\n            if (options) {\r\n                wrapped.canSelectMany = !!options.canSelectMany;\r\n                wrapped.contextKey = options.contextKey;\r\n                wrapped.description = options.description;\r\n                wrapped.enabled = options.enabled ?? true;\r\n                wrapped.ignoreFocusOut = !!options.ignoreFocusOut;\r\n                wrapped.matchOnDescription = options.matchOnDescription ?? true;\r\n                wrapped.matchOnDetail = options.matchOnDetail ?? true;\r\n                wrapped.placeholder = options.placeholder;\r\n                wrapped.step = options.step;\r\n                wrapped.title = options.title;\r\n                wrapped.totalSteps = options.totalSteps;\r\n\r\n                if (options.activeItem) {\r\n                    wrapped.activeItems = [options.activeItem];\r\n                }\r\n\r\n                wrapped.onDidAccept(() => {\r\n                    if (options?.onDidAccept) {\r\n                        options.onDidAccept();\r\n                    }\r\n                    wrapped.hide();\r\n                    resolve(wrapped.selectedItems[0]);\r\n                });\r\n\r\n                wrapped.onDidHide(() => {\r\n                    if (options.onDidHide) {\r\n                        options.onDidHide();\r\n                    }\r\n                    ;\r\n                    wrapped.dispose();\r\n                });\r\n                wrapped.onDidChangeValue((filter: string) => {\r\n                    if (options.onDidChangeValue) {\r\n                        options.onDidChangeValue(wrapped, filter);\r\n                    }\r\n                });\r\n                wrapped.onDidChangeActive((activeItems: Array<T>) => {\r\n                    if (options.onDidChangeActive) {\r\n                        options.onDidChangeActive(wrapped, activeItems);\r\n                    }\r\n                });\r\n                wrapped.onDidTriggerButton((button: monaco.quickInput.IQuickInputButton) => {\r\n                    if (options.onDidTriggerButton) {\r\n                        options.onDidTriggerButton(button);\r\n                    }\r\n                });\r\n                wrapped.onDidTriggerItemButton((evt: QuickPickItemButtonEvent<T>) => {\r\n                    if (options.onDidTriggerItemButton) {\r\n                        // https://github.com/wm-ide/vscode/blob/standalone/0.23.x/src/vs/base/parts/quickinput/browser/quickInput.ts#L1387\r\n                        options.onDidTriggerItemButton(\r\n                            {\r\n                                ...evt,\r\n                                removeItem: () => {\r\n                                    wrapped.items = wrapped.items.filter(item => item !== evt.item);\r\n                                    wrapped.activeItems = wrapped.activeItems.filter(item => item !== evt.item);\r\n                                }\r\n                            });\r\n                    }\r\n                });\r\n                wrapped.onDidChangeSelection((selectedItems: Array<T>) => {\r\n                    if (options.onDidChangeSelection) {\r\n                        options.onDidChangeSelection(wrapped, selectedItems);\r\n                    }\r\n                });\r\n            }\r\n\r\n            wrapped.items = items;\r\n            wrapped.show();\r\n        }).then(item => {\r\n            if (item?.execute) {\r\n                item.execute();\r\n            }\r\n            return item;\r\n        });\r\n    }\r\n\r\n    wrapQuickPick<T extends QuickPickItem>(wrapped: monaco.quickInput.IQuickPick<MonacoQuickPickItem<T>>): QuickPick<T> {\r\n        return new MonacoQuickPick(wrapped, this.keybindingRegistry);\r\n    }\r\n\r\n    createQuickPick<T extends QuickPickItem>(): QuickPick<T> {\r\n        const quickPick = this.monacoService.createQuickPick<MonacoQuickPickItem<T>>();\r\n        return this.wrapQuickPick(quickPick);\r\n    }\r\n\r\n    hide(): void {\r\n        return this.monacoService.hide();\r\n    }\r\n}\r\n\r\nexport class MonacoQuickPickItem<T extends QuickPickItem> implements monaco.quickInput.IQuickPickItem {\r\n    readonly type?: 'item' | 'separator';\r\n    readonly id?: string;\r\n    readonly label: string;\r\n    readonly meta?: string;\r\n    readonly ariaLabel?: string;\r\n    readonly description?: string;\r\n    readonly detail?: string;\r\n    readonly keybinding?: monaco.keybindings.ResolvedKeybinding;\r\n    readonly iconClasses?: string[];\r\n    buttons?: monaco.quickInput.IQuickInputButton[];\r\n    readonly alwaysShow?: boolean;\r\n    readonly highlights?: QuickPickItemHighlights;\r\n\r\n    constructor(readonly item: T, kbRegistry: KeybindingRegistry) {\r\n        this.type = item.type;\r\n        this.id = item.id;\r\n        this.label = item.label;\r\n        this.meta = item.meta;\r\n        this.ariaLabel = item.ariaLabel;\r\n        this.description = item.description;\r\n        this.detail = item.detail;\r\n        this.keybinding = item.keySequence ? new MonacoResolvedKeybinding(item.keySequence, kbRegistry) : undefined;\r\n        this.iconClasses = item.iconClasses;\r\n        this.buttons = item.buttons;\r\n        this.alwaysShow = item.alwaysShow;\r\n        this.highlights = item.highlights;\r\n    }\r\n\r\n    accept(): void {\r\n        if (this.item.execute) {\r\n            this.item.execute();\r\n        }\r\n    }\r\n}\r\n\r\n"]}