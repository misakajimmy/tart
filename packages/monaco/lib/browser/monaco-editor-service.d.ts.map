{"version":3,"sources":["browser/monaco-editor-service.ts"],"names":[],"mappings":"AAAA,OAAO,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC;AAC/C,OAAO,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;AACzD,OAAO,oBAAoB,GAAG,MAAM,CAAC,MAAM,CAAC,oBAAoB,CAAC;AAIjE,OAAO,EAAC,gBAAgB,EAAQ,aAAa,EAAE,iBAAiB,EAAE,cAAc,EAAC,MAAM,wBAAwB,CAAC;AAChH,OAAO,EAAC,yBAAyB,EAAC,MAAM,gCAAgC,CAAC;AAEzE,OAAO,EAAC,aAAa,EAAE,mBAAmB,EAAC,MAAM,yCAAyC,CAAC;AAE3F,OAAO,EAAC,YAAY,EAAC,MAAM,wCAAwC,CAAC;AAMpE,qBACa,mBAAoB,SAAQ,MAAM,CAAC,QAAQ,CAAC,qBAAqB;IAE5E,gBAAuB,yBAAyB,EAAE,MAAM,CAA0B;IAGlF,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAGhD,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,yBAAyB,CAAC;IAGlD,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,gBAAgB,CAAC;IAG3C,SAAS,CAAC,QAAQ,CAAC,OAAO,EAAE,aAAa,CAAC;IAG1C,SAAS,CAAC,QAAQ,CAAC,kBAAkB,EAAE,iBAAiB,CAAC;;IAMzD;;OAEG;IACH,mBAAmB,IAAI,MAAM,CAAC,MAAM,CAAC,qBAAqB,GAAG,SAAS;IAWhE,cAAc,CAAC,KAAK,EAAE,oBAAoB,EAAE,MAAM,CAAC,EAAE,WAAW,EAAE,UAAU,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC,gBAAgB,GAAG,SAAS,CAAC;cAWpH,qBAAqB,CAAC,MAAM,EAAE,MAAM,GAAG,SAAS,EAAE,WAAW,EAAE,MAAM,GAAG,OAAO,CAAC,YAAY,GAAG,SAAS,CAAC;IAkBzH,SAAS,CAAC,yBAAyB,CAAC,KAAK,EAAE,oBAAoB,EAAE,MAAM,CAAC,EAAE,WAAW,EAAE,UAAU,CAAC,EAAE,OAAO,GAAG,mBAAmB;IAQjI,SAAS,CAAC,iBAAiB,CAAC,KAAK,EAAE,oBAAoB,GAAG,cAAc;IAYxE,SAAS,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,WAAW,EAAE,UAAU,CAAC,EAAE,OAAO,GAAG,gBAAgB,CAAC,aAAa,GAAG,SAAS;CAUnH","file":"../../src/browser/monaco-editor-service.d.ts","sourcesContent":["import ICodeEditor = monaco.editor.ICodeEditor;\r\nimport CommonCodeEditor = monaco.editor.CommonCodeEditor;\r\nimport IResourceEditorInput = monaco.editor.IResourceEditorInput;\r\nimport {MonacoEditor} from './monaco-editor';\r\nimport {decorate, inject, injectable} from 'inversify';\r\nimport {MonacoEditorModel} from './monaco-editor-model';\r\nimport {ApplicationShell, open, OpenerService, PreferenceService, WidgetOpenMode} from '@tart/core/lib/browser';\r\nimport {MonacoToProtocolConverter} from './monaco-to-protocol-converter';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {EditorManager, EditorOpenerOptions} from '@tart/editor/lib/browser/editor-manager';\r\nimport {CustomEditorWidget} from '@tart/editor/lib/browser/editor';\r\nimport {EditorWidget} from '@tart/editor/lib/browser/editor-widget';\r\n\r\n\r\n\r\ndecorate(injectable(), monaco.services.CodeEditorServiceImpl);\r\n\r\n@injectable()\r\nexport class MonacoEditorService extends monaco.services.CodeEditorServiceImpl {\r\n\r\n  public static readonly ENABLE_PREVIEW_PREFERENCE: string = 'editor.enablePreview';\r\n\r\n  @inject(OpenerService)\r\n  protected readonly openerService: OpenerService;\r\n\r\n  @inject(MonacoToProtocolConverter)\r\n  protected readonly m2p: MonacoToProtocolConverter;\r\n\r\n  @inject(ApplicationShell)\r\n  protected readonly shell: ApplicationShell;\r\n\r\n  @inject(EditorManager)\r\n  protected readonly editors: EditorManager;\r\n\r\n  @inject(PreferenceService)\r\n  protected readonly preferencesService: PreferenceService;\r\n\r\n  constructor() {\r\n    super(undefined, monaco.services.StaticServices.standaloneThemeService.get());\r\n  }\r\n\r\n  /**\r\n   * Monaco active editor is either focused or last focused editor.\r\n   */\r\n  getActiveCodeEditor(): monaco.editor.IStandaloneCodeEditor | undefined {\r\n    let editor = MonacoEditor.getCurrent(this.editors);\r\n    if (!editor && CustomEditorWidget.is(this.shell.activeWidget)) {\r\n      const model = this.shell.activeWidget.modelRef.object;\r\n      if (model.editorTextModel instanceof MonacoEditorModel) {\r\n        editor = MonacoEditor.findByDocument(this.editors, model.editorTextModel)[0];\r\n      }\r\n    }\r\n    return editor && editor.getControl();\r\n  }\r\n\r\n  async openCodeEditor(input: IResourceEditorInput, source?: ICodeEditor, sideBySide?: boolean): Promise<CommonCodeEditor | undefined> {\r\n    const uri = new URI(input.resource.toString());\r\n    const openerOptions = this.createEditorOpenerOptions(input, source, sideBySide);\r\n    const widget = await open(this.openerService, uri, openerOptions);\r\n    const editorWidget = await this.findEditorWidgetByUri(widget, uri.toString());\r\n    if (editorWidget && editorWidget.editor instanceof MonacoEditor) {\r\n      return editorWidget.editor.getControl();\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  protected async findEditorWidgetByUri(widget: object | undefined, uriAsString: string): Promise<EditorWidget | undefined> {\r\n    if (widget instanceof EditorWidget) {\r\n      if (widget.editor.uri.toString() === uriAsString) {\r\n        return widget;\r\n      }\r\n      return undefined;\r\n    }\r\n    if (ApplicationShell.TrackableWidgetProvider.is(widget)) {\r\n      for (const childWidget of widget.getTrackableWidgets()) {\r\n        const editorWidget = await this.findEditorWidgetByUri(childWidget, uriAsString);\r\n        if (editorWidget) {\r\n          return editorWidget;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  protected createEditorOpenerOptions(input: IResourceEditorInput, source?: ICodeEditor, sideBySide?: boolean): EditorOpenerOptions {\r\n    const mode = this.getEditorOpenMode(input);\r\n    const selection = input.options && this.m2p.asRange(input.options.selection);\r\n    const widgetOptions = this.getWidgetOptions(source, sideBySide);\r\n    const preview = !!this.preferencesService.get<boolean>(MonacoEditorService.ENABLE_PREVIEW_PREFERENCE, false);\r\n    return {mode: mode, selection, widgetOptions, preview};\r\n  }\r\n\r\n  protected getEditorOpenMode(input: IResourceEditorInput): WidgetOpenMode {\r\n    const options = {\r\n      preserveFocus: false,\r\n      revealIfVisible: true,\r\n      ...input.options\r\n    };\r\n    if (options.preserveFocus) {\r\n      return 'reveal';\r\n    }\r\n    return options.revealIfVisible ? 'activate' : 'open';\r\n  }\r\n\r\n  protected getWidgetOptions(source?: ICodeEditor, sideBySide?: boolean): ApplicationShell.WidgetOptions | undefined {\r\n    const ref = MonacoEditor.getWidgetFor(this.editors, source);\r\n    if (!ref) {\r\n      return undefined;\r\n    }\r\n    const area = (ref && this.shell.getAreaFor(ref)) || 'main';\r\n    const mode = ref && sideBySide ? 'split-right' : undefined;\r\n    return {area, mode, ref};\r\n  }\r\n\r\n}\r\n"]}