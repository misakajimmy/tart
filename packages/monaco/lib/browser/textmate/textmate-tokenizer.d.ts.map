{"version":3,"sources":["browser/textmate/textmate-tokenizer.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;;AAElF,OAAO,EAAC,QAAQ,EAAW,YAAY,EAAC,MAAM,iBAAiB,CAAC;AAEhE,qBAAa,cAAe,YAAW,MAAM,CAAC,SAAS,CAAC,MAAM;aAGtC,SAAS,EAAE,YAAY;gBAAvB,SAAS,EAAE,YAAY;IAI3C,KAAK,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM;IAIhC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,MAAM,GAAG,OAAO;CAIlD;AAED;;GAEG;AACH,MAAM,WAAW,eAAe;IAE5B;;;;;;OAMG;IACH,SAAS,CAAC,EAAE,MAAM,CAAC;CAEtB;AAED,yBAAiB,eAAe,CAAC;IAC7B;;;;OAIG;IACI,MAAM,OAAO,EAAE,eAErB,CAAC;CACL;AAED,wBAAgB,uBAAuB,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,qBAAqB,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAkC7J","file":"../../../src/browser/textmate/textmate-tokenizer.d.ts","sourcesContent":["/********************************************************************************\r\n * Copyright (C) 2018 Ericsson and others.\r\n *\r\n * This program and the accompanying materials are made available under the\r\n * terms of the Eclipse Public License v. 2.0 which is available at\r\n * http://www.eclipse.org/legal/epl-2.0.\r\n *\r\n * This Source Code may also be made available under the following Secondary\r\n * Licenses when the conditions for such availability set forth in the Eclipse\r\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\r\n * with the GNU Classpath Exception which is available at\r\n * https://www.gnu.org/software/classpath/license.html.\r\n *\r\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\r\n ********************************************************************************/\r\n\r\nimport {IGrammar, INITIAL, StackElement} from 'vscode-textmate';\r\n\r\nexport class TokenizerState implements monaco.languages.IState {\r\n\r\n    constructor(\r\n        public readonly ruleStack: StackElement\r\n    ) {\r\n    }\r\n\r\n    clone(): monaco.languages.IState {\r\n        return new TokenizerState(this.ruleStack);\r\n    }\r\n\r\n    equals(other: monaco.languages.IState): boolean {\r\n        return other instanceof TokenizerState && (other === this || other.ruleStack === this.ruleStack);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Options for the TextMate tokenizer.\r\n */\r\nexport interface TokenizerOption {\r\n\r\n    /**\r\n     * Maximum line length that will be handled by the TextMate tokenizer. If the length of the actual line exceeds this\r\n     * limit, the tokenizer terminates and the tokenization of any subsequent lines might be broken.\r\n     *\r\n     * If the `lineLimit` is not defined, it means, there are no line length limits. Otherwise, it must be a positive\r\n     * integer or an error will be thrown.\r\n     */\r\n    lineLimit?: number;\r\n\r\n}\r\n\r\nexport namespace TokenizerOption {\r\n    /**\r\n     * The default TextMate tokenizer option.\r\n     *\r\n     * @deprecated Use the current value of `editor.maxTokenizationLineLength` preference instead.\r\n     */\r\n    export const DEFAULT: TokenizerOption = {\r\n        lineLimit: 400\r\n    };\r\n}\r\n\r\nexport function createTextmateTokenizer(grammar: IGrammar, options: TokenizerOption): monaco.languages.EncodedTokensProvider & monaco.languages.TokensProvider {\r\n    if (options.lineLimit !== undefined && (options.lineLimit <= 0 || !Number.isInteger(options.lineLimit))) {\r\n        throw new Error(`The 'lineLimit' must be a positive integer. It was ${options.lineLimit}.`);\r\n    }\r\n    return {\r\n        getInitialState: () => new TokenizerState(INITIAL),\r\n        tokenizeEncoded(line: string, state: TokenizerState): monaco.languages.IEncodedLineTokens {\r\n            let processedLine = line;\r\n            if (options.lineLimit !== undefined && line.length > options.lineLimit) {\r\n                // Line is too long to be tokenized\r\n                processedLine = line.substr(0, options.lineLimit);\r\n            }\r\n            const result = grammar.tokenizeLine2(processedLine, state.ruleStack);\r\n            return {\r\n                endState: new TokenizerState(result.ruleStack),\r\n                tokens: result.tokens\r\n            };\r\n        },\r\n        tokenize(line: string, state: TokenizerState): monaco.languages.ILineTokens {\r\n            let processedLine = line;\r\n            if (options.lineLimit !== undefined && line.length > options.lineLimit) {\r\n                // Line is too long to be tokenized\r\n                processedLine = line.substr(0, options.lineLimit);\r\n            }\r\n            const result = grammar.tokenizeLine(processedLine, state.ruleStack);\r\n            return {\r\n                endState: new TokenizerState(result.ruleStack),\r\n                tokens: result.tokens.map(t => ({\r\n                    startIndex: t.startIndex,\r\n                    scopes: t.scopes.reverse().join(' ')\r\n                }))\r\n            };\r\n        }\r\n    };\r\n}\r\n"]}