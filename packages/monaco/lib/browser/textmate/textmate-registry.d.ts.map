{"version":3,"sources":["browser/textmate/textmate-registry.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,qBAAqB,EAAC,MAAM,iBAAiB,CAAC;AAEtD,OAAO,EAAC,UAAU,EAAC,MAAM,uBAAuB,CAAC;AACjD,OAAO,EAAC,eAAe,EAAC,MAAM,sBAAsB,CAAC;AAErD,MAAM,WAAW,4BAA6B,SAAQ,qBAAqB;IAEvE;;OAEG;IACH,QAAQ,CAAC,eAAe,CAAC,EAAE,eAAe,CAAC;CAE9C;AAED,MAAM,WAAW,yBAAyB;IACtC,oBAAoB,IAAI,OAAO,CAAC,iBAAiB,CAAC,CAAC;IAEnD,aAAa,CAAC,CAAC,SAAS,EAAE,MAAM,GAAG,MAAM,EAAE,CAAC;CAC/C;AAED,MAAM,WAAW,iBAAiB;IAC9B,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC;IACzB,OAAO,EAAE,MAAM,GAAG,MAAM,CAAC;IACzB,QAAQ,CAAC,EAAE,MAAM,CAAC;CACrB;AAED,qBACa,gBAAgB;IAEzB,SAAS,CAAC,QAAQ,CAAC,eAAe,2CAAkD;IACpF,SAAS,CAAC,QAAQ,CAAC,gBAAgB,8CAAqD;IACxF,SAAS,CAAC,QAAQ,CAAC,iBAAiB,wBAA+B;IAEnE,IAAI,SAAS,IAAI,gBAAgB,CAAC,MAAM,CAAC,CAExC;IAED,4BAA4B,CAAC,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,yBAAyB,GAAG,UAAU;IAoB5F,WAAW,CAAC,KAAK,EAAE,MAAM,GAAG,yBAAyB,GAAG,SAAS;IAKjE,8BAA8B,CAAC,UAAU,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,UAAU;IAgB7E,QAAQ,CAAC,UAAU,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS;IAKhD,aAAa,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,GAAG,SAAS;IAShD,4BAA4B,CAAC,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,4BAA4B,GAAG,UAAU;IAgBlG,uBAAuB,CAAC,UAAU,EAAE,MAAM,GAAG,4BAA4B;CAK5E","file":"../../../src/browser/textmate/textmate-registry.d.ts","sourcesContent":["import {IGrammarConfiguration} from 'vscode-textmate';\r\nimport {injectable} from 'inversify';\r\nimport {Disposable} from '@tart/core/lib/common';\r\nimport {TokenizerOption} from './textmate-tokenizer';\r\n\r\nexport interface TextmateGrammarConfiguration extends IGrammarConfiguration {\r\n\r\n    /**\r\n     * Optional options to further refine the tokenization of the grammar.\r\n     */\r\n    readonly tokenizerOption?: TokenizerOption;\r\n\r\n}\r\n\r\nexport interface GrammarDefinitionProvider {\r\n    getGrammarDefinition(): Promise<GrammarDefinition>;\r\n\r\n    getInjections?(scopeName: string): string[];\r\n}\r\n\r\nexport interface GrammarDefinition {\r\n    format: 'json' | 'plist';\r\n    content: object | string;\r\n    location?: string;\r\n}\r\n\r\n@injectable()\r\nexport class TextmateRegistry {\r\n\r\n    protected readonly scopeToProvider = new Map<string, GrammarDefinitionProvider[]>();\r\n    protected readonly languageToConfig = new Map<string, TextmateGrammarConfiguration[]>();\r\n    protected readonly languageIdToScope = new Map<string, string[]>();\r\n\r\n    get languages(): IterableIterator<string> {\r\n        return this.languageIdToScope.keys();\r\n    }\r\n\r\n    registerTextmateGrammarScope(scope: string, provider: GrammarDefinitionProvider): Disposable {\r\n        const providers = this.scopeToProvider.get(scope) || [];\r\n        const existingProvider = providers[0];\r\n        if (existingProvider) {\r\n            Promise.all([existingProvider.getGrammarDefinition(), provider.getGrammarDefinition()]).then(([a, b]) => {\r\n                if (a.location !== b.location || !a.location && !b.location) {\r\n                    console.warn(`a registered grammar provider for '${scope}' scope is overridden`);\r\n                }\r\n            });\r\n        }\r\n        providers.unshift(provider);\r\n        this.scopeToProvider.set(scope, providers);\r\n        return Disposable.create(() => {\r\n            const index = providers.indexOf(provider);\r\n            if (index !== -1) {\r\n                providers.splice(index, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    getProvider(scope: string): GrammarDefinitionProvider | undefined {\r\n        const providers = this.scopeToProvider.get(scope);\r\n        return providers && providers[0];\r\n    }\r\n\r\n    mapLanguageIdToTextmateGrammar(languageId: string, scope: string): Disposable {\r\n        const scopes = this.languageIdToScope.get(languageId) || [];\r\n        const existingScope = scopes[0];\r\n        if (typeof existingScope === 'string') {\r\n            console.warn(`'${languageId}' language is remapped from '${existingScope}' to '${scope}' scope`);\r\n        }\r\n        scopes.unshift(scope);\r\n        this.languageIdToScope.set(languageId, scopes);\r\n        return Disposable.create(() => {\r\n            const index = scopes.indexOf(scope);\r\n            if (index !== -1) {\r\n                scopes.splice(index, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    getScope(languageId: string): string | undefined {\r\n        const scopes = this.languageIdToScope.get(languageId);\r\n        return scopes && scopes[0];\r\n    }\r\n\r\n    getLanguageId(scope: string): string | undefined {\r\n        for (const languageId of this.languageIdToScope.keys()) {\r\n            if (this.getScope(languageId) === scope) {\r\n                return languageId;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    registerGrammarConfiguration(languageId: string, config: TextmateGrammarConfiguration): Disposable {\r\n        const configs = this.languageToConfig.get(languageId) || [];\r\n        const existingConfig = configs[0];\r\n        if (existingConfig) {\r\n            console.warn(`a registered grammar configuration for '${languageId}' language is overridden`);\r\n        }\r\n        configs.unshift(config);\r\n        this.languageToConfig.set(languageId, configs);\r\n        return Disposable.create(() => {\r\n            const index = configs.indexOf(config);\r\n            if (index !== -1) {\r\n                configs.splice(index, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    getGrammarConfiguration(languageId: string): TextmateGrammarConfiguration {\r\n        const configs = this.languageToConfig.get(languageId);\r\n        return configs && configs[0] || {};\r\n    }\r\n\r\n}\r\n"]}