{"version":3,"sources":["browser/open-editors-widget/navigator-open-editors-tree-model.ts"],"names":[],"mappings":"AAEA,OAAO,EACL,gBAAgB,EAChB,iBAAiB,EAEjB,iBAAiB,EAEjB,MAAM,EACN,MAAM,EACP,MAAM,YAAY,CAAC;AACpB,OAAO,EAAC,YAAY,EAAE,aAAa,EAAC,MAAM,kBAAkB,CAAC;AAC7D,OAAO,EAAC,QAAQ,EAAC,MAAM,mCAAmC,CAAC;AAC3D,OAAO,EAAC,oBAAoB,EAAC,MAAM,uBAAuB,CAAC;AAE3D,MAAM,WAAW,cAAe,SAAQ,YAAY;IAClD,MAAM,EAAE,MAAM,CAAC;CAChB;AAED,qBACa,gBAAiB,SAAQ,aAAa;IACjD,MAAM,CAAC,oBAAoB,SAAgB;IAC3C,MAAM,CAAC,mBAAmB,SAAe;IAEf,SAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,gBAAgB,CAAC;IAEhF,SAAS,CAAC,gCAAgC,uBAA8B;IAExE,SAAS,CAAC,qBAAqB;iBAA8B,iBAAiB,EAAE;gBAAU,OAAO,MAAM,CAAC;OAAM;IAG9G,SAAS,CAAC,oBAAoB,kDAAyD;IAGvF,SAAS,CAAC,wBAAwB,kDAAyD;IAE3F,SAAS,CAAC,eAAe,wBAA+B;IACxD,SAAS,CAAC,iBAAiB,MAA2C;IAEtE,IAAI,aAAa,IAAI,iBAAiB,EAAE,CAIvC;IAED,iBAAiB,CAAC,EAAE,EAAE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,SAAS;IAKzD,SAAS,CAAC,IAAI,IAAI,IAAI;IAMtB,SAAS,CAAC,aAAa,IAAI,IAAI;cAsBf,cAAc,IAAI,OAAO,CAAC,IAAI,CAAC;cAK/B,mBAAmB,CAAC,kBAAkB,CAAC,EAAE,gBAAgB,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;IAyB9F,SAAS,CAAC,iCAAiC,CAAC,IAAI,EAAE,gBAAgB,CAAC,IAAI,GAAG,OAAO;IAgBjF,SAAS,CAAC,uBAAuB,IAAI,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC;cA4BnD,0BAA0B,CAAC,aAAa,EAAE,GAAG,CAAC,gBAAgB,CAAC,IAAI,EAAE,iBAAiB,EAAE,CAAC,GAAG,OAAO,CAAC,iBAAiB,CAAC;CAmEvI","file":"../../../src/browser/open-editors-widget/navigator-open-editors-tree-model.d.ts","sourcesContent":["import {inject, injectable, postConstruct} from 'inversify';\r\nimport {debounce} from 'lodash';\r\nimport {\r\n  ApplicationShell,\r\n  CompositeTreeNode,\r\n  ExpandableTreeNode,\r\n  NavigatableWidget,\r\n  SelectableTreeNode,\r\n  TabBar,\r\n  Widget\r\n} from '@tart/core';\r\nimport {FileStatNode, FileTreeModel} from '@tart/filesystem';\r\nimport {FileStat} from '@tart/filesystem/lib/common/files';\r\nimport {DisposableCollection} from '@tart/core/lib/common';\r\n\r\nexport interface OpenEditorNode extends FileStatNode {\r\n  widget: Widget;\r\n}\r\n\r\n@injectable()\r\nexport class OpenEditorsModel extends FileTreeModel {\r\n  static GROUP_NODE_ID_PREFIX = 'group-node';\r\n  static AREA_NODE_ID_PREFIX = 'area-node';\r\n\r\n  @inject(ApplicationShell) protected readonly applicationShell: ApplicationShell;\r\n\r\n  protected toDisposeOnPreviewWidgetReplaced = new DisposableCollection();\r\n  // Returns the collection of editors belonging to a tabbar group in the main area\r\n  protected _editorWidgetsByGroup = new Map<number, { widgets: NavigatableWidget[], tabbar: TabBar<Widget> }>();\r\n\r\n  // Returns the collection of editors belonging to an area grouping (main, left, right bottom)\r\n  protected _editorWidgetsByArea = new Map<ApplicationShell.Area, NavigatableWidget[]>();\r\n\r\n  // Last collection of editors before a layout modification, used to detect changes in widget ordering\r\n  protected _lastEditorWidgetsByArea = new Map<ApplicationShell.Area, NavigatableWidget[]>();\r\n\r\n  protected cachedFileStats = new Map<string, FileStat>();\r\n  protected updateOpenWidgets = debounce(this.doUpdateOpenWidgets, 250);\r\n\r\n  get editorWidgets(): NavigatableWidget[] {\r\n    const editorWidgets: NavigatableWidget[] = [];\r\n    this._editorWidgetsByArea.forEach(widgets => editorWidgets.push(...widgets));\r\n    return editorWidgets;\r\n  }\r\n\r\n  getTabBarForGroup(id: number): TabBar<Widget> | undefined {\r\n    return this._editorWidgetsByGroup.get(id)?.tabbar;\r\n  }\r\n\r\n  @postConstruct()\r\n  protected init(): void {\r\n    super.init();\r\n    this.setupHandlers();\r\n    this.initializeRoot();\r\n  }\r\n\r\n  protected setupHandlers(): void {\r\n    this.toDispose.push(this.applicationShell.onDidChangeCurrentWidget(({newValue}) => {\r\n      const nodeToSelect = this.tree.getNode(newValue?.id);\r\n      if (nodeToSelect && SelectableTreeNode.is(nodeToSelect)) {\r\n        this.selectNode(nodeToSelect);\r\n      }\r\n    }));\r\n    this.toDispose.push(this.applicationShell.onDidAddWidget(async () => {\r\n      await this.updateOpenWidgets();\r\n      const existingWidgetIds = new Set(this.editorWidgets.map(widget => widget.id));\r\n      this.cachedFileStats.forEach((_fileStat, id) => {\r\n        if (!existingWidgetIds.has(id)) {\r\n          this.cachedFileStats.delete(id);\r\n        }\r\n      });\r\n    }));\r\n    this.toDispose.push(this.applicationShell.onDidRemoveWidget(() => this.updateOpenWidgets()));\r\n    // Check for tabs rearranged in main and bottom\r\n    this.applicationShell.mainPanel.layoutModified.connect(() => this.doUpdateOpenWidgets('main'));\r\n    this.applicationShell.bottomPanel.layoutModified.connect(() => this.doUpdateOpenWidgets('bottom'));\r\n  }\r\n\r\n  protected async initializeRoot(): Promise<void> {\r\n    await this.updateOpenWidgets();\r\n    this.fireChanged();\r\n  }\r\n\r\n  protected async doUpdateOpenWidgets(layoutModifiedArea?: ApplicationShell.Area): Promise<void> {\r\n    this._lastEditorWidgetsByArea = this._editorWidgetsByArea;\r\n    this._editorWidgetsByArea = new Map<ApplicationShell.Area, NavigatableWidget[]>();\r\n    let doRebuild = true;\r\n    const areas: ApplicationShell.Area[] = ['main', 'bottom', 'left', 'right', 'top'];\r\n    areas.forEach(area => {\r\n      const editorWidgetsForArea = this.applicationShell.getWidgets(area).filter((widget): widget is NavigatableWidget => NavigatableWidget.is(widget));\r\n      if (editorWidgetsForArea.length) {\r\n        this._editorWidgetsByArea.set(area, editorWidgetsForArea);\r\n      }\r\n    });\r\n    if (this._lastEditorWidgetsByArea.size === 0) {\r\n      this._lastEditorWidgetsByArea = this._editorWidgetsByArea;\r\n    }\r\n    // `layoutModified` can be triggered when tabs are clicked, even if they are not rearranged.\r\n    // This will check for those instances and prevent a rebuild if it is unnecessary. Rebuilding\r\n    // the tree if there is no change can cause the tree's selection to flicker.\r\n    if (layoutModifiedArea) {\r\n      doRebuild = this.shouldRebuildTreeOnLayoutModified(layoutModifiedArea);\r\n    }\r\n    if (doRebuild) {\r\n      this.root = await this.buildRootFromOpenedWidgets(this._editorWidgetsByArea);\r\n    }\r\n  }\r\n\r\n  protected shouldRebuildTreeOnLayoutModified(area: ApplicationShell.Area): boolean {\r\n    const currentOrdering = this._editorWidgetsByArea.get(area);\r\n    const previousOrdering = this._lastEditorWidgetsByArea.get(area);\r\n    if (currentOrdering?.length === 1) {\r\n      return true;\r\n    }\r\n    if (currentOrdering?.length !== previousOrdering?.length) {\r\n      return true;\r\n    }\r\n    if (!!currentOrdering && !!previousOrdering) {\r\n      return !currentOrdering.every((widget, index) => widget === previousOrdering[index]);\r\n    }\r\n    return true;\r\n  }\r\n\r\n\r\n  protected tryCreateWidgetGroupMap(): Map<Widget, CompositeTreeNode> {\r\n    const mainTabBars = this.applicationShell.mainAreaTabBars;\r\n    this._editorWidgetsByGroup = new Map();\r\n    const widgetGroupMap = new Map<Widget, CompositeTreeNode>();\r\n    if (mainTabBars.length > 1) {\r\n      mainTabBars.forEach((tabbar, index) => {\r\n        const groupNumber = index + 1;\r\n        const newCaption = `GROUP ${groupNumber}`;\r\n        const groupNode = {\r\n          parent: undefined,\r\n          id: `${OpenEditorsModel.GROUP_NODE_ID_PREFIX}:${groupNumber}`,\r\n          name: newCaption,\r\n          children: []\r\n        };\r\n        const widgets: NavigatableWidget[] = [];\r\n        tabbar.titles.map(title => {\r\n          const {owner} = title;\r\n          widgetGroupMap.set(owner, groupNode);\r\n          if (NavigatableWidget.is(owner)) {\r\n            widgets.push(owner);\r\n          }\r\n        });\r\n        this._editorWidgetsByGroup.set(groupNumber, {widgets, tabbar});\r\n      });\r\n    }\r\n    return widgetGroupMap;\r\n  }\r\n\r\n  protected async buildRootFromOpenedWidgets(widgetsByArea: Map<ApplicationShell.Area, NavigatableWidget[]>): Promise<CompositeTreeNode> {\r\n    const rootNode: CompositeTreeNode = {\r\n      id: 'open-editors:root',\r\n      parent: undefined,\r\n      visible: false,\r\n      children: [],\r\n    };\r\n\r\n    const mainAreaWidgetGroups = this.tryCreateWidgetGroupMap();\r\n\r\n    for (const [area, widgetsInArea] of widgetsByArea.entries()) {\r\n      const areaNode: CompositeTreeNode & ExpandableTreeNode = {\r\n        id: `${OpenEditorsModel.AREA_NODE_ID_PREFIX}:${area}`,\r\n        parent: rootNode,\r\n        name: area,\r\n        expanded: true,\r\n        children: []\r\n      };\r\n      for (const widget of widgetsInArea) {\r\n        const uri = widget.getResourceUri();\r\n        if (uri) {\r\n          let fileStat: FileStat;\r\n          try {\r\n            fileStat = await this.fileService.resolve(uri);\r\n            this.cachedFileStats.set(widget.id, fileStat);\r\n          } catch {\r\n            const cachedStat = this.cachedFileStats.get(widget.id);\r\n            if (cachedStat) {\r\n              fileStat = cachedStat;\r\n            } else {\r\n              continue;\r\n            }\r\n          }\r\n\r\n          const openEditorNode: OpenEditorNode = {\r\n            id: widget.id,\r\n            fileStat,\r\n            uri,\r\n            selected: false,\r\n            parent: undefined,\r\n            name: widget.title.label,\r\n            icon: widget.title.iconClass,\r\n            widget\r\n          };\r\n          // only show groupings for main area widgets if more than one tabbar\r\n          if ((area === 'main') && (mainAreaWidgetGroups.size > 1)) {\r\n            const groupNode = mainAreaWidgetGroups.get(widget);\r\n            if (groupNode) {\r\n              CompositeTreeNode.addChild(groupNode, openEditorNode);\r\n              CompositeTreeNode.addChild(areaNode, groupNode);\r\n            }\r\n          } else {\r\n            CompositeTreeNode.addChild(areaNode, openEditorNode);\r\n          }\r\n        }\r\n      }\r\n      // If widgets are only in the main area and in a single tabbar, then don't show area node\r\n      if (widgetsByArea.size === 1 && widgetsByArea.has('main') && area === 'main') {\r\n        areaNode.children.forEach(child => CompositeTreeNode.addChild(rootNode, child));\r\n      } else {\r\n        CompositeTreeNode.addChild(rootNode, areaNode);\r\n      }\r\n\r\n    }\r\n    return rootNode;\r\n  }\r\n\r\n}\r\n"]}