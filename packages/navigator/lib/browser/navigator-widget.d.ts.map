{"version":3,"sources":["browser/navigator-widget.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,EAAkC,cAAc,EAAC,MAAM,kBAAkB,CAAC;AACjF,OAAO,EACL,gBAAgB,EAChB,mBAAmB,EAGnB,SAAS,EACT,aAAa,EAIb,cAAc,EACd,SAAS,EACT,QAAQ,EACR,SAAS,EACV,MAAM,YAAY,CAAC;AACpB,OAAO,EAAC,kBAAkB,EAAC,MAAM,mBAAmB,CAAC;AAGrD,OAAO,EAAC,cAAc,EAAkB,MAAM,uBAAuB,CAAC;AACtE,OAAO,EAAC,OAAO,EAAC,MAAM,mBAAmB,CAAC;AAC1C,OAAO,EAAC,0BAA0B,EAAC,MAAM,iCAAiC,CAAC;AAI3E,eAAO,MAAM,iBAAiB,UAAU,CAAC;AACzC,eAAO,MAAM,KAAK,QAA4C,CAAC;AAC/D,eAAO,MAAM,KAAK,aAAa,CAAC;AAEhC,qBACa,mBAAoB,SAAQ,cAAc;IAQ9B,QAAQ,CAAC,KAAK,EAAE,SAAS;IAChB,QAAQ,CAAC,KAAK,EAAE,kBAAkB;IACtC,SAAS,CAAC,QAAQ,CAAC,cAAc,EAAE,cAAc;IAE/C,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,gBAAgB;IATxE,SAAS,CAAC,QAAQ,CAAC,iBAAiB,EAAE,0BAA0B,CAAC;IAE1C,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;gBAGvC,KAAK,EAAE,SAAS,EACP,KAAK,EAAE,kBAAkB,EACnB,cAAc,EAAE,cAAc,EAC5C,mBAAmB,EAAE,mBAAmB,EACxB,KAAK,EAAE,gBAAgB;IASxE,SAAS,CAAC,IAAI;IAsBd,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,SAAS,GAAG,KAAK,CAAC,SAAS;IAOvD;;;OAGG;IACH,SAAS,CAAC,6BAA6B,IAAI,KAAK,CAAC,SAAS;IAc1D,SAAS,CAAC,QAAQ,CAAC,SAAS,aAA4B;IAExD,SAAS,CAAC,WAAW,IAAI,IAAI;IAI7B,SAAS,CAAC,QAAQ,CAAC,YAAY,MAAO,mBAAmB,UAIvD;IAEF,SAAS,CAAC,YAAY,IAAI,IAAI;IAmB9B,SAAS,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO;IAOpC,SAAS,CAAC,UAAU,CAAC,KAAK,EAAE,cAAc,GAAG,IAAI;IAQjD,SAAS,CAAC,WAAW,CAAC,KAAK,EAAE,cAAc,GAAG,IAAI;IAkBlD,SAAS,CAAC,oBAAoB,IAAI,IAAI;IA8BtC,SAAS,CAAC,4BAA4B,CAAC,IAAI,EAAE,YAAY,GAAG,QAAQ,EAAE;IAStE,SAAS,CAAC,qBAAqB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,GAAG,KAAK,CAAC,SAAS;IAelF,SAAS,CAAC,qCAAqC,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,eAAe,EAC7F,CAAC,cAAc,CAAC,cAAc,GAAG,cAAc,CAAC,kBAAkB,GAAG,cAAc,CAAC,uBAAuB,CAAC,EAAE,GAAG,KAAK,CAAC,SAAS;IAepI,SAAS,CAAC,yBAAyB,CAAC,KAAK,EAAE,SAAS,GAAG,OAAO;IAI9D,SAAS,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,GAAG,SAAS,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,CAAC,WAAW,CAAC,GAAG,IAAI;IASlG,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAKzC,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,OAAO,GAAG,IAAI;IAKzC,SAAS,CAAC,0BAA0B,IAAI,IAAI;CAG7C","file":"../../src/browser/navigator-widget.d.ts","sourcesContent":["import React from 'react';\r\nimport {inject, injectable, postConstruct} from 'inversify';\r\nimport {DirNode, FileNode, FileStatNode, FileTreeWidget} from '@tart/filesystem';\r\nimport {\r\n  ApplicationShell,\r\n  ContextMenuRenderer,\r\n  ExpandableTreeNode,\r\n  Key,\r\n  NodeProps,\r\n  OpenerService,\r\n  SelectableTreeNode,\r\n  TREE_NODE_SEGMENT_CLASS,\r\n  TREE_NODE_TAIL_CLASS,\r\n  TreeDecoration,\r\n  TreeModel,\r\n  TreeNode,\r\n  TreeProps\r\n} from '@tart/core';\r\nimport {FileNavigatorModel} from './navigator-model';\r\nimport {nls} from '@tart/core/lib/common/nls';\r\nimport {WorkspaceNode, WorkspaceRootNode} from './navigator-tree';\r\nimport {CommandService, isOSX, notEmpty} from '@tart/core/lib/common';\r\nimport {Message} from '@lumino/messaging';\r\nimport {NavigatorContextKeyService} from './navigator-context-key-service';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {FileNavigatorCommands} from './navigator-contribution';\r\n\r\nexport const FILE_NAVIGATOR_ID = 'files';\r\nexport const LABEL = nls.localizeByDefault('No Folder Opened');\r\nexport const CLASS = 'wm-Files';\r\n\r\n@injectable()\r\nexport class FileNavigatorWidget extends FileTreeWidget {\r\n\r\n  @inject(NavigatorContextKeyService)\r\n  protected readonly contextKeyService: NavigatorContextKeyService;\r\n\r\n  @inject(OpenerService) protected readonly openerService: OpenerService;\r\n\r\n  constructor(\r\n      @inject(TreeProps) readonly props: TreeProps,\r\n      @inject(FileNavigatorModel) readonly model: FileNavigatorModel,\r\n      @inject(CommandService) protected readonly commandService: CommandService,\r\n      @inject(ContextMenuRenderer) contextMenuRenderer: ContextMenuRenderer,\r\n      @inject(ApplicationShell) protected readonly shell: ApplicationShell,\r\n  ) {\r\n    super(props, model, contextMenuRenderer);\r\n    console.log(model);\r\n    this.id = FILE_NAVIGATOR_ID;\r\n    this.addClass(CLASS);\r\n  }\r\n\r\n  @postConstruct()\r\n  protected init() {\r\n    super.init();\r\n    // This ensures that the context menu command to hide this widget receives the label 'Folders'\r\n    // regardless of the name of workspace. See ViewContainer.updateToolbarItems.\r\n    const dataset = {...this.title.dataset, visibilityCommandLabel: nls.localizeByDefault('Folders')};\r\n    this.title.dataset = dataset;\r\n    this.updateSelectionContextKeys();\r\n    this.toDispose.pushAll([\r\n      this.model.onSelectionChanged(() =>\r\n          this.updateSelectionContextKeys()\r\n      ),\r\n      this.model.onExpansionChanged(node => {\r\n        if (node.expanded && node.children.length === 1) {\r\n          const child = node.children[0];\r\n          if (ExpandableTreeNode.is(child) && !child.expanded) {\r\n            this.model.expandNode(child);\r\n          }\r\n        }\r\n      })\r\n    ]);\r\n  }\r\n\r\n  protected renderTree(model: TreeModel): React.ReactNode {\r\n    if (this.model.root && this.isEmptyMultiRootWorkspace(model)) {\r\n      return this.renderEmptyMultiRootWorkspace();\r\n    }\r\n    return super.renderTree(model);\r\n  }\r\n\r\n  /**\r\n   * When a multi-root workspace is opened, a user can remove all the folders from it.\r\n   * Instead of displaying an empty navigator tree, this will show a button to add more folders.\r\n   */\r\n  protected renderEmptyMultiRootWorkspace(): React.ReactNode {\r\n    // TODO: @msujew Implement a markdown renderer and use vscode/explorerViewlet/noFolderHelp\r\n    return <div className='wm-navigator-container'>\r\n      <div className='center'>You have not yet added a folder to the workspace.</div>\r\n      <div className='open-workspace-button-container'>\r\n        <button className='wm-button open-workspace-button' title='Add a folder to your workspace'\r\n                onClick={this.addFolder}\r\n                onKeyUp={this.keyUpHandler}>\r\n          Add Folder\r\n        </button>\r\n      </div>\r\n    </div>;\r\n  }\r\n\r\n  protected readonly addFolder = () => this.doAddFolder();\r\n\r\n  protected doAddFolder(): void {\r\n    // this.commandService.executeCommand(WorkspaceCommands.ADD_FOLDER.id);\r\n  }\r\n\r\n  protected readonly keyUpHandler = (e: React.KeyboardEvent) => {\r\n    if (Key.ENTER.keyCode === e.keyCode) {\r\n      (e.target as HTMLElement).click();\r\n    }\r\n  };\r\n\r\n  protected doUpdateRows(): void {\r\n    super.doUpdateRows();\r\n    this.title.label = LABEL;\r\n    if (WorkspaceNode.is(this.model.root)) {\r\n      if (this.model.root.name === WorkspaceNode.name) {\r\n        const rootNode = this.model.root.children[0];\r\n        if (WorkspaceRootNode.is(rootNode)) {\r\n          this.title.label = this.toNodeName(rootNode);\r\n          this.title.caption = this.labelProvider.getLongName(rootNode.uri);\r\n        }\r\n      } else {\r\n        this.title.label = this.toNodeName(this.model.root);\r\n        this.title.caption = this.title.label;\r\n      }\r\n    } else {\r\n      this.title.caption = this.title.label;\r\n    }\r\n  }\r\n\r\n  protected onAfterAttach(msg: Message) {\r\n    super.onAfterAttach(msg);\r\n    this.addClipboardListener(this.node, 'copy', e => this.handleCopy(e));\r\n    this.addClipboardListener(this.node, 'paste', e => this.handlePaste(e));\r\n    this.enableDndOnMainPanel();\r\n  }\r\n\r\n  protected handleCopy(event: ClipboardEvent): void {\r\n    const uris = this.model.selectedFileStatNodes.map(node => node.uri.toString());\r\n    if (uris.length > 0 && event.clipboardData) {\r\n      event.clipboardData.setData('text/plain', uris.join('\\n'));\r\n      event.preventDefault();\r\n    }\r\n  }\r\n\r\n  protected handlePaste(event: ClipboardEvent): void {\r\n    if (event.clipboardData) {\r\n      const raw = event.clipboardData.getData('text/plain');\r\n      if (!raw) {\r\n        return;\r\n      }\r\n      const target = this.model.selectedFileStatNodes[0];\r\n      if (!target) {\r\n        return;\r\n      }\r\n      for (const file of raw.split('\\n')) {\r\n        event.preventDefault();\r\n        const source = new URI(file);\r\n        this.model.copy(source, target);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected enableDndOnMainPanel(): void {\r\n    const mainPanelNode = this.shell.mainPanel.node;\r\n    this.addEventListener(mainPanelNode, 'drop', async ({dataTransfer}) => {\r\n      const treeNodes = dataTransfer && this.getSelectedTreeNodesFromData(dataTransfer) || [];\r\n      if (treeNodes.length > 0) {\r\n        treeNodes.filter(FileNode.is).forEach(treeNode => {\r\n          if (!SelectableTreeNode.isSelected(treeNode)) {\r\n            this.model.toggleNode(treeNode);\r\n          }\r\n        });\r\n        this.commandService.executeCommand(FileNavigatorCommands.OPEN.id);\r\n      } else if (dataTransfer && dataTransfer.files?.length > 0) {\r\n        // the files were dragged from the outside the workspace\r\n        // Array.from(dataTransfer.files).forEach(async file => {\r\n        //     const fileUri = new URI(file.path);\r\n        //     const opener = await this.openerService.getOpener(fileUri);\r\n        //     opener.open(fileUri);\r\n        // });\r\n      }\r\n    });\r\n    const handler = (e: DragEvent) => {\r\n      if (e.dataTransfer) {\r\n        e.dataTransfer.dropEffect = 'link';\r\n        e.preventDefault();\r\n      }\r\n    };\r\n    this.addEventListener(mainPanelNode, 'dragover', handler);\r\n    this.addEventListener(mainPanelNode, 'dragenter', handler);\r\n  }\r\n\r\n  protected getSelectedTreeNodesFromData(data: DataTransfer): TreeNode[] {\r\n    const resources = data.getData('selected-tree-nodes');\r\n    if (!resources) {\r\n      return [];\r\n    }\r\n    const ids: string[] = JSON.parse(resources);\r\n    return ids.map(id => this.model.getNode(id)).filter(node => node !== undefined) as TreeNode[];\r\n  }\r\n\r\n  protected renderTailDecorations(node: TreeNode, props: NodeProps): React.ReactNode {\r\n    const tailDecorations = this.getDecorationData(node, 'tailDecorations').filter(notEmpty).reduce((acc, current) => acc.concat(current), []);\r\n\r\n    if (tailDecorations.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Handle rendering of directories versus file nodes.\r\n    if (FileStatNode.is(node) && node.fileStat.isDirectory) {\r\n      return this.renderTailDecorationsForDirectoryNode(node, props, tailDecorations);\r\n    } else {\r\n      return this.renderTailDecorationsForNode(node, props, tailDecorations);\r\n    }\r\n  }\r\n\r\n  protected renderTailDecorationsForDirectoryNode(node: TreeNode, props: NodeProps, tailDecorations:\r\n      (TreeDecoration.TailDecoration | TreeDecoration.TailDecorationIcon | TreeDecoration.TailDecorationIconClass)[]): React.ReactNode {\r\n    // If the node represents a directory, we just want to use the decorationData with the highest priority (last element).\r\n    const decoration = tailDecorations[tailDecorations.length - 1];\r\n    const {tooltip, fontData} = decoration as TreeDecoration.TailDecoration;\r\n    const color = (decoration as TreeDecoration.TailDecorationIcon).color;\r\n    const className = [TREE_NODE_SEGMENT_CLASS, TREE_NODE_TAIL_CLASS].join(' ');\r\n    const style = fontData ? this.applyFontStyles({}, fontData) : color ? {color} : undefined;\r\n    const content = <span\r\n        className={this.getIconClass('circle', [TreeDecoration.Styles.DECORATOR_SIZE_CLASS])}/>;\r\n\r\n    return <div className={className} style={style} title={tooltip}>\r\n      {content}\r\n    </div>;\r\n  }\r\n\r\n  protected isEmptyMultiRootWorkspace(model: TreeModel): boolean {\r\n    return WorkspaceNode.is(model.root) && model.root.children.length === 0;\r\n  }\r\n\r\n  protected handleClickEvent(node: TreeNode | undefined, event: React.MouseEvent<HTMLElement>): void {\r\n    const modifierKeyCombined: boolean = isOSX ? (event.shiftKey || event.metaKey) : (event.shiftKey || event.ctrlKey);\r\n    // if (!modifierKeyCombined && node && this.corePreferences['workbench.list.openMode'] === 'singleClick') {\r\n    if (!modifierKeyCombined && node) {\r\n      this.model.previewNode(node);\r\n    }\r\n    super.handleClickEvent(node, event);\r\n  }\r\n\r\n  protected onAfterShow(msg: Message): void {\r\n    super.onAfterShow(msg);\r\n    this.contextKeyService.explorerViewletVisible.set(true);\r\n  }\r\n\r\n  protected onAfterHide(msg: Message): void {\r\n    super.onAfterHide(msg);\r\n    this.contextKeyService.explorerViewletVisible.set(false);\r\n  }\r\n\r\n  protected updateSelectionContextKeys(): void {\r\n    this.contextKeyService.explorerResourceIsFolder.set(DirNode.is(this.model.selectedNodes[0]));\r\n  }\r\n}\r\n"]}