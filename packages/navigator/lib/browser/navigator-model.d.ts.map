{"version":3,"sources":["browser/navigator-model.ts"],"names":[],"mappings":"AACA,OAAO,EAAW,aAAa,EAAC,MAAM,kBAAkB,CAAC;AACzD,OAAO,GAAG,MAAM,2BAA2B,CAAC;AAC5C,OAAO,EAIL,aAAa,EAEb,QAAQ,EACT,MAAM,wBAAwB,CAAC;AAChC,OAAO,EAAC,iBAAiB,EAAE,aAAa,EAAoB,MAAM,kBAAkB,CAAC;AACrF,OAAO,EAAC,gBAAgB,EAAC,MAAM,iBAAiB,CAAC;AACjD,OAAO,EAAC,+BAA+B,EAAC,MAAM,mDAAmD,CAAC;AAElG,qBACa,kBAAmB,SAAQ,aAAa;IAE5B,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAC5C,SAAS,CAAC,QAAQ,CAAC,iBAAiB,EAAE,iBAAiB,CAAC;IACzD,SAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,gBAAgB,CAAC;IACvC,SAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,+BAA+B,CAAC;IAE5G,aAAa,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB,CAAC,QAAQ,CAAC;IAarD;;;;;OAKG;IACG,UAAU,CAAC,GAAG,EAAE,GAAG,GAAG,OAAO,CAAC,QAAQ,GAAG,SAAS,CAAC;IAuCzD,WAAW,CAAC,IAAI,EAAE,QAAQ,GAAG,IAAI;IAOjC,SAAS,CAAC,IAAI;cAKE,cAAc,IAAI,OAAO,CAAC,IAAI,CAAC;cAwB/B,UAAU,IAAI,OAAO,CAAC,IAAI,CAAC;cAI3B,UAAU,IAAI,OAAO,CAAC,QAAQ,GAAG,SAAS,CAAC;IAiB3D;;;;;OAKG;IACH,SAAS,CAAC,sBAAsB,IAAI,aAAa;IASjD,SAAS,CAAC,yBAAyB,CAAC,GAAG,EAAE,GAAG,GAAG,QAAQ,GAAG,SAAS;CAQpE","file":"../../src/browser/navigator-model.d.ts","sourcesContent":["import {inject, injectable, postConstruct} from 'inversify';\r\nimport {FileNode, FileTreeModel} from '@tart/filesystem';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {\r\n  CompositeTreeNode,\r\n  ExpandableTreeNode,\r\n  open,\r\n  OpenerService,\r\n  SelectableTreeNode,\r\n  TreeNode\r\n} from '@tart/core/lib/browser';\r\nimport {FileNavigatorTree, WorkspaceNode, WorkspaceRootNode} from './navigator-tree';\r\nimport {WorkspaceService} from '@tart/workspace';\r\nimport {FrontendApplicationStateService} from '@tart/core/lib/browser/frontend-application-state';\r\n\r\n@injectable()\r\nexport class FileNavigatorModel extends FileTreeModel {\r\n\r\n  @inject(OpenerService) protected readonly openerService: OpenerService;\r\n  @inject(FileNavigatorTree) protected readonly fileNavigatorTree: FileNavigatorTree;\r\n  @inject(WorkspaceService) protected readonly workspaceService: WorkspaceService;\r\n  @inject(FrontendApplicationStateService) protected readonly applicationState: FrontendApplicationStateService;\r\n\r\n  * getNodesByUri(uri: URI): IterableIterator<TreeNode> {\r\n    const workspace = this.root;\r\n    if (WorkspaceNode.is(workspace)) {\r\n      for (const root of workspace.children) {\r\n        // const id = this.tree.createId(root, uri);\r\n        // const node = this.getNode(id);\r\n        // if (node) {\r\n        //     yield node;\r\n        // }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reveals node in the navigator by given file uri.\r\n   *\r\n   * @param uri uri to file which should be revealed in the navigator\r\n   * @returns file tree node if the file with given uri was revealed, undefined otherwise\r\n   */\r\n  async revealFile(uri: URI): Promise<TreeNode | undefined> {\r\n    if (!uri.path.isAbsolute) {\r\n      return undefined;\r\n    }\r\n    let node = this.getNodeClosestToRootByUri(uri);\r\n\r\n    // success stop condition\r\n    // we have to reach workspace root because expanded node could be inside collapsed one\r\n    if (WorkspaceRootNode.is(node)) {\r\n      if (ExpandableTreeNode.is(node)) {\r\n        if (!node.expanded) {\r\n          node = await this.expandNode(node);\r\n        }\r\n        return node;\r\n      }\r\n      // shouldn't happen, root node is always directory, i.e. expandable\r\n      return undefined;\r\n    }\r\n\r\n    // fail stop condition\r\n    if (uri.path.isRoot) {\r\n      // file system root is reached but workspace root wasn't found, it means that\r\n      // given uri is not in workspace root folder or points to not existing file.\r\n      return undefined;\r\n    }\r\n\r\n    if (await this.revealFile(uri.parent)) {\r\n      if (node === undefined) {\r\n        // get node if it wasn't mounted into navigator tree before expansion\r\n        node = this.getNodeClosestToRootByUri(uri);\r\n      }\r\n      if (ExpandableTreeNode.is(node) && !node.expanded) {\r\n        node = await this.expandNode(node);\r\n      }\r\n      return node;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  previewNode(node: TreeNode): void {\r\n    if (FileNode.is(node)) {\r\n      open(this.openerService, node.uri, {mode: 'reveal', preview: true});\r\n    }\r\n  }\r\n\r\n  @postConstruct()\r\n  protected init() {\r\n    super.init();\r\n    this.initializeRoot();\r\n  }\r\n\r\n  protected async initializeRoot(): Promise<void> {\r\n    await Promise.all([\r\n      this.applicationState.reachedState('initialized_layout'),\r\n      this.workspaceService.roots\r\n    ]);\r\n    await this.updateRoot();\r\n    if (this.toDispose.disposed) {\r\n      return;\r\n    }\r\n    this.toDispose.push(this.workspaceService.onWorkspaceChanged(() => this.updateRoot()));\r\n    this.toDispose.push(this.workspaceService.onWorkspaceLocationChanged(() => this.updateRoot()));\r\n    if (this.selectedNodes.length) {\r\n      return;\r\n    }\r\n    const root = this.root;\r\n    if (CompositeTreeNode.is(root) && root.children.length === 1) {\r\n      const child = root.children[0];\r\n      if (SelectableTreeNode.is(child) && !child.selected && ExpandableTreeNode.is(child)) {\r\n        this.selectNode(child);\r\n        this.expandNode(child);\r\n      }\r\n    }\r\n  }\r\n\r\n  protected async updateRoot(): Promise<void> {\r\n    this.root = await this.createRoot();\r\n  }\r\n\r\n  protected async createRoot(): Promise<TreeNode | undefined> {\r\n    if (this.workspaceService.opened) {\r\n      const stat = this.workspaceService.workspace;\r\n      const isMulti = (stat) ? !stat.isDirectory : false;\r\n      const workspaceNode = isMulti\r\n          ? this.createMultipleRootNode()\r\n          : WorkspaceNode.createRoot();\r\n      const roots = await this.workspaceService.roots;\r\n      for (const root of roots) {\r\n        workspaceNode.children.push(\r\n            await this.fileNavigatorTree.createWorkspaceRoot(root, workspaceNode)\r\n        );\r\n      }\r\n      return workspaceNode;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create multiple root node used to display\r\n   * the multiple root workspace name.\r\n   *\r\n   * @returns `WorkspaceNode`\r\n   */\r\n  protected createMultipleRootNode(): WorkspaceNode {\r\n    const workspace = this.workspaceService.workspace;\r\n    let name = workspace\r\n        ? workspace.resource.path.name\r\n        : 'untitled';\r\n    name += ' (Workspace)';\r\n    return WorkspaceNode.createRoot(name);\r\n  }\r\n\r\n  protected getNodeClosestToRootByUri(uri: URI): TreeNode | undefined {\r\n    const nodes = [...this.getNodesByUri(uri)];\r\n    return nodes.length > 0\r\n        ? nodes.reduce((node1, node2) => // return the node closest to the workspace root\r\n            node1.id.length >= node2.id.length ? node1 : node2\r\n        ) : undefined;\r\n  }\r\n\r\n}\r\n"]}