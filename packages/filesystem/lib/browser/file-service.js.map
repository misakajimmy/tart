{"version":3,"sources":["browser/file-service.ts"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,aAAa,EAAC,MAAM,WAAW,CAAC;AACnE,OAAO,EACH,YAAY,EACZ,iBAAiB,EACjB,uBAAuB,EACvB,oBAAoB,EACpB,UAAU,EACV,oBAAoB,EACpB,OAAO,EAGP,cAAc,EACjB,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EAIH,6BAA6B,EAC7B,IAAI,EACJ,aAAa,EACb,gBAAgB,EAIhB,kBAAkB,EAClB,kBAAkB,EAGlB,QAAQ,EAKR,2BAA2B,EAI3B,QAAQ,EACR,2BAA2B,EAC3B,2BAA2B,EAC3B,+BAA+B,EAC/B,sBAAsB,EACtB,mBAAmB,EAMnB,qBAAqB,EACrB,6BAA6B,EAGhC,MAAM,iBAAiB,CAAC;AAEzB,OAAO,EAAC,QAAQ,EAAC,MAAM,oCAAoC,CAAC;AAC5D,OAAO,EAAC,iBAAiB,EAAC,MAAM,2CAA2C,CAAC;AAE5E,OAAO,EAAC,aAAa,EAAC,MAAM,YAAY,CAAC;AACzC,OAAO,EAAC,gBAAgB,EAAC,MAAM,0CAA0C,CAAC;AAC1E,OAAO,EACH,aAAa,EACb,wBAAwB,EACxB,gBAAgB,EAChB,YAAY,EACZ,UAAU,EAGV,SAAS,EACZ,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAqB,eAAe,EAAmB,MAAM,wCAAwC,CAAC;AAC7G,OAAO,EAAC,IAAI,EAAE,aAAa,EAAC,MAAM,iCAAiC,CAAC;AACpE,OAAO,EAAC,qBAAqB,EAAC,MAAM,0BAA0B,CAAC;AAC/D,OAAO,EACH,YAAY,EACZ,oBAAoB,EACpB,kCAAkC,EAClC,0BAA0B,EAC1B,2BAA2B,EAC9B,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAC,kBAAkB,EAAC,MAAM,cAAc,CAAC;AAChD,OAAO,EAAC,eAAe,EAAC,MAAM,8BAA8B,CAAC;AAE7D,MAAM,CAAC,MAAM,uBAAuB,GAAG,MAAM,CAAC,yBAAyB,CAAC,CAAC;AA0KzE,MAAM,OAAO,sBAAuB,SAAQ,kBAAkB;IAE1D,YACI,OAAe,EACR,uBAAgD,EAChD,OAAoD;QAE3D,KAAK,CAAC,OAAO,gDAAuC,CAAC;QAH9C,4BAAuB,GAAvB,uBAAuB,CAAyB;QAChD,YAAO,GAAP,OAAO,CAA6C;QAG3D,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,sBAAsB,CAAC,SAAS,CAAC,CAAC;IAClE,CAAC;CAEJ;AAED;;;;;GAKG;AAEH,IAAa,WAAW,GAAxB,MAAa,WAAW;IAAxB;QAYqB,gBAAW,GAAG,EAAE,GAAG,IAAI,CAAC;QACjC,4CAAuC,GAAG,IAAI,OAAO,EAAqC,CAAC;QACnG;;WAEG;QACM,qCAAgC,GAAG,IAAI,CAAC,uCAAuC,CAAC,KAAK,CAAC;QACvF,sDAAiD,GAAG,IAAI,OAAO,EAAuC,CAAC;QAC9F,cAAS,GAAG,IAAI,GAAG,EAA8B,CAAC;QAClD,gBAAW,GAAG,IAAI,GAAG,EAAuC,CAAC;QACtE,mBAAc,GAAG,CAAC,CAAC;QAE3B,iBAAiB;QACA,kCAA6B,GAAG,IAAI,YAAY,EAA0B,CAAC;QAC5F;;;WAGG;QACM,2BAAsB,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC;QAC1D,kCAA6B,GAAG,IAAI,YAAY,EAA0B,CAAC;QAC5F;;;WAGG;QACM,2BAAsB,GAAG,IAAI,CAAC,6BAA6B,CAAC,KAAK,CAAC;QAC1D,iCAA4B,GAAG,IAAI,YAAY,EAA0B,CAAC;QAC3F;;;WAGG;QACM,0BAAqB,GAAG,IAAI,CAAC,4BAA4B,CAAC,KAAK,CAAC;QACjE,6BAAwB,GAAG,IAAI,OAAO,EAAsB,CAAC;QACrE;;;WAGG;QACM,sBAAiB,GAAG,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC;QACzD,gBAAW,GAA+B,IAAI,GAAG,EAAE,CAAC;QACpD,4BAAuB,GAAG,IAAI,OAAO,EAAoB,CAAC;QAC1D,mBAAc,GAAG,IAAI,GAAG,EAAqD,CAAC;QAC9E,qDAAgD,GAAG,IAAI,OAAO,EAA6C,CAAC;QAC3G,8CAAyC,GAAG,IAAI,CAAC,gDAAgD,CAAC,KAAK,CAAC;QA4zCjH;;;;;WAKG;QACH,4DAA4D;QAC5D,wDAAwD;QACxD,iEAAiE;QACjE,8DAA8D;QAC9D,wDAAwD;QACxD,QAAQ;QACR,uBAAuB;QACvB,IAAI;QAEJ,2CAA2C;QAC3C,8CAA8C;QAC9C,IAAI;IACR,CAAC;IA50CG;;OAEG;IACH,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC;IAC9C,CAAC;IAaD,KAAK,CAAC,OAAO,CAAC,QAAa,EAAE,OAAa;QACtC,IAAI;YACA,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SACtD;QAAC,OAAO,KAAK,EAAE;YAEZ,gEAAgE;YAChE,IAAI,6BAA6B,CAAC,KAAK,CAAC,KAAK,2BAA2B,CAAC,YAAY,EAAE;gBACnF,MAAM,IAAI,kBAAkB,CAAC,wCAAwC,6CAAqC,CAAC;aAC9G;YAED,kCAAkC;YAClC,MAAM,6BAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;IACL,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,QAAa,EAAE,KAAgC,EAAE,OAA8B;QACvF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzE,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE,EAAC,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAC,CAAC,CAAC;IAC1G,CAAC;IAED,KAAK,CAAC,4BAA4B,CAAC,MAAW,EAAE,MAAuB,EAAE,SAAwB;QAC7F,MAAM,mBAAmB,GAAG,IAAI,CAAC,WAAW,CAAC,4BAA4B,CAAC,CAAC;QAC3E,IAAI,mBAAmB,IAAI,CAAC,EAAE;YAC1B,OAAO;SACV;QAED,MAAM,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAE9D,kGAAkG;QAClG,qDAAqD;QACrD,uEAAuE;QACvE,qBAAqB;QACrB,YAAY;QACZ,EAAE;QACF,gBAAgB;QAChB,sIAAsI;QACtI,mCAAmC;QACnC,2BAA2B;QAC3B,gKAAgK;QAChK,kBAAkB;QAClB,0BAA0B;QAC1B,iCAAiC;QACjC,YAAY;QACZ,QAAQ;QACR,MAAM;IACV,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,MAAW,EAAE,MAAW,EAAE,OAAyB;QAC1D,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;SACzD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,MAAM,EAAE,MAAM,6BAAqB,CAAC;QAE5E,MAAM,KAAK,GAAG,EAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,4BAAoB,EAAE,MAAM,EAAE,MAAM,EAAC,CAAC;QACpG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC,CAAC;SAChE;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAA2D;QACnF,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC3C;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,EAAE,SAAS,+BAAuB,CAAC;QAEnF,MAAM,KAAK,GAAG,EAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,8BAAsB,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC;QACxG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI;YACA,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC1C;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACxD,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,MAAW,EAAE,MAAW,EAAE,OAAyB;QAC1D,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;SACzD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,MAAM,EAAE,MAAM,6BAAqB,CAAC;QAE5E,MAAM,KAAK,GAAG,EAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,4BAAoB,EAAE,MAAM,EAAE,MAAM,EAAC,CAAC;QACpG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC,CAAC;SAChE;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,QAAa,EAAE,UAAgC,EAAE;QAChE,MAAM,EACF,eAAe,GAAG,IAAI,GACzB,GAAG,OAAO,CAAC;QAEZ,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAE/F,oBAAoB;QACpB,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAEtC,SAAS;QACT,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAC;QAEvE,IAAI,eAAe,EAAE;YACjB,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC;gBACnC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE;gBACpC,SAAS,8BAAsB;gBAC/B,MAAM,EAAE,QAAQ;aACnB,CAAC,CAAC;SACN;aAAM;YACH,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,QAAQ,gCAAwB,QAAQ,CAAC,CAAC,CAAC;SACxG;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,SAAS,CAAC,QAAa,EAAE,wBAA0F,EAAE,OAA0B;QACjJ,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAEpG,IAAI;YAEA,iBAAiB;YACjB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAEvE,8BAA8B;YAC9B,IAAI,CAAC,IAAI,EAAE;gBACP,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;aAChD;YAED,6EAA6E;YAC7E,8EAA8E;YAC9E,8EAA8E;YAC9E,iCAAiC;YACjC,IAAI,wCAA+I,CAAC;YACpJ,IAAI,sBAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,wBAAwB,YAAY,YAAY,CAAC,EAAE;gBACzF,IAAI,gBAAgB,CAAC,wBAAwB,CAAC,EAAE;oBAC5C,MAAM,cAAc,GAAG,MAAM,UAAU,CAAC,wBAAwB,EAAE,CAAC,CAAC,CAAC;oBACrE,IAAI,cAAc,CAAC,KAAK,EAAE;wBACtB,wCAAwC,GAAG,YAAY,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;qBACzF;yBAAM;wBACH,wCAAwC,GAAG,cAAc,CAAC;qBAC7D;iBACJ;qBAAM;oBACH,wCAAwC,GAAG,YAAY,CAAC,wBAAwB,EAAE,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;iBAC3H;aACJ;iBAAM;gBACH,wCAAwC,GAAG,wBAAwB,CAAC;aACvE;YAED,+GAA+G;YAC/G,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,IAAI,wCAAwC,YAAY,YAAY,CAAC,EAAE;gBACtJ,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,CAAC,CAAC;aAC9F;YAED,uBAAuB;iBAClB;gBACD,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,YAAY,YAAY,CAAC,CAAC,CAAC,oBAAoB,CAAC,UAAU,CAAC,wCAAwC,CAAC,CAAC,CAAC,CAAC,wCAAwC,CAAC,CAAC;aAC3O;SACJ;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,sBAAsB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACtF;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAC;IAC3D,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,MAAM,CAAC,QAAa;QACtB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI;YACA,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAE3C,OAAO,CAAC,CAAC,IAAI,CAAC;SACjB;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,KAAiC,EAAE,OAA+B;QAC1F,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,MAAK,KAAK,EAAE;YACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SAClD;QACD,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,EAAE,SAAS,+BAAuB,CAAC;QAEnF,MAAM,KAAK,GAAG,EAAC,aAAa,EAAE,IAAI,CAAC,cAAc,EAAE,EAAE,SAAS,8BAAsB,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC;QACxG,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAErD,IAAI,IAA0B,CAAC;QAC/B,IAAI;YACA,IAAI,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACxD;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,IAAI,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACrD,MAAM,KAAK,CAAC;SACf;QAED,MAAM,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEpD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,UAAU,CAAC,QAAa,EAAE,2BAA6F,YAAY,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE,OAA2B;QAEjL,qBAAqB;QACrB,IAAI,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAA,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE;YACpD,MAAM,IAAI,kBAAkB,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,sDAAsD,mDAA2C,OAAO,CAAC,CAAC;SACnM;QAED,+CAA+C;QAC/C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,wBAAwB,CAAC,CAAC;QAE1E,SAAS;QACT,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,QAAQ,gCAAwB,QAAQ,CAAC,CAAC,CAAC;QAErG,OAAO,QAAQ,CAAC;IACpB,CAAC;IAED,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAAyC,EAAE,OAA8B;QACjG,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QACpG,IAAI;YACA,MAAM,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YAC1D,IAAI,mBAAmB,CAAC,QAAQ,CAAC,EAAE;gBAC/B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;gBACrG,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE;oBACtD,YAAY,EAAE,OAAO,CAAC,YAAY;oBAClC,aAAa,EAAE,QAAQ;oBACvB,iBAAiB,EAAE,OAAO,CAAC,iBAAiB,IAAI,KAAK;iBACxD,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE,EAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAC,CAAC,CAAC;aACtF;iBAAM;gBACH,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;aAC/D;SACJ;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,sBAAsB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACtF;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,gBAAgB,CAAC,MAAc;QACjC,IAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC1C,IAAI,QAAQ,EAAE;YACV,OAAO,QAAQ,CAAC;SACnB;QACD,IAAI,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC9C,IAAI,CAAC,UAAU,EAAE;YACb,MAAM,kBAAkB,GAAG,IAAI,QAAQ,EAAsB,CAAC;YAC9D,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC;YACtE,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,uCAAuC,EAAE,EAAC,MAAM,EAAC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE;gBAClF,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBACtC,IAAI,CAAC,QAAQ,EAAE;oBACX,MAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC;oBAC1B,KAAK,CAAC,IAAI,GAAG,QAAQ,CAAC;oBACtB,KAAK,CAAC,OAAO,GAAG,4CAA4C,MAAM,EAAE,CAAC;oBACrE,MAAM,KAAK,CAAC;iBACf;qBAAM;oBACH,kBAAkB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;iBACxC;YACL,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SAC/C;QACD,OAAO,UAAU,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACH,aAAa,CAAC,QAAa,EAAE,UAA0C;QACnE,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAErD,OAAO,CAAC,CAAC,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,YAAY,GAAG,UAAU,CAAC,CAAC,CAAC;IAChE,CAAC;IAED,KAAK,CAAC,QAAa,EAAE,UAAwB,EAAC,SAAS,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAC;QACzE,MAAM,eAAe,mCACd,OAAO;YACV,uCAAuC;YACvC,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,MAAM,CAAC,kBAAkB,CAAC,GACxD,CAAC;QAEF,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,IAAI,eAAe,GAAG,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,CAAC;QAEpE,kDAAkD;QAClD,kDAAkD;QAClD,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACtD,IAAI,aAAa,EAAE;gBACf,UAAU,CAAC,OAAO,EAAE,CAAC;aACxB;iBAAM;gBACH,eAAe,GAAG,UAAU,CAAC;aAChC;QACL,CAAC,EAAE,KAAK,CAAC,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QAElC,OAAO,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC,CAAC;IAC9D,CAAC;IAED,KAAK,CAAC,OAAO,CAAC,QAAa,EAAE,OAAqB;QAC9C,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACnD,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAEzD,4DAA4D;QAC5D,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAC,KAAK,EAAE,CAAC,EAAE,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC,QAAQ,EAAE,OAAO,CAAC,EAAC,CAAC;QAC1G,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YAC/B,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;SACzC;QAED,0BAA0B;QAC1B,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC;QAEnB,OAAO,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE;YAE1B,QAAQ;YACR,OAAO,CAAC,KAAK,EAAE,CAAC;YAEhB,yCAAyC;YACzC,IAAI,OAAO,CAAC,KAAK,KAAK,CAAC,EAAE;gBACrB,OAAO,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;gBAC7B,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;aACnC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;OAMG;IACH,gBAAgB,CAAC,MAAc,EAAE,QAA4B;QACzD,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;YAC5B,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,yCAAyC,MAAM,0BAA0B,CAAC,CAAC;SAC9F;QAED,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;QACrC,IAAI,CAAC,iDAAiD,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC,CAAC;QAE7F,MAAM,mBAAmB,GAAG,IAAI,oBAAoB,EAAE,CAAC;QACvD,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;QAChI,0FAA0F;QAC1F,mBAAmB,CAAC,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,gDAAgD,CAAC,IAAI,CAAC;YACvH,QAAQ;YACR,MAAM;SACT,CAAC,CAAC,CAAC,CAAC;QAEL,OAAO,UAAU,CAAC,MAAM,CAAC,GAAG,EAAE;YAC1B,IAAI,CAAC,iDAAiD,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC,CAAC;YAC9F,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAE9B,mBAAmB,CAAC,OAAO,EAAE,CAAC;QAClC,CAAC,CAAC,CAAC;IACP,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,QAAa,EAAE,OAA6B;QACnD,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,kCACnD,OAAO;YACV,uDAAuD;YACvD,wDAAwD;YACxD,qDAAqD;YACrD,mDAAmD;YACnD,sBAAsB;YACtB,gBAAgB,EAAE,IAAI,IACxB,CAAC;QAEH,uCACO,YAAY,KACf,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,EAC3C,KAAK,EAAE,MAAM,aAAa,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IACzE;IACN,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,QAAa,EAAE,OAAyB;QACzD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAEvD,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;IAChE,CAAC;IAED,KAAK,CAAC,UAAU,CAAC,QAAa,EAAE,OAA6B;QACzD,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAErE,uCACO,YAAY,KACf,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,EAC3C,KAAK,EAAE,OAAO,CAAC,MAAM,IACvB;IACN,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,OAAyB;QACnD,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAEvD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,kCACxD,OAAO;YACV,uDAAuD;YACvD,wDAAwD;YACxD,qDAAqD;YACrD,mDAAmD;YACnD,sBAAsB;YACtB,gBAAgB,EAAE,IAAI,IACxB,CAAC;QACH,uCACO,MAAM,KACT,KAAK,EAAE,MAAM,0BAA0B,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,IAChE;IACN,CAAC;IAGS,IAAI;QACV,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,EAAE;YAC9D,YAAY,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;SAClD;IACL,CAAC;IAED;;;;;;;;;;;;;OAaG;IACO,aAAa,CAAC,IAAU,EAAE,OAA0B;QAC1D,OAAO,CAAC,CAAC,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,aAAa;YACvH,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ;YAC/D,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC;YAChD,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,kDAAkD;YACvE,IAAI,EAAE,IAAI,CAAC,IAAI;SAClB,CAAC,CAAC;IACX,CAAC;IAES,KAAK,CAAC,gBAAgB,CAAC,QAAa,EAAE,OAA8B;QAC1E,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QACrG,OAAO,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,QAAQ,EAAE;YACrD,iBAAiB,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB;YAC7C,IAAI,EAAE,KAAK,EAAC,MAAM,EAAC,EAAE;gBACjB,MAAM,MAAM,GAAG,MAAM,0BAA0B,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,EAAC,MAAM,EAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;gBAChH,OAAO,MAAM,CAAC,MAAM,CAAC;YACzB,CAAC;SACJ,CAAC,CAAC;IACP,CAAC;IAES,KAAK,CAAC,MAAM,CAAC,MAAW,EAAE,MAAW,EAAE,SAAmB;QAChE,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAC3D,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QAEtG,OAAO;QACP,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;QAExG,0BAA0B;QAC1B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAC;QACrE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,MAAM,EAAE,IAAI,KAAK,MAAM,CAAC,CAAC,4BAAoB,CAAC,2BAAmB,EAAE,QAAQ,CAAC,CAAC,CAAC;QAExI,OAAO,QAAQ,CAAC;IACpB,CAAC;IAES,KAAK,CAAC,MAAM,CAAC,MAAW,EAAE,MAAW,EAAE,SAAmB;QAChE,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QACtG,MAAM,cAAc,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC;QAEtG,OAAO;QACP,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;QAExG,0BAA0B;QAC1B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAC;QACrE,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,MAAM,EAAE,IAAI,KAAK,MAAM,CAAC,CAAC,4BAAoB,CAAC,2BAAmB,EAAE,QAAQ,CAAC,CAAC,CAAC;QAExI,OAAO,QAAQ,CAAC;IACpB,CAAC;IAES,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,OAAoC;QACxE,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE,QAAQ,CAAC,CAAC;QAE/F,yBAAyB;QACzB,MAAM,QAAQ,GAAG,CAAC,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAA,CAAC;QACrC,IAAI,QAAQ,IAAI,CAAC,CAAC,QAAQ,CAAC,YAAY,kDAAuC,CAAC,EAAE;YAC7E,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,mDAAmD,CAAC,CAAC;SACjI;QAED,kBAAkB;QAClB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,IAAI,kBAAkB,CAAC,uCAAuC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,GAAG,6CAAqC,CAAC;SAC/I;QAED,qBAAqB;QACrB,MAAM,SAAS,GAAG,CAAC,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAA,CAAC;QACvC,IAAI,CAAC,SAAS,IAAI,MAAM,EAAE;YACtB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YAC1C,IAAI,IAAI,CAAC,WAAW,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC9E,MAAM,IAAI,KAAK,CAAC,sCAAsC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;aAC9F;SACJ;QAED,0BAA0B;QAC1B,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAC,SAAS,EAAE,QAAQ,EAAC,CAAC,CAAC;QAEvD,SAAS;QACT,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,QAAQ,+BAAuB,CAAC,CAAC;IAC/F,CAAC;IAES,KAAK,CAAC,QAAQ,CAAC,QAAa,EAAE,KAAiC,EAAE,OAA+B;QACtG,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAChE,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzE,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAES,2BAA2B,CAAC,OAAe,EAAE,QAAa,EAAE,KAAY,EAAE,OAAgE;QAChJ,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACvE,CAAC;IAES,oBAAoB,CAAC,OAAe,EAAE,QAAa,EAAE,KAAY,EAAE,OAAgE;QACzI,MAAM,kBAAkB,GAAG,IAAI,kBAAkB,CAAC,GAAG,OAAO,KAAK,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAM,6BAA6B,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,GAAG,EACpJ,qBAAqB,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;QAC3C,kBAAkB,CAAC,KAAK,GAAG,GAAG,kBAAkB,CAAC,KAAK,gBAAgB,KAAK,CAAC,KAAK,EAAE,CAAC;QACpF,OAAO,kBAAkB,CAAC;IAC9B,CAAC;IAES,2BAA2B,CAA+B,QAAW,EAAE,QAAa;QAC1F,IAAI,QAAQ,CAAC,YAAY,qDAA0C,EAAE;YACjE,MAAM,IAAI,kBAAkB,CAAC,gCAAgC,qDAA6C,CAAC;SAC9G;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAES,KAAK,CAAC,YAAY,CAAC,QAAa;QACtC,0BAA0B;QAC1B,mCAAmC;QACnC,4IAA4I;QAC5I,IAAI;QAEJ,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAClD,CAAC;IAES,KAAK,CAAC,sBAAsB,CAAC,QAAa,EAAE,iBAA0B;QAC5E,wDAAwD;QACxD,OAAO,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;IACrF,CAAC;IAES,eAAe,CAAC,QAAa,EAAE,OAA6B,EAAE,gBAAyB;QAC7F,IAAI,iBAAqC,CAAC;QAE1C,+BAA+B;QAC/B,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,EAAE;YACnB,IAAI,gBAAgB,KAAK,aAAa,IAAI,OAAO,CAAC,QAAQ,KAAK,IAAI,EAAE;gBACjE,iBAAiB,GAAG,aAAa,CAAC,CAAC,4DAA4D;aAClG;iBAAM;gBACH,iBAAiB,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC,2CAA2C;aACpF;SACJ;aAAM,IAAI,gBAAgB,EAAE;YACzB,iBAAiB,GAAG,gBAAgB,CAAC;SACxC;QAED,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;IACpE,CAAC;IAES,kBAAkB,CAAC,OAA6B;QACtD,OAAO,mCACA,OAAO,KACV,iBAAiB,EAAE,OAAO,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB,CAAA,KAAK,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,yBAAyB,CAAC,GAC/I,CAAC;QACF,MAAM,MAAM,GAA2C,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC;QAC7F,IAAI,OAAO,MAAM,CAAC,IAAI,KAAK,QAAQ,EAAE;YACjC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,qBAAqB,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;SACvE;QACD,OAAO,OAAO,CAAC;IACnB,CAAC;IAEO,gBAAgB,CAAC,QAAa;QAClC,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IACpD,CAAC;IAMO,KAAK,CAAC,aAAa,CAAC,QAAa,EAAE,OAA4B;QACnE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,MAAM,SAAS,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,CAAC;QACrC,MAAM,6BAA6B,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,6BAA6B,CAAC;QAC7E,MAAM,eAAe,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,CAAC;QAEjD,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAE3C,IAAI,IAAiD,CAAC;QAEtD,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC,CAAC,eAAe,EAAE,CAAC,IAAI,EAAE,QAAQ,EAAE,EAAE;YAE9F,6CAA6C;YAC7C,IAAI,CAAC,IAAI,EAAE;gBACP,IAAI,GAAG,iBAAiB,CAAC,OAAO,CAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,8DAAmD,CAAC,CAAC,CAAC;gBACrH,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACzB,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,MAAM,EAAE;oBAC9C,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,IAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;iBAClD;aACJ;YAED,gCAAgC;YAChC,IAAI,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;gBACtE,OAAO,IAAI,CAAC;aACf;YAED,2CAA2C;YAC3C,IAAI,IAAI,CAAC,WAAW,IAAI,6BAA6B,EAAE;gBACnD,OAAO,QAAQ,KAAK,CAAC,CAAC;aACzB;YAED,OAAO,KAAK,CAAC;QACjB,CAAC,CAAC,CAAC;IACP,CAAC;IAMO,KAAK,CAAC,UAAU,CAAC,QAA4B,EAAE,QAAa,EAAE,IAA+C,EAAE,QAA4B,EAAE,eAAwB,EAAE,OAAuD;QAClO,MAAM,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QAEnD,mCAAmC;QACnC,IAAI,QAAQ,CAAC,WAAW,IAAI,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;YACrD,IAAI;gBACA,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;gBACjD,MAAM,eAAe,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,EAAE;oBACzE,IAAI;wBACA,MAAM,aAAa,GAAG,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;wBAC7C,MAAM,SAAS,GAAG,eAAe,CAAC,CAAC,CAAC,MAAM,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAC,IAAI,EAAC,CAAC;wBAEhF,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,aAAa,EAAE,SAAS,EAAE,OAAO,CAAC,MAAM,EAAE,eAAe,EAAE,OAAO,CAAC,CAAC;qBAC9G;oBAAC,OAAO,KAAK,EAAE;wBACZ,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;wBAErB,OAAO,IAAI,CAAC,CAAC,2CAA2C;qBAC3D;gBACL,CAAC,CAAC,CAAC,CAAC;gBAEJ,0FAA0F;gBAC1F,QAAQ,CAAC,QAAQ,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAe,CAAC;aACtE;YAAC,OAAO,KAAK,EAAE;gBACZ,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBAErB,QAAQ,CAAC,QAAQ,GAAG,EAAE,CAAC,CAAC,gEAAgE;aAC3F;YAED,OAAO,QAAQ,CAAC;SACnB;QAED,OAAO,QAAQ,CAAC;IACpB,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAA4B,EAAE,QAAa,EAAE,OAA0B;QACnG,IAAI,IAAI,GAAqB,SAAS,CAAC;QACvC,IAAI;YACA,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SACxC;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,SAAS,CAAC,CAAC,uBAAuB;SAC5C;QAED,IAAI,IAAI,KAAK,SAAS,EAAE;YACpB,OAAO,SAAS,CAAC;SACpB;QAED,2BAA2B;QAC3B,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;YACxC,MAAM,IAAI,kBAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,+BAA+B,iDAAyC,OAAO,CAAC,CAAC;SACxK;QAED,IAAI,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,OAAO,CAAC,EAAE;YACnC,MAAM,IAAI,kBAAkB,CAAC,qBAAqB,mDAA2C,OAAO,CAAC,CAAC;SACzG;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,KAAK,CAAC,UAAU,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW,EAAE,IAAqB,EAAE,SAAkB;QAChK,IAAI,MAAM,CAAC,QAAQ,EAAE,KAAK,MAAM,CAAC,QAAQ,EAAE,EAAE;YACzC,OAAO,IAAI,CAAC,CAAC,gEAAgE;SAChF;QAED,aAAa;QACb,MAAM,EACF,MAAM,EACN,mCAAmC,EACtC,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QAEnG,oCAAoC;QACpC,IAAI,MAAM,IAAI,CAAC,SAAS,EAAE;YACtB,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACjD,MAAM,IAAI,GAAG,mCAAmC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC;YACjG,MAAM,GAAG,eAAe,CAAC,yBAAyB,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACpG;QAED,6EAA6E;QAC7E,IAAI,MAAM,IAAI,CAAC,mCAAmC,IAAI,SAAS,EAAE;YAC7D,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAC,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;SAChD;QAED,wBAAwB;QACxB,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAEjD,wBAAwB;QACxB,IAAI,IAAI,KAAK,MAAM,EAAE;YAEjB,8DAA8D;YAC9D,IAAI,cAAc,KAAK,cAAc,IAAI,2BAA2B,CAAC,cAAc,CAAC,EAAE;gBAClF,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,EAAC,SAAS,EAAC,CAAC,CAAC;aAC1D;YAEG,0DAA0D;YAC9D,uDAAuD;iBAClD;gBACD,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAC9C,IAAI,UAAU,CAAC,WAAW,EAAE;oBACxB,MAAM,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,UAAU,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;iBAC/E;qBAAM;oBACH,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;iBACzE;aACJ;YAED,OAAO,IAAI,CAAC;SACf;QAED,wBAAwB;aACnB;YAED,iDAAiD;YACjD,IAAI,cAAc,KAAK,cAAc,EAAE;gBACnC,MAAM,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,EAAC,SAAS,EAAC,CAAC,CAAC;gBAEzD,OAAO,IAAI,CAAC;aACf;YAED,sDAAsD;iBACjD;gBACD,MAAM,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC;gBAEzF,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAC,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;gBAE7C,OAAO,MAAM,CAAC;aACjB;SACJ;IACL,CAAC;IAEO,KAAK,CAAC,UAAU,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW;QAErH,+CAA+C;QAC/C,IAAI,+BAA+B,CAAC,cAAc,CAAC,IAAI,+BAA+B,CAAC,cAAc,CAAC,EAAE;YACpG,OAAO,IAAI,CAAC,cAAc,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC9E;QAED,iDAAiD;QACjD,IAAI,+BAA+B,CAAC,cAAc,CAAC,IAAI,sBAAsB,CAAC,cAAc,CAAC,EAAE;YAC3F,OAAO,IAAI,CAAC,0BAA0B,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC1F;QAED,iDAAiD;QACjD,IAAI,sBAAsB,CAAC,cAAc,CAAC,IAAI,+BAA+B,CAAC,cAAc,CAAC,EAAE;YAC3F,OAAO,IAAI,CAAC,0BAA0B,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAC1F;QAED,mDAAmD;QACnD,IAAI,sBAAsB,CAAC,cAAc,CAAC,IAAI,sBAAsB,CAAC,cAAc,CAAC,EAAE;YAClF,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC;SAChF;IACL,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,cAA6D,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QACjL,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IAC5I,CAAC;IAEO,KAAK,CAAC,sBAAsB,CAAC,cAA6D,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QACvL,OAAO,cAAc,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,EAAC,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IACpH,CAAC;IAEO,KAAK,CAAC,YAAY,CAAC,cAAkC,EAAE,YAAsB,EAAE,cAAkC,EAAE,YAAiB;QAExI,0BAA0B;QAC1B,MAAM,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;QAEzC,4BAA4B;QAC5B,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,QAAQ,CAAC,EAAE;YACtC,MAAM,OAAO,CAAC,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAC,WAAW,EAAC,EAAE;gBAC5D,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBAC3D,IAAI,WAAW,CAAC,WAAW,EAAE;oBACzB,OAAO,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,MAAM,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;iBACnH;qBAAM;oBACH,OAAO,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,WAAW,CAAC,QAAQ,EAAE,cAAc,EAAE,WAAW,CAAC,CAAC;iBAC7F;YACL,CAAC,CAAC,CAAC,CAAC;SACP;IACL,CAAC;IAED,wBAAwB;IAEhB,KAAK,CAAC,kBAAkB,CAAC,cAAkC,EAAE,MAAW,EAAE,cAAkC,EAAE,MAAW,EAAE,IAAqB,EAAE,SAAmB;QACzK,IAAI,mCAAmC,GAAG,KAAK,CAAC;QAEhD,mFAAmF;QACnF,IAAI,cAAc,KAAK,cAAc,EAAE;YACnC,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC,YAAY,8DAAmD,CAAC,CAAC;YAC/G,IAAI,CAAC,mBAAmB,EAAE;gBACtB,mCAAmC,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC;aAC7G;YAED,IAAI,mCAAmC,IAAI,IAAI,KAAK,MAAM,EAAE;gBACxD,MAAM,IAAI,KAAK,CAAC,+BAA+B,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,8DAA8D,CAAC,CAAC;aACpM;YAED,IAAI,CAAC,mCAAmC,IAAI,MAAM,CAAC,eAAe,CAAC,MAAM,EAAE,mBAAmB,CAAC,EAAE;gBAC7F,MAAM,IAAI,KAAK,CAAC,oCAAoC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;aACjJ;SACJ;QAED,yDAAyD;QACzD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACzC,IAAI,MAAM,IAAI,CAAC,mCAAmC,EAAE;YAEhD,0EAA0E;YAC1E,0EAA0E;YAC1E,IAAI,cAAc,KAAK,cAAc,EAAE;gBACnC,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,cAAc,CAAC,YAAY,8DAAmD,CAAC,CAAC;gBAC/G,IAAI,MAAM,CAAC,eAAe,CAAC,MAAM,EAAE,mBAAmB,CAAC,EAAE;oBACrD,MAAM,IAAI,KAAK,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,WAAW,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,6DAA6D,CAAC,CAAC;iBAC/K;aACJ;SACJ;QAED,OAAO,EAAC,MAAM,EAAE,mCAAmC,EAAC,CAAC;IACzD,CAAC;IAEO,KAAK,CAAC,eAAe,CAAC,QAA4D,EAAE,QAAa,EAAE,gCAAwH;QAC/N,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK,IAAI,EAAE;YAExD,cAAc;YACd,MAAM,MAAM,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAC,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;YAE7D,kEAAkE;YAClE,IAAI;gBACA,IAAI,gBAAgB,CAAC,gCAAgC,CAAC,IAAI,wBAAwB,CAAC,gCAAgC,CAAC,EAAE;oBAClH,MAAM,IAAI,CAAC,2BAA2B,CAAC,QAAQ,EAAE,MAAM,EAAE,gCAAgC,CAAC,CAAC;iBAC9F;qBAAM;oBACH,MAAM,IAAI,CAAC,6BAA6B,CAAC,QAAQ,EAAE,MAAM,EAAE,gCAAgC,CAAC,CAAC;iBAChG;aACJ;YAAC,OAAO,KAAK,EAAE;gBACZ,MAAM,6BAA6B,CAAC,KAAK,CAAC,CAAC;aAC9C;oBAAS;gBAEN,sBAAsB;gBACtB,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;aAChC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,2BAA2B,CAAC,QAA4D,EAAE,MAAc,EAAE,sBAAuF;QAC3M,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,MAAkC,CAAC;QAEvC,uDAAuD;QACvD,mDAAmD;QACnD,IAAI,wBAAwB,CAAC,sBAAsB,CAAC,EAAE;YAClD,IAAI,sBAAsB,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC1C,MAAM,KAAK,GAAG,YAAY,CAAC,MAAM,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;gBACjE,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;gBAElF,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;aACjC;YAED,gDAAgD;YAChD,IAAI,sBAAsB,CAAC,KAAK,EAAE;gBAC9B,OAAO;aACV;YAED,MAAM,GAAG,sBAAsB,CAAC,MAAM,CAAC;SAC1C;QAED,sCAAsC;aACjC;YACD,MAAM,GAAG,sBAAsB,CAAC;SACnC;QAED,OAAO,IAAI,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;YAEzC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,EAAC,KAAK,EAAC,EAAE;gBAE5B,gDAAgD;gBAChD,MAAM,CAAC,KAAK,EAAE,CAAC;gBAEf,IAAI;oBACA,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;iBACrF;gBAAC,OAAO,KAAK,EAAE;oBACZ,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;iBACxB;gBAED,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;gBAE9B,sDAAsD;gBACtD,sDAAsD;gBACtD,sDAAsD;gBACtD,kCAAkC;gBAClC,UAAU,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;YACtC,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YAC3C,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,KAAK,CAAC,6BAA6B,CAAC,QAA4D,EAAE,MAAc,EAAE,QAA8B;QACpJ,IAAI,SAAS,GAAG,CAAC,CAAC;QAElB,IAAI,KAA0B,CAAC;QAC/B,OAAO,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE;YACvC,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;YAElF,SAAS,IAAI,KAAK,CAAC,UAAU,CAAC;SACjC;IACL,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,QAA4D,EAAE,MAAc,EAAE,MAAoB,EAAE,MAAc,EAAE,SAAiB,EAAE,WAAmB;QAClL,IAAI,iBAAiB,GAAG,CAAC,CAAC;QAC1B,OAAO,iBAAiB,GAAG,MAAM,EAAE;YAC/B,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,SAAS,GAAG,iBAAiB,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,GAAG,iBAAiB,EAAE,MAAM,GAAG,iBAAiB,CAAC,CAAC;YAC7J,iBAAiB,IAAI,YAAY,CAAC;SACrC;IACL,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAuD,EAAE,QAAa,EAAE,wCAA+I;QACnP,OAAO,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,QAAQ,EAAE,wCAAwC,CAAC,CAAC,CAAC;IACvJ,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,cAAkE,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QACzL,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IAC1I,CAAC;IAEO,KAAK,CAAC,oBAAoB,CAAC,cAAkE,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAC/L,IAAI,YAAY,GAAuB,SAAS,CAAC;QACjD,IAAI,YAAY,GAAuB,SAAS,CAAC;QAEjD,IAAI;YAEA,eAAe;YACf,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAC,MAAM,EAAE,KAAK,EAAC,CAAC,CAAC;YAClE,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAC,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;YAEjE,MAAM,MAAM,GAAG,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAEpD,IAAI,SAAS,GAAG,CAAC,CAAC;YAClB,IAAI,WAAW,GAAG,CAAC,CAAC;YACpB,IAAI,SAAS,GAAG,CAAC,CAAC;YAClB,GAAG;gBACC,0FAA0F;gBAC1F,kFAAkF;gBAClF,SAAS,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,MAAM,CAAC,MAAM,EAAE,WAAW,EAAE,MAAM,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC;gBAE5H,2FAA2F;gBAC3F,+DAA+D;gBAC/D,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,CAAC,CAAC;gBAElG,SAAS,IAAI,SAAS,CAAC;gBACvB,WAAW,IAAI,SAAS,CAAC;gBAEzB,qDAAqD;gBACrD,IAAI,WAAW,KAAK,MAAM,CAAC,UAAU,EAAE;oBACnC,WAAW,GAAG,CAAC,CAAC;iBACnB;aACJ,QAAQ,SAAS,GAAG,CAAC,EAAE;SAC3B;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,6BAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;gBAAS;YACN,MAAM,OAAO,CAAC,GAAG,CAAC;gBACd,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;gBACzF,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;aAC5F,CAAC,CAAC;SACN;IACL,CAAC;IAEO,KAAK,CAAC,uBAAuB,CAAC,QAAuD,EAAE,QAAa,EAAE,wCAA+I;QACzP,IAAI,MAAoB,CAAC;QACzB,IAAI,wCAAwC,YAAY,YAAY,EAAE;YAClE,MAAM,GAAG,wCAAwC,CAAC;SACrD;aAAM,IAAI,gBAAgB,CAAC,wCAAwC,CAAC,EAAE;YACnE,MAAM,GAAG,MAAM,0BAA0B,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SAChG;aAAM,IAAI,wBAAwB,CAAC,wCAAwC,CAAC,EAAE;YAC3E,MAAM,GAAG,MAAM,kCAAkC,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SACxG;aAAM;YACH,MAAM,GAAG,oBAAoB,CAAC,QAAQ,CAAC,wCAAwC,CAAC,CAAC;SACpF;QAED,OAAO,QAAQ,CAAC,SAAS,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,EAAE,EAAC,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IACxF,CAAC;IAEO,KAAK,CAAC,0BAA0B,CAAC,cAA6D,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAChM,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,gCAAgC,CAAC,cAAc,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IACtJ,CAAC;IAEO,KAAK,CAAC,gCAAgC,CAAC,cAA6D,EAAE,MAAW,EAAE,cAAkE,EAAE,MAAW;QAEtM,cAAc;QACd,MAAM,YAAY,GAAG,MAAM,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,EAAC,MAAM,EAAE,IAAI,EAAC,CAAC,CAAC;QAEvE,oDAAoD;QACpD,IAAI;YACA,MAAM,MAAM,GAAG,MAAM,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;YACrD,MAAM,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE,YAAY,EAAE,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,MAAM,CAAC,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SAC9G;QAAC,OAAO,KAAK,EAAE;YACZ,MAAM,6BAA6B,CAAC,KAAK,CAAC,CAAC;SAC9C;gBAAS;YACN,MAAM,cAAc,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;SAC5C;IACL,CAAC;IAEO,KAAK,CAAC,0BAA0B,CAAC,cAAkE,EAAE,MAAW,EAAE,cAA6D,EAAE,MAAW;QAEhM,kCAAkC;QAClC,MAAM,MAAM,GAAG,MAAM,0BAA0B,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,MAAM,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QAEhI,mCAAmC;QACnC,MAAM,IAAI,CAAC,iBAAiB,CAAC,cAAc,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACjE,CAAC;IAEO,gBAAgB,CAAC,QAA4B,EAAE,QAAa,EAAE,IAAyB;QAC3F,+DAA+D;QAC/D,4DAA4D;QAC5D,kDAAkD;QAClD,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACnD,MAAM,UAAU,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAC1F,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC3C,OAAO,UAAU,CAAC;IACtB,CAAC;IAEO,KAAK,CAAC,MAAM,CAAC,QAA4B,EAAE,SAAc;QAC7D,MAAM,mBAAmB,GAAa,EAAE,CAAC;QAEzC,4BAA4B;QAC5B,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE;YAC3B,IAAI;gBACA,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC5C,IAAI,IAAI,KAAK,SAAS,EAAE;oBACpB,2DAA2D;oBAC3D,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAE9C,cAAc;oBACd,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;oBAC7B,MAAM;iBACT;gBACD,IAAI,CAAC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;oBACxC,MAAM,IAAI,KAAK,CAAC,2BAA2B,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,6CAA6C,CAAC,CAAC;iBAC7H;gBAED,MAAM,CAAC,8CAA8C;aACxD;YAAC,OAAO,KAAK,EAAE;gBAEZ,uDAAuD;gBACvD,IAAI,6BAA6B,CAAC,KAAK,CAAC,KAAK,2BAA2B,CAAC,YAAY,EAAE;oBACnF,MAAM,KAAK,CAAC;iBACf;gBAED,2DAA2D;gBAC3D,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAE9C,cAAc;gBACd,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;aAChC;SACJ;QAED,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,mBAAmB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACtD,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC;YAEtD,IAAI;gBACA,MAAM,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;aACnC;YAAC,OAAO,KAAK,EAAE;gBACZ,IAAI,6BAA6B,CAAC,KAAK,CAAC,KAAK,2BAA2B,CAAC,UAAU,EAAE;oBACjF,uDAAuD;oBACvD,0DAA0D;oBAC1D,0DAA0D;oBAC1D,2DAA2D;oBAC3D,mDAAmD;oBACnD,2DAA2D;oBAC3D,yCAAyC;oBACzC,8DAA8D;oBAC9D,MAAM,KAAK,CAAC;iBACf;aACJ;SACJ;IACL,CAAC;IAEO,KAAK,CAAC,iBAAiB,CAAC,QAAa;QACzC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,+BAA+B,CAAC,QAAQ,CAAC,IAAI,sBAAsB,CAAC,QAAQ,CAAC,EAAE;YAC/E,OAAO,QAAQ,CAAC;SACnB;QAED,MAAM,IAAI,KAAK,CAAC,mCAAmC,QAAQ,CAAC,MAAM,4GAA4G,CAAC,CAAC;IACpL,CAAC;IAEO,UAAU,CAAC,QAA4B,EAAE,QAAa,EAAE,OAAqB;QACjF,OAAO;YACH,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,CAAC;YACjC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC;YACzB,OAAO,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAa,kCAAkC;SACzE,CAAC,IAAI,EAAE,CAAC;IACb,CAAC;IAEO,QAAQ,CAAC,QAA4B,EAAE,QAAa;QACxD,MAAM,mBAAmB,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,YAAY,8DAAmD,CAAC,CAAC;QAEzG,OAAO,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,CAAC;IACzF,CAAC;IAEO,KAAK,CAAC,MAAM,CAAC,QAAa,EAAE,OAA8D;QAC9F,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;QAE3C,kDAAkD;QAClD,IAAI,YAA+B,CAAC;QACpC,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,EAAE;YAC3B,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;YACvD,YAAY,mCACL,OAAO,KACV,KAAK,EAAE,0BAA0B,CAAC,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,GAC9D,CAAC;SACL;aAAM;YACH,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;SAC/D;QAED,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,YAAY,CAAC,KAAK,EAAE;YACxE,aAAa,EAAE,OAAO,CAAC,iBAAiB;YACxC,iBAAiB,EAAE,gBAAgB,CAAC,EAAE,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,gBAAgB,CAAC;SACnG,CAAC,CAAC;QAEH,kBAAkB;QAClB,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,KAAI,OAAO,CAAC,QAAQ,CAAC,WAAW,EAAE;YACzD,MAAM,IAAI,sBAAsB,CAAC,sDAAsD,kDAA0C,OAAO,CAAC,CAAC;SAC7I;QAED,OAAO,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;IACnC,CAAC;IAEO,sBAAsB,CAAC,QAAa,EAAE,IAAY,EAAE,OAAyB;QACjF,IAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,EAAE;YACjB,IAAI,mBAAmB,GAAoC,SAAS,CAAC;YAErE,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,KAAK,QAAQ,IAAI,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE;gBAC3E,mBAAmB,wDAAgD,CAAC;aACvE;YAED,IAAI,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE;gBACvE,mBAAmB,6CAAqC,CAAC;aAC5D;YAED,IAAI,OAAO,mBAAmB,KAAK,QAAQ,EAAE;gBACzC,MAAM,IAAI,kBAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,6BAA6B,EAAE,mBAAmB,CAAC,CAAC;aAC3I;SACJ;IACL,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,QAAa,EAAE,OAAyB;QACnE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAC,eAAe,EAAE,IAAI,EAAC,CAAC,CAAC;QAEnE,mCAAmC;QACnC,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,MAAM,IAAI,kBAAkB,CAAC,wBAAwB,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,gCAAgC,iDAAyC,OAAO,CAAC,CAAC;SACzK;QAED,qDAAqD;QACrD,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,aAAa,IAAI,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAE;YAC7G,MAAM,IAAI,kBAAkB,CAAC,yBAAyB,uDAA+C,OAAO,CAAC,CAAC;SACjH;QAED,qCAAqC;QACrC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAE1D,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,QAAwD,EAAE,QAAa,EAAE,KAAwB,EAAE,UAA2B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAC5K,MAAM,UAAU,GAAG,MAAM,QAAQ,CAAC,cAAc,CAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QAE3E,OAAO,OAAO,CAAC,OAAO,CAClB,SAAS,CAAC,UAAU,EAAE;YAClB,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,YAAY,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC;YAC3E,KAAK,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC;SAC7F,EAAE,IAAI,CAAC,EAAE,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CACxC,CAAC;IACN,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,QAAuD,EAAE,QAAa,EAAE,OAAyB;QAC9H,IAAI,MAAM,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAE/C,0BAA0B;QAC1B,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,QAAQ,KAAK,QAAQ,EAAE;YACjD,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;SAC3C;QAED,wBAAwB;QACxB,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,KAAK,QAAQ,EAAE;YAC/C,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;SAC5C;QAED,qCAAqC;QACrC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,MAAM,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAElE,OAAO,0BAA0B,CAAC,UAAU,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC5E,CAAC;IAEO,gBAAgB,CAAC,QAA4D,EAAE,QAAa,EAAE,KAAwB,EAAE,UAA2B,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAC1K,MAAM,MAAM,GAAG,2BAA2B,CAAC,MAAM,EAAE,CAAC;QAEpD,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,kCACpD,OAAO,KACV,UAAU,EAAE,IAAI,CAAC,WAAW,EAC5B,gBAAgB,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,KACtG,KAAK,CAAC,CAAC;QAEV,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,KAAK,CAAC,kBAAkB,CAAC,QAA4G,EAAE,QAAa,EAAE,OAA0D;QAEpN,mDAAmD;QACnD,mDAAmD;QACnD,mDAAmD;QACnD,mDAAmD;QACnD,MAAM,iBAAiB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAExD,0BAA0B;QAC1B,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;YACpF,iBAAiB,CAAC,MAAM,EAAE,CAAC;YAE3B,MAAM,KAAK,CAAC;QAChB,CAAC,CAAC,CAAC;QAEH,IAAI;YAEA,iEAAiE;YACjE,gEAAgE;YAChE,+DAA+D;YAC/D,+BAA+B;YAC/B,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,KAAK,aAAa,EAAE;gBAC/E,MAAM,WAAW,CAAC;aACrB;YAED,IAAI,iBAAsD,CAAC;YAE3D,8FAA8F;YAC9F,IAAI,CAAC,CAAC,+BAA+B,CAAC,QAAQ,CAAC,IAAI,2BAA2B,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,KAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,gBAAgB,CAAA,CAAC,EAAE;gBAC1J,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;aAC5E;YAED,6DAA6D;iBACxD,IAAI,2BAA2B,CAAC,QAAQ,CAAC,EAAE;gBAC5C,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;aACpH;YAED,gBAAgB;iBACX;gBACD,iBAAiB,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;aACpH;YAED,MAAM,CAAC,QAAQ,EAAE,UAAU,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,iBAAiB,CAAC,CAAC,CAAC;YAEnF,uCACO,QAAQ,KACX,KAAK,EAAE,UAAU,IACnB;SACL;QAAC,OAAO,KAAK,EAAE;YACZ,IAAI,CAAC,2BAA2B,CAAC,qBAAqB,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;SACrF;IACL,CAAC;IAEO,KAAK,CAAC,gBAAgB,CAAC,QAAa;QACxC,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QAEnD,IAAI,+BAA+B,CAAC,QAAQ,CAAC,IAAI,sBAAsB,CAAC,QAAQ,CAAC,EAAE;YAC/E,OAAO,QAAQ,CAAC;SACnB;QAED,MAAM,IAAI,KAAK,CAAC,mCAAmC,QAAQ,CAAC,MAAM,2HAA2H,CAAC,CAAC;IACnM,CAAC;IAGS,KAAK,CAAC,kBAAkB;QAC9B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QACrD,aAAa;QACb,QAAQ,CAAC,QAAQ,EAAE,CAAC;IACxB,CAAC;CAmBJ,CAAA;AA/3CG;IADC,MAAM,CAAC,aAAa,CAAC;kDAC0B;AAEhD;IADC,MAAM,CAAC,qBAAqB,CAAC;gDACwB;AAEtD;IADC,MAAM,CAAC,gBAAgB,CAAC;qDAC6B;AAEtD;IADC,MAAM,CAAC,eAAe,CAAC;oDAC4B;AAEpD;IADC,MAAM,CAAC,oBAAoB,CAAC;IAAE,KAAK,CAAC,uBAAuB,CAAC;kDACmB;AAgfhF;IADC,aAAa,EAAE;uCAKf;AA/fQ,WAAW;IADvB,UAAU,EAAE;GACA,WAAW,CAk4CvB;SAl4CY,WAAW","file":"../../src/browser/file-service.js","sourcesContent":["import {inject, injectable, named, postConstruct} from 'inversify';\r\nimport {\r\n    AsyncEmitter,\r\n    CancellationToken,\r\n    CancellationTokenSource,\r\n    ContributionProvider,\r\n    Disposable,\r\n    DisposableCollection,\r\n    Emitter,\r\n    Event,\r\n    Mutable,\r\n    WaitUntilEvent\r\n} from '@tart/core/lib/common';\r\nimport {\r\n    BaseStatWithMetadata,\r\n    CopyFileOptions,\r\n    CreateFileOptions,\r\n    ensureFileSystemProviderError,\r\n    etag,\r\n    ETAG_DISABLED,\r\n    FileChangesEvent,\r\n    FileContent,\r\n    FileDeleteOptions,\r\n    FileOperation,\r\n    FileOperationError,\r\n    FileOperationEvent,\r\n    FileOperationOptions,\r\n    FileOperationResult,\r\n    FileStat,\r\n    FileStatWithMetadata,\r\n    FileStreamContent,\r\n    FileSystemProvider,\r\n    FileSystemProviderCapabilities,\r\n    FileSystemProviderErrorCode,\r\n    FileSystemProviderWithFileReadStreamCapability,\r\n    FileSystemProviderWithFileReadWriteCapability,\r\n    FileSystemProviderWithOpenReadWriteCloseCapability,\r\n    FileType,\r\n    hasFileFolderCopyCapability,\r\n    hasFileReadStreamCapability,\r\n    hasOpenReadWriteCloseCapability,\r\n    hasReadWriteCapability,\r\n    hasUpdateCapability,\r\n    MoveFileOptions,\r\n    ReadFileOptions,\r\n    ResolveFileOptions,\r\n    ResolveMetadataFileOptions,\r\n    Stat,\r\n    toFileOperationResult,\r\n    toFileSystemProviderErrorCode,\r\n    WatchOptions,\r\n    WriteFileOptions\r\n} from '../common/files';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {Deferred} from '@tart/core/lib/common/promise-util';\r\nimport {TernarySearchTree} from '@tart/core/lib/common/ternary-search-tree';\r\nimport type {TextDocumentContentChangeEvent} from 'vscode-languageserver-protocol';\r\nimport {LabelProvider} from '@tart/core';\r\nimport {EncodingRegistry} from '@tart/core/lib/browser/encoding-registry';\r\nimport {\r\n    consumeStream,\r\n    isReadableBufferedStream,\r\n    isReadableStream,\r\n    peekReadable,\r\n    peekStream,\r\n    Readable,\r\n    ReadableStream,\r\n    transform\r\n} from '@tart/core/lib/common/stream';\r\nimport {DecodeStreamResult, EncodingService, ResourceEncoding} from '@tart/core/lib/common/encoding-service';\r\nimport {UTF8, UTF8_with_bom} from '@tart/core/lib/common/encodings';\r\nimport {FileSystemPreferences} from './filesystem-preferences';\r\nimport {\r\n    BinaryBuffer,\r\n    BinaryBufferReadable,\r\n    BinaryBufferReadableBufferedStream,\r\n    BinaryBufferReadableStream,\r\n    BinaryBufferWriteableStream\r\n} from '@tart/core/lib/common/buffer';\r\nimport {readFileIntoStream} from '../common/io';\r\nimport {FileSystemUtils} from './file-tree/filesystem-utils';\r\n\r\nexport const FileServiceContribution = Symbol('FileServiceContribution');\r\n\r\n/**\r\n * A {@link FileServiceContribution} can be used to add custom {@link FileSystemProvider}s.\r\n * For this, the contribution has to listen to the {@link FileSystemProviderActivationEvent} and register\r\n * the custom {@link FileSystemProvider}s according to the scheme when this event is fired.\r\n *\r\n * ### Example usage\r\n * ```ts\r\n * export class MyFileServiceContribution implements FileServiceContribution {\r\n *     registerFileSystemProviders(service: FileService): void {\r\n *         service.onWillActivateFileSystemProvider(event => {\r\n *             if (event.scheme === 'mySyncProviderScheme') {\r\n *                 service.registerProvider('mySyncProviderScheme', this.mySyncProvider);\r\n *             }\r\n *             if (event.scheme === 'myAsyncProviderScheme') {\r\n *                 event.waitUntil((async () => {\r\n *                     const myAsyncProvider = await this.createAsyncProvider();\r\n *                     service.registerProvider('myAsyncProviderScheme', myAsyncProvider);\r\n *                 })());\r\n *             }\r\n *         });\r\n *\r\n *     }\r\n *```\r\n */\r\nexport interface FileServiceContribution {\r\n    /**\r\n     * Register custom file system providers for the given {@link FileService}.\r\n     * @param service The file service for which the providers should be registered.\r\n     */\r\n    registerFileSystemProviders(service: FileService): void;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderActivation` event.\r\n * This event is fired by the {@link FileService} if it wants to activate the\r\n * {@link FileSystemProvider} for a specific scheme.\r\n */\r\nexport interface FileSystemProviderActivationEvent extends WaitUntilEvent {\r\n    /** The (uri) scheme for which the provider should be activated */\r\n    scheme: string;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderCapabilitiesChange` event.\r\n * This event is fired by the {@link FileService} if the capabilities of one of its managed\r\n * {@link FileSystemProvider}s have changed.\r\n */\r\nexport interface FileSystemProviderCapabilitiesChangeEvent {\r\n    /** The affected file system provider for which this event was fired. */\r\n    provider: FileSystemProvider;\r\n    /** The (uri) scheme for which the provider is registered */\r\n    scheme: string;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderRegistration` event.\r\n * This event is fired by the {@link FileService} if a {@link FileSystemProvider} is\r\n * registered to or unregistered from the service.\r\n */\r\nexport interface FileSystemProviderRegistrationEvent {\r\n    /** `True` if a new provider has been registered, `false` if a provider has been unregistered. */\r\n    added: boolean;\r\n    /** The (uri) scheme for which the provider was (previously) registered */\r\n    scheme: string;\r\n    /** The affected file system provider for which this event was fired. */\r\n    provider?: FileSystemProvider;\r\n}\r\n\r\nexport interface ReadEncodingOptions {\r\n\r\n    /**\r\n     * The optional encoding parameter allows to specify the desired encoding when resolving\r\n     * the contents of the file.\r\n     */\r\n    encoding?: string;\r\n\r\n    /**\r\n     * The optional guessEncoding parameter allows to guess encoding from content of the file.\r\n     */\r\n    autoGuessEncoding?: boolean;\r\n}\r\n\r\ninterface BaseTextFileContent extends BaseStatWithMetadata {\r\n\r\n    /**\r\n     * The encoding of the content if known.\r\n     */\r\n    encoding: string;\r\n}\r\n\r\nexport interface TextFileStreamContent extends BaseTextFileContent {\r\n\r\n    /**\r\n     * The line grouped content of a text file.\r\n     */\r\n    value: ReadableStream<string>;\r\n}\r\n\r\n\r\nexport interface TextFileContent extends BaseTextFileContent {\r\n\r\n    /**\r\n     * The content of a text file.\r\n     */\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface WriteEncodingOptions {\r\n\r\n    /**\r\n     * The encoding to use when updating a file.\r\n     */\r\n    encoding?: string;\r\n\r\n    /**\r\n     * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\r\n     */\r\n    overwriteEncoding?: boolean;\r\n}\r\n\r\nexport interface ReadTextFileOptions extends ReadEncodingOptions, ReadFileOptions {\r\n    /**\r\n     * The optional acceptTextOnly parameter allows to fail this request early if the file\r\n     * contents are not textual.\r\n     */\r\n    acceptTextOnly?: boolean;\r\n}\r\n\r\n\r\nexport interface CreateTextFileOptions extends WriteEncodingOptions, CreateFileOptions {\r\n}\r\n\r\nexport interface WriteTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\r\n}\r\n\r\nexport interface UpdateTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\r\n    readEncoding: string\r\n}\r\n\r\nexport interface UserFileOperationEvent extends WaitUntilEvent {\r\n\r\n    /**\r\n     * An identifier to correlate the operation through the\r\n     * different event types (before, after, error).\r\n     */\r\n    readonly correlationId: number;\r\n\r\n    /**\r\n     * The file operation that is taking place.\r\n     */\r\n    readonly operation: FileOperation;\r\n\r\n    /**\r\n     * The resource the event is about.\r\n     */\r\n    readonly target: URI;\r\n\r\n    /**\r\n     * A property that is defined for move operations.\r\n     */\r\n    readonly source?: URI;\r\n}\r\n\r\nexport const enum TextFileOperationResult {\r\n    FILE_IS_BINARY\r\n}\r\n\r\nexport class TextFileOperationError extends FileOperationError {\r\n\r\n    constructor(\r\n        message: string,\r\n        public textFileOperationResult: TextFileOperationResult,\r\n        public options?: ReadTextFileOptions & WriteTextFileOptions\r\n    ) {\r\n        super(message, FileOperationResult.FILE_OTHER_ERROR);\r\n        Object.setPrototypeOf(this, TextFileOperationError.prototype);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * The {@link FileService} is the common facade responsible for all interactions with file systems.\r\n * It manages all registered {@link FileSystemProvider}s and\r\n *  forwards calls to the responsible {@link FileSystemProvider}, determined by the scheme.\r\n * For additional documentation regarding the provided functions see also {@link FileSystemProvider}.\r\n */\r\n@injectable()\r\nexport class FileService {\r\n\r\n    @inject(LabelProvider)\r\n    protected readonly labelProvider: LabelProvider;\r\n    @inject(FileSystemPreferences)\r\n    protected readonly preferences: FileSystemPreferences;\r\n    @inject(EncodingRegistry)\r\n    protected readonly encodingRegistry: EncodingRegistry;\r\n    @inject(EncodingService)\r\n    protected readonly encodingService: EncodingService;\r\n    @inject(ContributionProvider) @named(FileServiceContribution)\r\n    protected readonly contributions: ContributionProvider<FileServiceContribution>;\r\n    private readonly BUFFER_SIZE = 64 * 1024;\r\n    private onWillActivateFileSystemProviderEmitter = new Emitter<FileSystemProviderActivationEvent>();\r\n    /**\r\n     * See `FileServiceContribution.registerProviders`.\r\n     */\r\n    readonly onWillActivateFileSystemProvider = this.onWillActivateFileSystemProviderEmitter.event;\r\n    private onDidChangeFileSystemProviderRegistrationsEmitter = new Emitter<FileSystemProviderRegistrationEvent>();\r\n    private readonly providers = new Map<string, FileSystemProvider>();\r\n    private readonly activations = new Map<string, Promise<FileSystemProvider>>();\r\n    private correlationIds = 0;\r\n\r\n    // #region Events\r\n    private readonly onWillRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is being performed.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onWillRunUserOperation = this.onWillRunUserOperationEmitter.event;\r\n    private readonly onDidFailUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is failed.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onDidFailUserOperation = this.onDidFailUserOperationEmitter.event;\r\n    private readonly onDidRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is finished.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onDidRunUserOperation = this.onDidRunUserOperationEmitter.event;\r\n    private onDidRunOperationEmitter = new Emitter<FileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when operation is finished.\r\n     * This event is triggered by user gestures and programmatically.\r\n     */\r\n    readonly onDidRunOperation = this.onDidRunOperationEmitter.event;\r\n    private writeQueues: Map<string, Promise<void>> = new Map();\r\n    private onDidFilesChangeEmitter = new Emitter<FileChangesEvent>();\r\n    private activeWatchers = new Map<string, { disposable: Disposable, count: number }>();\r\n    private onDidChangeFileSystemProviderCapabilitiesEmitter = new Emitter<FileSystemProviderCapabilitiesChangeEvent>();\r\n    readonly onDidChangeFileSystemProviderCapabilities = this.onDidChangeFileSystemProviderCapabilitiesEmitter.event;\r\n\r\n    /**\r\n     * An event that is emitted when files are changed on the disk.\r\n     */\r\n    get onDidFilesChange(): Event<FileChangesEvent> {\r\n        return this.onDidFilesChangeEmitter.event;\r\n    }\r\n\r\n    /**\r\n     * Try to resolve file information and metadata for the given resource.\r\n     * @param resource `URI` of the resource that should be resolved.\r\n     * @param options  Options to customize the resolvement process.\r\n     *\r\n     * @return A promise that resolves if the resource could be successfully resolved.\r\n     */\r\n    resolve(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\r\n\r\n    resolve(resource: URI, options?: ResolveFileOptions | undefined): Promise<FileStat>;\r\n\r\n    async resolve(resource: any, options?: any) {\r\n        try {\r\n            return await this.doResolveFile(resource, options);\r\n        } catch (error) {\r\n\r\n            // Specially handle file not found case as file operation result\r\n            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\r\n                throw new FileOperationError(`Unable to resolve non-existing file ''`, FileOperationResult.FILE_NOT_FOUND);\r\n            }\r\n\r\n            // Bubble up any other error as is\r\n            throw ensureFileSystemProviderError(error);\r\n        }\r\n    }\r\n\r\n    async write(resource: URI, value: string | Readable<string>, options?: WriteTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\r\n        const encoding = await this.getWriteEncoding(resource, options);\r\n        const encoded = await this.encodingService.encodeStream(value, encoding);\r\n        return Object.assign(await this.writeFile(resource, encoded, options), {encoding: encoding.encoding});\r\n    }\r\n\r\n    async runFileOperationParticipants(target: URI, source: URI | undefined, operation: FileOperation): Promise<void> {\r\n        const participantsTimeout = this.preferences['files.participants.timeout'];\r\n        if (participantsTimeout <= 0) {\r\n            return;\r\n        }\r\n\r\n        const cancellationTokenSource = new CancellationTokenSource();\r\n\r\n        // return this.progressService.withProgress(this.progressLabel(operation), 'window', async () => {\r\n        //     for (const participant of this.participants) {\r\n        //         if (cancellationTokenSource.token.isCancellationRequested) {\r\n        //             break;\r\n        //         }\r\n        //\r\n        //         try {\r\n        //             const promise = participant.participate(target, source, operation, participantsTimeout, cancellationTokenSource.token);\r\n        //             await Promise.race([\r\n        //                 promise,\r\n        //                 timeout(participantsTimeout, cancellationTokenSource.token).then(() => cancellationTokenSource.dispose(), () => { /* no-op if cancelled */ })\r\n        //             ]);\r\n        //         } catch (err) {\r\n        //             console.warn(err);\r\n        //         }\r\n        //     }\r\n        // });\r\n    }\r\n\r\n    async copy(source: URI, target: URI, options?: CopyFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doCopy(source, target, options.overwrite);\r\n        }\r\n        await this.runFileOperationParticipants(target, source, FileOperation.COPY);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.COPY, target, source};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doCopy(source, target, options?.overwrite);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n        return stat;\r\n    }\r\n\r\n    async delete(resource: URI, options?: FileOperationOptions & Partial<FileDeleteOptions>): Promise<void> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doDelete(resource, options);\r\n        }\r\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.DELETE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.DELETE, target: resource};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        try {\r\n            await this.doDelete(resource, options);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n    }\r\n\r\n    async move(source: URI, target: URI, options?: MoveFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doMove(source, target, options.overwrite);\r\n        }\r\n        await this.runFileOperationParticipants(target, source, FileOperation.MOVE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.MOVE, target, source};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doMove(source, target, options?.overwrite);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n        return stat;\r\n    }\r\n\r\n    async createFolder(resource: URI, options: FileOperationOptions = {}): Promise<FileStatWithMetadata> {\r\n        const {\r\n            fromUserGesture = true,\r\n        } = options;\r\n\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\r\n\r\n        // mkdir recursively\r\n        await this.mkdirp(provider, resource);\r\n\r\n        // events\r\n        const fileStat = await this.resolve(resource, {resolveMetadata: true});\r\n\r\n        if (fromUserGesture) {\r\n            this.onDidRunUserOperationEmitter.fire({\r\n                correlationId: this.correlationIds++,\r\n                operation: FileOperation.CREATE,\r\n                target: resource\r\n            });\r\n        } else {\r\n            this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\r\n        }\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    async writeFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream, options?: WriteFileOptions): Promise<FileStatWithMetadata> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\r\n\r\n        try {\r\n\r\n            // validate write\r\n            const stat = await this.validateWriteFile(provider, resource, options);\r\n\r\n            // mkdir recursively as needed\r\n            if (!stat) {\r\n                await this.mkdirp(provider, resource.parent);\r\n            }\r\n\r\n            // optimization: if the provider has unbuffered write capability and the data\r\n            // to write is a Readable, we consume up to 3 chunks and try to write the data\r\n            // unbuffered to reduce the overhead. If the Readable has more data to provide\r\n            // we continue to write buffered.\r\n            let bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream;\r\n            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof BinaryBuffer)) {\r\n                if (isReadableStream(bufferOrReadableOrStream)) {\r\n                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\r\n                    if (bufferedStream.ended) {\r\n                        bufferOrReadableOrStreamOrBufferedStream = BinaryBuffer.concat(bufferedStream.buffer);\r\n                    } else {\r\n                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;\r\n                    }\r\n                } else {\r\n                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => BinaryBuffer.concat(data), 3);\r\n                }\r\n            } else {\r\n                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\r\n            }\r\n\r\n            // write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\r\n            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer)) {\r\n                await this.doWriteUnbuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream);\r\n            }\r\n\r\n            // write file: buffered\r\n            else {\r\n                await this.doWriteBuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer ? BinaryBufferReadable.fromBuffer(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\r\n            }\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\r\n        }\r\n\r\n        return this.resolve(resource, {resolveMetadata: true});\r\n    }\r\n\r\n    /**\r\n     * Tests if the given resource exists in the filesystem.\r\n     * @param resource `URI` of the resource which should be tested.\r\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\r\n     *\r\n     * @returns A promise that resolves to `true` if the resource exists.\r\n     */\r\n    async exists(resource: URI): Promise<boolean> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        try {\r\n            const stat = await provider.stat(resource);\r\n\r\n            return !!stat;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async create(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doCreate(resource, value, options);\r\n        }\r\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.CREATE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doCreate(resource, value, options);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n\r\n        return stat;\r\n    }\r\n\r\n    async createFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream = BinaryBuffer.fromString(''), options?: CreateFileOptions): Promise<FileStatWithMetadata> {\r\n\r\n        // validate overwrite\r\n        if (!options?.overwrite && await this.exists(resource)) {\r\n            throw new FileOperationError(`Unable to create file '${this.resourceForError(resource)}' that already exists when overwrite flag is not set`, FileOperationResult.FILE_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        // do write into file (this will create it too)\r\n        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\r\n\r\n        // events\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    async update(resource: URI, changes: TextDocumentContentChangeEvent[], options: UpdateTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\r\n        try {\r\n            await this.validateWriteFile(provider, resource, options);\r\n            if (hasUpdateCapability(provider)) {\r\n                const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\r\n                const stat = await provider.updateFile(resource, changes, {\r\n                    readEncoding: options.readEncoding,\r\n                    writeEncoding: encoding,\r\n                    overwriteEncoding: options.overwriteEncoding || false\r\n                });\r\n                return Object.assign(FileStat.fromStat(resource, stat), {encoding: stat.encoding});\r\n            } else {\r\n                throw new Error('incremental file update is not supported');\r\n            }\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to activate the registered provider for the given scheme\r\n     * @param scheme  The uri scheme for which the responsible provider should be activated.\r\n     *\r\n     * @returns A promise of the activated file system provider. Only resolves if a provider is available for this scheme, gets rejected otherwise.\r\n     */\r\n    async activateProvider(scheme: string): Promise<FileSystemProvider> {\r\n        let provider = this.providers.get(scheme);\r\n        if (provider) {\r\n            return provider;\r\n        }\r\n        let activation = this.activations.get(scheme);\r\n        if (!activation) {\r\n            const deferredActivation = new Deferred<FileSystemProvider>();\r\n            this.activations.set(scheme, activation = deferredActivation.promise);\r\n            WaitUntilEvent.fire(this.onWillActivateFileSystemProviderEmitter, {scheme}).then(() => {\r\n                provider = this.providers.get(scheme);\r\n                if (!provider) {\r\n                    const error = new Error();\r\n                    error.name = 'ENOPRO';\r\n                    error.message = `No file system provider found for scheme ${scheme}`;\r\n                    throw error;\r\n                } else {\r\n                    deferredActivation.resolve(provider);\r\n                }\r\n            }).catch(e => deferredActivation.reject(e));\r\n        }\r\n        return activation;\r\n    }\r\n\r\n    /**\r\n     * Tests if the service (i.e the {@link FileSystemProvider} registered for the given uri scheme) provides the given capability.\r\n     * @param resource `URI` of the resource to test.\r\n     * @param capability The required capability.\r\n     *\r\n     * @returns `true` if the resource can be handled and the required capability can be provided.\r\n     */\r\n    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\r\n        const provider = this.providers.get(resource.scheme);\r\n\r\n        return !!(provider && (provider.capabilities & capability));\r\n    }\r\n\r\n    watch(resource: URI, options: WatchOptions = {recursive: false, excludes: []}): Disposable {\r\n        const resolvedOptions: WatchOptions = {\r\n            ...options,\r\n            // always ignore temporary upload files\r\n            excludes: options.excludes.concat('**/tart_upload_*')\r\n        };\r\n\r\n        let watchDisposed = false;\r\n        let watchDisposable = Disposable.create(() => watchDisposed = true);\r\n\r\n        // Watch and wire in disposable which is async but\r\n        // check if we got disposed meanwhile and forward4\r\n        this.doWatch(resource, resolvedOptions).then(disposable => {\r\n            if (watchDisposed) {\r\n                disposable.dispose();\r\n            } else {\r\n                watchDisposable = disposable;\r\n            }\r\n        }, error => console.error(error));\r\n\r\n        return Disposable.create(() => watchDisposable.dispose());\r\n    }\r\n\r\n    async doWatch(resource: URI, options: WatchOptions): Promise<Disposable> {\r\n        const provider = await this.withProvider(resource);\r\n        const key = this.toWatchKey(provider, resource, options);\r\n\r\n        // Only start watching if we are the first for the given key\r\n        const watcher = this.activeWatchers.get(key) || {count: 0, disposable: provider.watch(resource, options)};\r\n        if (!this.activeWatchers.has(key)) {\r\n            this.activeWatchers.set(key, watcher);\r\n        }\r\n\r\n        // Increment usage counter\r\n        watcher.count += 1;\r\n\r\n        return Disposable.create(() => {\r\n\r\n            // Unref\r\n            watcher.count--;\r\n\r\n            // Dispose only when last user is reached\r\n            if (watcher.count === 0) {\r\n                watcher.disposable.dispose();\r\n                this.activeWatchers.delete(key);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers a new {@link FileSystemProvider} for the given scheme.\r\n     * @param scheme The (uri) scheme for which the provider should be registered.\r\n     * @param provider The file system provider that should be registered.\r\n     *\r\n     * @returns A `Disposable` that can be invoked to unregister the given provider.\r\n     */\r\n    registerProvider(scheme: string, provider: FileSystemProvider): Disposable {\r\n        if (this.providers.has(scheme)) {\r\n            console.log('error');\r\n            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\r\n        }\r\n\r\n        this.providers.set(scheme, provider);\r\n        this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({added: true, scheme, provider});\r\n\r\n        const providerDisposables = new DisposableCollection();\r\n        providerDisposables.push(provider.onDidChangeFile(changes => this.onDidFilesChangeEmitter.fire(new FileChangesEvent(changes))));\r\n        // providerDisposables.push(provider.onFileWatchError(() => this.handleFileWatchError()));\r\n        providerDisposables.push(provider.onDidChangeCapabilities(() => this.onDidChangeFileSystemProviderCapabilitiesEmitter.fire({\r\n            provider,\r\n            scheme\r\n        })));\r\n\r\n        return Disposable.create(() => {\r\n            this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({added: false, scheme, provider});\r\n            this.providers.delete(scheme);\r\n\r\n            providerDisposables.dispose();\r\n        });\r\n    }\r\n\r\n    async read(resource: URI, options?: ReadTextFileOptions): Promise<TextFileContent> {\r\n        const [bufferStream, decoder] = await this.doRead(resource, {\r\n            ...options,\r\n            // optimization: since we know that the caller does not\r\n            // care about buffering, we indicate this to the reader.\r\n            // this reduces all the overhead the buffered reading\r\n            // has (open, read, close) if the provider supports\r\n            // unbuffered reading.\r\n            preferUnbuffered: true\r\n        });\r\n\r\n        return {\r\n            ...bufferStream,\r\n            encoding: decoder.detected.encoding || UTF8,\r\n            value: await consumeStream(decoder.stream, strings => strings.join(''))\r\n        };\r\n    }\r\n\r\n    async readFileStream(resource: URI, options?: ReadFileOptions): Promise<FileStreamContent> {\r\n        const provider = await this.withReadProvider(resource);\r\n\r\n        return this.doReadAsFileStream(provider, resource, options);\r\n    }\r\n\r\n    async readStream(resource: URI, options?: ReadTextFileOptions): Promise<TextFileStreamContent> {\r\n        const [bufferStream, decoder] = await this.doRead(resource, options);\r\n\r\n        return {\r\n            ...bufferStream,\r\n            encoding: decoder.detected.encoding || UTF8,\r\n            value: decoder.stream\r\n        };\r\n    }\r\n\r\n    async readFile(resource: URI, options?: ReadFileOptions): Promise<FileContent> {\r\n        const provider = await this.withReadProvider(resource);\r\n\r\n        const stream = await this.doReadAsFileStream(provider, resource, {\r\n            ...options,\r\n            // optimization: since we know that the caller does not\r\n            // care about buffering, we indicate this to the reader.\r\n            // this reduces all the overhead the buffered reading\r\n            // has (open, read, close) if the provider supports\r\n            // unbuffered reading.\r\n            preferUnbuffered: true\r\n        });\r\n        return {\r\n            ...stream,\r\n            value: await BinaryBufferReadableStream.toBuffer(stream.value)\r\n        };\r\n    }\r\n\r\n    @postConstruct()\r\n    protected init(): void {\r\n        for (const contribution of this.contributions.getContributions()) {\r\n            contribution.registerFileSystemProviders(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dirty write prevention: if the file on disk has been changed and does not match our expected\r\n     * mtime and etag, we bail out to prevent dirty writing.\r\n     *\r\n     * First, we check for a mtime that is in the future before we do more checks. The assumption is\r\n     * that only the mtime is an indicator for a file that has changed on disk.\r\n     *\r\n     * Second, if the mtime has advanced, we compare the size of the file on disk with our previous\r\n     * one using the etag() function. Relying only on the mtime check has proven to produce false\r\n     * positives due to file system weirdness (especially around remote file systems). As such, the\r\n     * check for size is a weaker check because it can return a false negative if the file has changed\r\n     * but to the same length. This is a compromise we take to avoid having to produce checksums of\r\n     * the file content for comparison which would be much slower to compute.\r\n     */\r\n    protected modifiedSince(stat: Stat, options?: WriteFileOptions): boolean {\r\n        return !!options && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\r\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\r\n            options.mtime < stat.mtime && options.etag !== etag({\r\n                mtime: options.mtime /* not using stat.mtime for a reason, see above */,\r\n                size: stat.size\r\n            });\r\n    }\r\n\r\n    protected async getWriteEncoding(resource: URI, options?: WriteEncodingOptions): Promise<ResourceEncoding> {\r\n        const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\r\n        return this.encodingService.toResourceEncoding(encoding, {\r\n            overwriteEncoding: options?.overwriteEncoding,\r\n            read: async length => {\r\n                const buffer = await BinaryBufferReadableStream.toBuffer((await this.readFileStream(resource, {length})).value);\r\n                return buffer.buffer;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected async doCopy(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\r\n        const sourceProvider = await this.withReadProvider(source);\r\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\r\n\r\n        // copy\r\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\r\n\r\n        // resolve and send events\r\n        const fileStat = await this.resolve(target, {resolveMetadata: true});\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    protected async doMove(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\r\n        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\r\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\r\n\r\n        // move\r\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\r\n\r\n        // resolve and send events\r\n        const fileStat = await this.resolve(target, {resolveMetadata: true});\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    protected async doDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\r\n\r\n        // Validate trash support\r\n        const useTrash = !!options?.useTrash;\r\n        if (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\r\n            throw new Error(`Unable to delete file '${this.resourceForError(resource)}' via trash because provider does not support it.`);\r\n        }\r\n\r\n        // Validate delete\r\n        const exists = await this.exists(resource);\r\n        if (!exists) {\r\n            throw new FileOperationError(`Unable to delete non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\r\n        }\r\n\r\n        // Validate recursive\r\n        const recursive = !!options?.recursive;\r\n        if (!recursive && exists) {\r\n            const stat = await this.resolve(resource);\r\n            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\r\n                throw new Error(`Unable to delete non-empty folder '${this.resourceForError(resource)}'.`);\r\n            }\r\n        }\r\n\r\n        // Delete through provider\r\n        await provider.delete(resource, {recursive, useTrash});\r\n\r\n        // Events\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.DELETE));\r\n    }\r\n\r\n    protected async doCreate(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\r\n        const encoding = await this.getWriteEncoding(resource, options);\r\n        const encoded = await this.encodingService.encodeStream(value, encoding);\r\n        return this.createFile(resource, encoded, options);\r\n    }\r\n\r\n    protected rethrowAsFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): never {\r\n        throw this.asFileOperationError(message, resource, error, options);\r\n    }\r\n\r\n    protected asFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): FileOperationError {\r\n        const fileOperationError = new FileOperationError(`${message} '${this.resourceForError(resource)}' (${ensureFileSystemProviderError(error).toString()})`,\r\n            toFileOperationResult(error), options);\r\n        fileOperationError.stack = `${fileOperationError.stack}\\nCaused by: ${error.stack}`;\r\n        return fileOperationError;\r\n    }\r\n\r\n    protected throwIfFileSystemIsReadonly<T extends FileSystemProvider>(provider: T, resource: URI): T {\r\n        if (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\r\n            throw new FileOperationError(`Unable to modify readonly file`, FileOperationResult.FILE_PERMISSION_DENIED);\r\n        }\r\n\r\n        return provider;\r\n    }\r\n\r\n    protected async withProvider(resource: URI): Promise<FileSystemProvider> {\r\n        // Assert path is absolute\r\n        // if (!resource.path.isAbsolute) {\r\n        //     throw new FileOperationError(`Unable to resolve filesystem provider with relative file path`, FileOperationResult.FILE_INVALID_PATH);\r\n        // }\r\n\r\n        return this.activateProvider(resource.scheme);\r\n    }\r\n\r\n    protected async getEncodingForResource(resource: URI, preferredEncoding?: string): Promise<string> {\r\n        // resource = await this.toUnderlyingResource(resource);\r\n        return this.encodingRegistry.getEncodingForResource(resource, preferredEncoding);\r\n    }\r\n\r\n    protected getReadEncoding(resource: URI, options?: ReadEncodingOptions, detectedEncoding?: string): Promise<string> {\r\n        let preferredEncoding: string | undefined;\r\n\r\n        // Encoding passed in as option\r\n        if (options?.encoding) {\r\n            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {\r\n                preferredEncoding = UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\r\n            } else {\r\n                preferredEncoding = options.encoding; // give passed in encoding highest priority\r\n            }\r\n        } else if (detectedEncoding) {\r\n            preferredEncoding = detectedEncoding;\r\n        }\r\n\r\n        return this.getEncodingForResource(resource, preferredEncoding);\r\n    }\r\n\r\n    protected resolveReadOptions(options?: ReadTextFileOptions): ReadTextFileOptions {\r\n        options = {\r\n            ...options,\r\n            autoGuessEncoding: typeof options?.autoGuessEncoding === 'boolean' ? options.autoGuessEncoding : this.preferences['files.autoGuessEncoding']\r\n        };\r\n        const limits: Mutable<ReadTextFileOptions['limits']> = options.limits = options.limits || {};\r\n        if (typeof limits.size !== 'number') {\r\n            limits.size = this.preferences['files.maxFileSizeMB'] * 1024 * 1024;\r\n        }\r\n        return options;\r\n    }\r\n\r\n    private resourceForError(resource: URI): string {\r\n        return this.labelProvider.getLongName(resource);\r\n    }\r\n\r\n    private async doResolveFile(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\r\n\r\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat>;\r\n\r\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        const resolveTo = options?.resolveTo;\r\n        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\r\n        const resolveMetadata = options?.resolveMetadata;\r\n\r\n        const stat = await provider.stat(resource);\r\n\r\n        let trie: TernarySearchTree<URI, boolean> | undefined;\r\n\r\n        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\r\n\r\n            // lazy trie to check for recursive resolving\r\n            if (!trie) {\r\n                trie = TernarySearchTree.forUris<true>(!!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive));\r\n                trie.set(resource, true);\r\n                if (Array.isArray(resolveTo) && resolveTo.length) {\r\n                    resolveTo.forEach(uri => trie!.set(uri, true));\r\n                }\r\n            }\r\n\r\n            // check for recursive resolving\r\n            if (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\r\n                return true;\r\n            }\r\n\r\n            // check for resolving single child folders\r\n            if (stat.isDirectory && resolveSingleChildDescendants) {\r\n                return siblings === 1;\r\n            }\r\n\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat>;\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStatWithMetadata>;\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat> {\r\n        const fileStat = FileStat.fromStat(resource, stat);\r\n\r\n        // check to recurse for directories\r\n        if (fileStat.isDirectory && recurse(fileStat, siblings)) {\r\n            try {\r\n                const entries = await provider.readdir(resource);\r\n                const resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\r\n                    try {\r\n                        const childResource = resource.resolve(name);\r\n                        const childStat = resolveMetadata ? await provider.stat(childResource) : {type};\r\n\r\n                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\r\n                    } catch (error) {\r\n                        console.trace(error);\r\n\r\n                        return null; // can happen e.g. due to permission errors\r\n                    }\r\n                }));\r\n\r\n                // make sure to get rid of null values that signal a failure to resolve a particular entry\r\n                fileStat.children = resolvedEntries.filter(e => !!e) as FileStat[];\r\n            } catch (error) {\r\n                console.trace(error);\r\n\r\n                fileStat.children = []; // gracefully handle errors, we may not have permissions to read\r\n            }\r\n\r\n            return fileStat;\r\n        }\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    private async validateWriteFile(provider: FileSystemProvider, resource: URI, options?: WriteFileOptions): Promise<Stat | undefined> {\r\n        let stat: Stat | undefined = undefined;\r\n        try {\r\n            stat = await provider.stat(resource);\r\n        } catch (error) {\r\n            return undefined; // file might not exist\r\n        }\r\n\r\n        if (stat === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        // file cannot be directory\r\n        if ((stat.type & FileType.Directory) !== 0) {\r\n            throw new FileOperationError(`Unable to write file ${this.resourceForError(resource)} that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\r\n        }\r\n\r\n        if (this.modifiedSince(stat, options)) {\r\n            throw new FileOperationError('File Modified Since', FileOperationResult.FILE_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        return stat;\r\n    }\r\n\r\n    private async doMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\r\n        if (source.toString() === target.toString()) {\r\n            return mode; // simulate node.js behaviour here and do a no-op if paths match\r\n        }\r\n\r\n        // validation\r\n        const {\r\n            exists,\r\n            isSameResourceWithDifferentPathCase\r\n        } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\r\n\r\n        // if target exists get valid target\r\n        if (exists && !overwrite) {\r\n            const parent = await this.resolve(target.parent);\r\n            const name = isSameResourceWithDifferentPathCase ? target.path.name : target.path.name + '_copy';\r\n            target = FileSystemUtils.generateUniqueResourceURI(target.parent, parent, name, target.path.ext);\r\n        }\r\n\r\n        // delete as needed (unless target is same resource with different path case)\r\n        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {\r\n            await this.delete(target, {recursive: true});\r\n        }\r\n\r\n        // create parent folders\r\n        await this.mkdirp(targetProvider, target.parent);\r\n\r\n        // copy source => target\r\n        if (mode === 'copy') {\r\n\r\n            // same provider with fast copy: leverage copy() functionality\r\n            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\r\n                await sourceProvider.copy(source, target, {overwrite});\r\n            }\r\n\r\n                // when copying via buffer/unbuffered, we have to manually\r\n            // traverse the source if it is a folder and not a file\r\n            else {\r\n                const sourceFile = await this.resolve(source);\r\n                if (sourceFile.isDirectory) {\r\n                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\r\n                } else {\r\n                    await this.doCopyFile(sourceProvider, source, targetProvider, target);\r\n                }\r\n            }\r\n\r\n            return mode;\r\n        }\r\n\r\n        // move source => target\r\n        else {\r\n\r\n            // same provider: leverage rename() functionality\r\n            if (sourceProvider === targetProvider) {\r\n                await sourceProvider.rename(source, target, {overwrite});\r\n\r\n                return mode;\r\n            }\r\n\r\n            // across providers: copy to target & delete at source\r\n            else {\r\n                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\r\n\r\n                await this.delete(source, {recursive: true});\r\n\r\n                return 'copy';\r\n            }\r\n        }\r\n    }\r\n\r\n    private async doCopyFile(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI): Promise<void> {\r\n\r\n        // copy: source (buffered) => target (buffered)\r\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\r\n            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (buffered) => target (unbuffered)\r\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\r\n            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (unbuffered) => target (buffered)\r\n        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\r\n            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (unbuffered) => target (unbuffered)\r\n        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\r\n            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n    }\r\n\r\n    private async doPipeUnbuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeUnbufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n        return targetProvider.writeFile(target, await sourceProvider.readFile(source), {create: true, overwrite: true});\r\n    }\r\n\r\n    private async doCopyFolder(sourceProvider: FileSystemProvider, sourceFolder: FileStat, targetProvider: FileSystemProvider, targetFolder: URI): Promise<void> {\r\n\r\n        // create folder in target\r\n        await targetProvider.mkdir(targetFolder);\r\n\r\n        // create children in target\r\n        if (Array.isArray(sourceFolder.children)) {\r\n            await Promise.all(sourceFolder.children.map(async sourceChild => {\r\n                const targetChild = targetFolder.resolve(sourceChild.name);\r\n                if (sourceChild.isDirectory) {\r\n                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\r\n                } else {\r\n                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\r\n                }\r\n            }));\r\n        }\r\n    }\r\n\r\n    // #region File Watching\r\n\r\n    private async doValidateMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean }> {\r\n        let isSameResourceWithDifferentPathCase = false;\r\n\r\n        // Check if source is equal or parent to target (requires providers to be the same)\r\n        if (sourceProvider === targetProvider) {\r\n            const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n            if (!isPathCaseSensitive) {\r\n                isSameResourceWithDifferentPathCase = source.toString().toLowerCase() === target.toString().toLowerCase();\r\n            }\r\n\r\n            if (isSameResourceWithDifferentPathCase && mode === 'copy') {\r\n                throw new Error(`Unable to copy when source '${this.resourceForError(source)}' is same as target '${this.resourceForError(target)}' with different path case on a case insensitive file system`);\r\n            }\r\n\r\n            if (!isSameResourceWithDifferentPathCase && target.isEqualOrParent(source, isPathCaseSensitive)) {\r\n                throw new Error(`Unable to move/copy when source '${this.resourceForError(source)}' is parent of target '${this.resourceForError(target)}'.`);\r\n            }\r\n        }\r\n\r\n        // Extra checks if target exists and this is not a rename\r\n        const exists = await this.exists(target);\r\n        if (exists && !isSameResourceWithDifferentPathCase) {\r\n\r\n            // Special case: if the target is a parent of the source, we cannot delete\r\n            // it as it would delete the source as well. In this case we have to throw\r\n            if (sourceProvider === targetProvider) {\r\n                const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n                if (source.isEqualOrParent(target, isPathCaseSensitive)) {\r\n                    throw new Error(`Unable to move/copy '${this.resourceForError(source)}' into '${this.resourceForError(target)}' since a file would replace the folder it is contained in.`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {exists, isSameResourceWithDifferentPathCase};\r\n    }\r\n\r\n    private async doWriteBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, readableOrStreamOrBufferedStream: BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        return this.ensureWriteQueue(provider, resource, async () => {\r\n\r\n            // open handle\r\n            const handle = await provider.open(resource, {create: true});\r\n\r\n            // write into handle until all bytes from buffer have been written\r\n            try {\r\n                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\r\n                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\r\n                } else {\r\n                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\r\n                }\r\n            } catch (error) {\r\n                throw ensureFileSystemProviderError(error);\r\n            } finally {\r\n\r\n                // close handle always\r\n                await provider.close(handle);\r\n            }\r\n        });\r\n    }\r\n\r\n    private async doWriteStreamBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        let posInFile = 0;\r\n        let stream: BinaryBufferReadableStream;\r\n\r\n        // Buffered stream: consume the buffer first by writing\r\n        // it to the target before reading from the stream.\r\n        if (isReadableBufferedStream(streamOrBufferedStream)) {\r\n            if (streamOrBufferedStream.buffer.length > 0) {\r\n                const chunk = BinaryBuffer.concat(streamOrBufferedStream.buffer);\r\n                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n\r\n                posInFile += chunk.byteLength;\r\n            }\r\n\r\n            // If the stream has been consumed, return early\r\n            if (streamOrBufferedStream.ended) {\r\n                return;\r\n            }\r\n\r\n            stream = streamOrBufferedStream.stream;\r\n        }\r\n\r\n        // Unbuffered stream - just take as is\r\n        else {\r\n            stream = streamOrBufferedStream;\r\n        }\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n\r\n            stream.on('data', async chunk => {\r\n\r\n                // pause stream to perform async write operation\r\n                stream.pause();\r\n\r\n                try {\r\n                    await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n                } catch (error) {\r\n                    return reject(error);\r\n                }\r\n\r\n                posInFile += chunk.byteLength;\r\n\r\n                // resume stream now that we have successfully written\r\n                // run this on the next tick to prevent increasing the\r\n                // execution stack because resume() may call the event\r\n                // handler again before finishing.\r\n                setTimeout(() => stream.resume());\r\n            });\r\n\r\n            stream.on('error', error => reject(error));\r\n            stream.on('end', () => resolve());\r\n        });\r\n    }\r\n\r\n    private async doWriteReadableBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: BinaryBufferReadable): Promise<void> {\r\n        let posInFile = 0;\r\n\r\n        let chunk: BinaryBuffer | null;\r\n        while ((chunk = readable.read()) !== null) {\r\n            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n\r\n            posInFile += chunk.byteLength;\r\n        }\r\n    }\r\n\r\n    private async doWriteBuffer(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: BinaryBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\r\n        let totalBytesWritten = 0;\r\n        while (totalBytesWritten < length) {\r\n            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\r\n            totalBytesWritten += bytesWritten;\r\n        }\r\n    }\r\n\r\n    private async doWriteUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        return this.ensureWriteQueue(provider, resource, () => this.doWriteUnbufferedQueued(provider, resource, bufferOrReadableOrStreamOrBufferedStream));\r\n    }\r\n\r\n    private async doPipeBuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeBufferedQueued(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        let sourceHandle: number | undefined = undefined;\r\n        let targetHandle: number | undefined = undefined;\r\n\r\n        try {\r\n\r\n            // Open handles\r\n            sourceHandle = await sourceProvider.open(source, {create: false});\r\n            targetHandle = await targetProvider.open(target, {create: true});\r\n\r\n            const buffer = BinaryBuffer.alloc(this.BUFFER_SIZE);\r\n\r\n            let posInFile = 0;\r\n            let posInBuffer = 0;\r\n            let bytesRead = 0;\r\n            do {\r\n                // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\r\n                // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\r\n                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\r\n\r\n                // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\r\n                // buffer position (posInBuffer) all bytes we read (bytesRead).\r\n                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\r\n\r\n                posInFile += bytesRead;\r\n                posInBuffer += bytesRead;\r\n\r\n                // when buffer full, fill it again from the beginning\r\n                if (posInBuffer === buffer.byteLength) {\r\n                    posInBuffer = 0;\r\n                }\r\n            } while (bytesRead > 0);\r\n        } catch (error) {\r\n            throw ensureFileSystemProviderError(error);\r\n        } finally {\r\n            await Promise.all([\r\n                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\r\n                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\r\n            ]);\r\n        }\r\n    }\r\n\r\n    private async doWriteUnbufferedQueued(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        let buffer: BinaryBuffer;\r\n        if (bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer) {\r\n            buffer = bufferOrReadableOrStreamOrBufferedStream;\r\n        } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\r\n            buffer = await BinaryBufferReadableStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\r\n            buffer = await BinaryBufferReadableBufferedStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        } else {\r\n            buffer = BinaryBufferReadable.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        }\r\n\r\n        return provider.writeFile(resource, buffer.buffer, {create: true, overwrite: true});\r\n    }\r\n\r\n    private async doPipeUnbufferedToBuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeUnbufferedToBufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n\r\n        // Open handle\r\n        const targetHandle = await targetProvider.open(target, {create: true});\r\n\r\n        // Read entire buffer from source and write buffered\r\n        try {\r\n            const buffer = await sourceProvider.readFile(source);\r\n            await this.doWriteBuffer(targetProvider, targetHandle, BinaryBuffer.wrap(buffer), buffer.byteLength, 0, 0);\r\n        } catch (error) {\r\n            throw ensureFileSystemProviderError(error);\r\n        } finally {\r\n            await targetProvider.close(targetHandle);\r\n        }\r\n    }\r\n\r\n    private async doPipeBufferedToUnbuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n\r\n        // Read buffer via stream buffered\r\n        const buffer = await BinaryBufferReadableStream.toBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\r\n\r\n        // Write buffer into target at once\r\n        await this.doWriteUnbuffered(targetProvider, target, buffer);\r\n    }\r\n\r\n    private ensureWriteQueue(provider: FileSystemProvider, resource: URI, task: () => Promise<void>): Promise<void> {\r\n        // ensure to never write to the same resource without finishing\r\n        // the one write. this ensures a write finishes consistently\r\n        // (even with error) before another write is done.\r\n        const queueKey = this.toMapKey(provider, resource);\r\n        const writeQueue = (this.writeQueues.get(queueKey) || Promise.resolve()).then(task, task);\r\n        this.writeQueues.set(queueKey, writeQueue);\r\n        return writeQueue;\r\n    }\r\n\r\n    private async mkdirp(provider: FileSystemProvider, directory: URI): Promise<void> {\r\n        const directoriesToCreate: string[] = [];\r\n\r\n        // mkdir until we reach root\r\n        while (!directory.path.isRoot) {\r\n            try {\r\n                const stat = await provider.stat(directory);\r\n                if (stat === undefined) {\r\n                    // Upon error, remember directories that need to be created\r\n                    directoriesToCreate.push(directory.path.base);\r\n\r\n                    // Continue up\r\n                    directory = directory.parent;\r\n                    break;\r\n                }\r\n                if ((stat.type & FileType.Directory) === 0) {\r\n                    throw new Error(`Unable to create folder ${this.resourceForError(directory)} that already exists but is not a directory`);\r\n                }\r\n\r\n                break; // we have hit a directory that exists -> good\r\n            } catch (error) {\r\n\r\n                // Bubble up any other error that is not file not found\r\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\r\n                    throw error;\r\n                }\r\n\r\n                // Upon error, remember directories that need to be created\r\n                directoriesToCreate.push(directory.path.base);\r\n\r\n                // Continue up\r\n                directory = directory.parent;\r\n            }\r\n        }\r\n\r\n        // Create directories as needed\r\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\r\n            directory = directory.resolve(directoriesToCreate[i]);\r\n\r\n            try {\r\n                await provider.mkdir(directory);\r\n            } catch (error) {\r\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\r\n                    // For mkdirp() we tolerate that the mkdir() call fails\r\n                    // in case the folder already exists. This follows node.js\r\n                    // own implementation of fs.mkdir({ recursive: true }) and\r\n                    // reduces the chances of race conditions leading to errors\r\n                    // if multiple calls try to create the same folders\r\n                    // As such, we only throw an error here if it is other than\r\n                    // the fact that the file already exists.\r\n                    // (see also https://github.com/microsoft/vscode/issues/89834)\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async withWriteProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\r\n        const provider = await this.withProvider(resource);\r\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\r\n            return provider;\r\n        }\r\n\r\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\r\n    }\r\n\r\n    private toWatchKey(provider: FileSystemProvider, resource: URI, options: WatchOptions): string {\r\n        return [\r\n            this.toMapKey(provider, resource),  // lowercase path if the provider is case insensitive\r\n            String(options.recursive),          // use recursive: true | false as part of the key\r\n            options.excludes.join()             // use excludes as part of the key\r\n        ].join();\r\n    }\r\n\r\n    private toMapKey(provider: FileSystemProvider, resource: URI): string {\r\n        const isPathCaseSensitive = !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n\r\n        return isPathCaseSensitive ? resource.toString() : resource.toString().toLowerCase();\r\n    }\r\n\r\n    private async doRead(resource: URI, options?: ReadTextFileOptions & { preferUnbuffered?: boolean }): Promise<[FileStreamContent, DecodeStreamResult]> {\r\n        options = this.resolveReadOptions(options);\r\n\r\n        // read stream raw (either buffered or unbuffered)\r\n        let bufferStream: FileStreamContent;\r\n        if (options?.preferUnbuffered) {\r\n            const content = await this.readFile(resource, options);\r\n            bufferStream = {\r\n                ...content,\r\n                value: BinaryBufferReadableStream.fromBuffer(content.value)\r\n            };\r\n        } else {\r\n            bufferStream = await this.readFileStream(resource, options);\r\n        }\r\n\r\n        const decoder = await this.encodingService.decodeStream(bufferStream.value, {\r\n            guessEncoding: options.autoGuessEncoding,\r\n            overwriteEncoding: detectedEncoding => this.getReadEncoding(resource, options, detectedEncoding)\r\n        });\r\n\r\n        // validate binary\r\n        if (options?.acceptTextOnly && decoder.detected.seemsBinary) {\r\n            throw new TextFileOperationError('File seems to be binary and cannot be opened as text', TextFileOperationResult.FILE_IS_BINARY, options);\r\n        }\r\n\r\n        return [bufferStream, decoder];\r\n    }\r\n\r\n    private validateReadFileLimits(resource: URI, size: number, options?: ReadFileOptions): void {\r\n        if (options?.limits) {\r\n            let tooLargeErrorResult: FileOperationResult | undefined = undefined;\r\n\r\n            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {\r\n                tooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\r\n            }\r\n\r\n            if (typeof options.limits.size === 'number' && size > options.limits.size) {\r\n                tooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\r\n            }\r\n\r\n            if (typeof tooLargeErrorResult === 'number') {\r\n                throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is too large to open`, tooLargeErrorResult);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async validateReadFile(resource: URI, options?: ReadFileOptions): Promise<FileStatWithMetadata> {\r\n        const stat = await this.resolve(resource, {resolveMetadata: true});\r\n\r\n        // Throw if resource is a directory\r\n        if (stat.isDirectory) {\r\n            throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\r\n        }\r\n\r\n        // Throw if file not modified since (unless disabled)\r\n        if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\r\n            throw new FileOperationError('File not modified since', FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        // Throw if file is too large to load\r\n        this.validateReadFileLimits(resource, stat.size, options);\r\n\r\n        return stat;\r\n    }\r\n\r\n    private async readFileStreamed(provider: FileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): Promise<BinaryBufferReadableStream> {\r\n        const fileStream = await provider.readFileStream(resource, options, token);\r\n\r\n        return Promise.resolve(\r\n            transform(fileStream, {\r\n                data: data => data instanceof BinaryBuffer ? data : BinaryBuffer.wrap(data),\r\n                error: error => this.asFileOperationError('Unable to read file', resource, error, options)\r\n            }, data => BinaryBuffer.concat(data))\r\n        );\r\n    }\r\n\r\n    private async readFileUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, options?: ReadFileOptions): Promise<BinaryBufferReadableStream> {\r\n        let buffer = await provider.readFile(resource);\r\n\r\n        // respect position option\r\n        if (options && typeof options.position === 'number') {\r\n            buffer = buffer.slice(options.position);\r\n        }\r\n\r\n        // respect length option\r\n        if (options && typeof options.length === 'number') {\r\n            buffer = buffer.slice(0, options.length);\r\n        }\r\n\r\n        // Throw if file is too large to load\r\n        this.validateReadFileLimits(resource, buffer.byteLength, options);\r\n\r\n        return BinaryBufferReadableStream.fromBuffer(BinaryBuffer.wrap(buffer));\r\n    }\r\n\r\n    private readFileBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\r\n        const stream = BinaryBufferWriteableStream.create();\r\n\r\n        readFileIntoStream(provider, resource, stream, data => data, {\r\n            ...options,\r\n            bufferSize: this.BUFFER_SIZE,\r\n            errorTransformer: error => this.asFileOperationError('Unable to read file', resource, error, options)\r\n        }, token);\r\n\r\n        return stream;\r\n    }\r\n\r\n    private async doReadAsFileStream(provider: FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options?: ReadFileOptions & { preferUnbuffered?: boolean }): Promise<FileStreamContent> {\r\n\r\n        // install a cancellation token that gets cancelled\r\n        // when any error occurs. this allows us to resolve\r\n        // the content of the file while resolving metadata\r\n        // but still cancel the operation in certain cases.\r\n        const cancellableSource = new CancellationTokenSource();\r\n\r\n        // validate read operation\r\n        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\r\n            cancellableSource.cancel();\r\n\r\n            throw error;\r\n        });\r\n\r\n        try {\r\n\r\n            // if the etag is provided, we await the result of the validation\r\n            // due to the likelyhood of hitting a NOT_MODIFIED_SINCE result.\r\n            // otherwise, we let it run in parallel to the file reading for\r\n            // optimal startup performance.\r\n            if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\r\n                await statPromise;\r\n            }\r\n\r\n            let fileStreamPromise: Promise<BinaryBufferReadableStream>;\r\n\r\n            // read unbuffered (only if either preferred, or the provider has no buffered read capability)\r\n            if (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\r\n                fileStreamPromise = this.readFileUnbuffered(provider, resource, options);\r\n            }\r\n\r\n            // read streamed (always prefer over primitive buffered read)\r\n            else if (hasFileReadStreamCapability(provider)) {\r\n                fileStreamPromise = Promise.resolve(this.readFileStreamed(provider, resource, cancellableSource.token, options));\r\n            }\r\n\r\n            // read buffered\r\n            else {\r\n                fileStreamPromise = Promise.resolve(this.readFileBuffered(provider, resource, cancellableSource.token, options));\r\n            }\r\n\r\n            const [fileStat, fileStream] = await Promise.all([statPromise, fileStreamPromise]);\r\n\r\n            return {\r\n                ...fileStat,\r\n                value: fileStream\r\n            };\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to read file', resource, error, options);\r\n        }\r\n    }\r\n\r\n    private async withReadProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\r\n            return provider;\r\n        }\r\n\r\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\r\n    }\r\n\r\n\r\n    protected async useLocalFileSystem(): Promise<any> {\r\n        const provider = await this.activateProvider('file');\r\n        // @ts-ignore\r\n        provider.useLocal();\r\n    }\r\n    /**\r\n     * Converts to an underlying fs provider resource format.\r\n     *\r\n     * For example converting `user-storage` resources to `file` resources under a user home:\r\n     * user-storage:/user/settings.json => file://home/.tart/settings.json\r\n     */\r\n    // async toUnderlyingResource(resource: URI): Promise<URI> {\r\n    //     let provider = await this.withProvider(resource);\r\n    //     while (provider instanceof DelegatingFileSystemProvider) {\r\n    //         resource = provider.toUnderlyingResource(resource);\r\n    //         provider = await this.withProvider(resource);\r\n    //     }\r\n    //     return resource;\r\n    // }\r\n\r\n    // protected handleFileWatchError(): void {\r\n    //     this.watcherErrorHandler.handleError();\r\n    // }\r\n}\r\n"]}