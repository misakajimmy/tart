{"version":3,"sources":["browser/location/loaction-render.tsx"],"names":[],"mappings":"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","file":"../../../src/browser/location/loaction-render.d.ts","sourcesContent":["import * as React from 'react';\r\nimport * as ReactDOM from 'react-dom';\r\nimport {DisposableCollection, Emitter, Path} from '@tart/core/lib/common';\r\nimport {FileService} from '../file-service';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {inject, injectable, postConstruct} from 'inversify';\r\nimport {codicon, ReactRenderer} from '@tart/core';\r\nimport {FileDialogModel} from '../file-dialog/file-dialog-model';\r\nimport {LocationService} from './locaion-service';\r\n\r\ninterface AutoSuggestDataEvent {\r\n    parent: string;\r\n    children: string[];\r\n}\r\n\r\nclass ResolvedDirectoryCache {\r\n    protected pendingResolvedDirectories = new Map<string, Promise<void>>();\r\n    protected cachedDirectories = new Map<string, string[]>();\r\n\r\n    protected directoryResolvedEmitter = new Emitter<AutoSuggestDataEvent>();\r\n    readonly onDirectoryDidResolve = this.directoryResolvedEmitter.event;\r\n\r\n    constructor(protected readonly fileService: FileService) {\r\n    }\r\n\r\n    tryResolveChildDirectories(inputAsURI: URI): string[] | undefined {\r\n        const parentDirectory = inputAsURI.path.dir.toString();\r\n        const cachedDirectories = this.cachedDirectories.get(parentDirectory);\r\n        const pendingDirectories = this.pendingResolvedDirectories.get(parentDirectory);\r\n        if (cachedDirectories) {\r\n            return cachedDirectories;\r\n        } else if (!pendingDirectories) {\r\n            this.pendingResolvedDirectories.set(parentDirectory, this.createResolutionPromise(parentDirectory));\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected async createResolutionPromise(directoryToResolve: string): Promise<void> {\r\n        return this.fileService.resolve(new URI(directoryToResolve)).then(({children}) => {\r\n            if (children) {\r\n                const childDirectories = children.filter(child => child.isDirectory)\r\n                    .map(directory => `${directory.resource.path}/`);\r\n                this.cachedDirectories.set(directoryToResolve, childDirectories);\r\n                this.directoryResolvedEmitter.fire({parent: directoryToResolve, children: childDirectories});\r\n            }\r\n        }).catch(e => {\r\n            // no-op\r\n        });\r\n    }\r\n}\r\n\r\nexport const LocationListRendererFactory = Symbol('LocationListRendererFactory');\r\n\r\nexport interface LocationListRendererFactory {\r\n    (options: LocationListRendererOptions): LocationListRenderer;\r\n}\r\n\r\nexport const LocationListRendererOptions = Symbol('LocationListRendererOptions');\r\n\r\nexport interface LocationListRendererOptions {\r\n    model: FileDialogModel;\r\n    host?: HTMLElement;\r\n}\r\n\r\n@injectable()\r\nexport class LocationListRenderer extends ReactRenderer {\r\n\r\n    @inject(FileService) protected readonly fileService: FileService;\r\n\r\n    protected directoryCache: ResolvedDirectoryCache;\r\n    protected service: LocationService;\r\n    protected toDisposeOnNewCache = new DisposableCollection();\r\n    protected _drives: URI[] | undefined;\r\n    protected homeDir: string;\r\n    protected lastUniqueTextInputLocation: URI | undefined;\r\n    protected previousAutocompleteMatch: string;\r\n    protected doAttemptAutocomplete = true;\r\n\r\n    constructor(\r\n        @inject(LocationListRendererOptions) readonly options: LocationListRendererOptions\r\n    ) {\r\n        super(options.host);\r\n        this.service = options.model;\r\n        this.doLoadDrives();\r\n    }\r\n\r\n    protected _doShowTextInput = false;\r\n\r\n    get doShowTextInput(): boolean {\r\n        return this._doShowTextInput;\r\n    }\r\n\r\n    set doShowTextInput(doShow: boolean) {\r\n        this._doShowTextInput = doShow;\r\n        if (doShow) {\r\n            this.initResolveDirectoryCache();\r\n        }\r\n    }\r\n\r\n    get locationList(): HTMLSelectElement | undefined {\r\n        const locationList = this.host.getElementsByClassName(LocationListRenderer.Styles.LOCATION_LIST_CLASS)[0];\r\n        if (locationList instanceof HTMLSelectElement) {\r\n            return locationList;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get locationTextInput(): HTMLInputElement | undefined {\r\n        const locationTextInput = this.host.getElementsByClassName(LocationListRenderer.Styles.LOCATION_TEXT_INPUT_CLASS)[0];\r\n        if (locationTextInput instanceof HTMLInputElement) {\r\n            return locationTextInput;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    @postConstruct()\r\n    async init(): Promise<void> {\r\n        // const homeDirWithPrefix = await this.variablesServer.getHomeDirUri();\r\n        // this.homeDir = (new URI(homeDirWithPrefix)).path.toString();\r\n        this.homeDir = (new URI()).path.toString();\r\n    }\r\n\r\n    render(): void {\r\n        ReactDOM.render(this.doRender(), this.host, this.doAfterRender);\r\n    }\r\n\r\n    dispose(): void {\r\n        super.dispose();\r\n        this.toDisposeOnNewCache.dispose();\r\n    }\r\n\r\n    protected initResolveDirectoryCache(): void {\r\n        this.toDisposeOnNewCache.dispose();\r\n        this.directoryCache = new ResolvedDirectoryCache(this.fileService);\r\n        this.toDisposeOnNewCache.push(this.directoryCache.onDirectoryDidResolve(({parent, children}) => {\r\n            if (this.locationTextInput) {\r\n                const expandedPath = Path.untildify(this.locationTextInput.value, this.homeDir);\r\n                const inputParent = (new URI(expandedPath)).path.dir.toString();\r\n                if (inputParent === parent) {\r\n                    this.tryRenderFirstMatch(this.locationTextInput, children);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n\r\n    protected doAfterRender = (): void => {\r\n        const locationList = this.locationList;\r\n        const locationListTextInput = this.locationTextInput;\r\n        if (locationList) {\r\n            const currentLocation = this.service.location;\r\n            locationList.value = currentLocation ? currentLocation.toString() : '';\r\n        } else if (locationListTextInput) {\r\n            locationListTextInput.focus();\r\n        }\r\n    };\r\n\r\n    protected readonly handleLocationChanged = (e: React.ChangeEvent<HTMLSelectElement>) => this.onLocationChanged(e);\r\n\r\n    protected readonly handleTextInputOnChange = (e: React.ChangeEvent<HTMLInputElement>) => this.trySuggestDirectory(e);\r\n\r\n    protected readonly handleTextInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => this.handleControlKeys(e);\r\n\r\n    protected readonly handleIconKeyDown = (e: React.KeyboardEvent<HTMLSpanElement>) => this.toggleInputOnKeyDown(e);\r\n\r\n    protected readonly handleTextInputOnBlur = () => this.toggleToSelectInput();\r\n\r\n    protected readonly handleTextInputMouseDown = (e: React.MouseEvent<HTMLSpanElement>) => this.toggleToTextInputOnMouseDown(e);\r\n\r\n    protected doRender(): React.ReactElement {\r\n        return (\r\n            <>\r\n                {this.renderInputIcon()}\r\n                {this.doShowTextInput\r\n                    ? this.renderTextInput()\r\n                    : this.renderSelectInput()\r\n                }\r\n            </>\r\n        );\r\n    }\r\n\r\n    protected renderInputIcon(): React.ReactNode {\r\n        return (\r\n            <span\r\n                // onMouseDown is used since it will fire before 'onBlur'. This prevents\r\n                // a re-render when textinput is in focus and user clicks toggle icon\r\n                onMouseDown={this.handleTextInputMouseDown}\r\n                onKeyDown={this.handleIconKeyDown}\r\n                className={LocationListRenderer.Styles.LOCATION_INPUT_TOGGLE_CLASS}\r\n                tabIndex={0}\r\n                id={`${this.doShowTextInput ? 'text-input' : 'select-input'}`}\r\n                title={this.doShowTextInput\r\n                    ? LocationListRenderer.Tooltips.TOGGLE_SELECT_INPUT\r\n                    : LocationListRenderer.Tooltips.TOGGLE_TEXT_INPUT}\r\n            >\r\n                <i className={codicon(this.doShowTextInput ? 'folder-opened' : 'edit')}/>\r\n            </span>\r\n        );\r\n    }\r\n\r\n    protected renderTextInput(): React.ReactNode {\r\n        return (\r\n            <input className={'tart-select ' + LocationListRenderer.Styles.LOCATION_TEXT_INPUT_CLASS}\r\n                   defaultValue={this.service.location?.path.toString()}\r\n                   onBlur={this.handleTextInputOnBlur}\r\n                   onChange={this.handleTextInputOnChange}\r\n                   onKeyDown={this.handleTextInputKeyDown}\r\n                   spellCheck={false}\r\n            />\r\n        );\r\n    }\r\n\r\n    protected renderSelectInput(): React.ReactNode {\r\n        const options = this.collectLocations().map(value => this.renderLocation(value));\r\n        return (\r\n            <select className={`tart-select ${LocationListRenderer.Styles.LOCATION_LIST_CLASS}`}\r\n                    onChange={this.handleLocationChanged}>\r\n                {...options}\r\n            </select>\r\n        );\r\n    }\r\n\r\n    protected toggleInputOnKeyDown(e: React.KeyboardEvent<HTMLSpanElement>): void {\r\n        if (e.key === 'Enter') {\r\n            this.doShowTextInput = true;\r\n            this.render();\r\n        }\r\n    }\r\n\r\n    protected toggleToTextInputOnMouseDown(e: React.MouseEvent<HTMLSpanElement>): void {\r\n        if (e.currentTarget.id === 'select-input') {\r\n            e.preventDefault();\r\n            this.doShowTextInput = true;\r\n            this.render();\r\n        }\r\n    }\r\n\r\n    protected toggleToSelectInput(): void {\r\n        if (this.doShowTextInput) {\r\n            this.doShowTextInput = false;\r\n            this.render();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects the available locations based on the currently selected, and appends the available drives to it.\r\n     */\r\n    protected collectLocations(): LocationListRenderer.Location[] {\r\n        const location = this.service.location;\r\n        const locations: LocationListRenderer.Location[] = (!!location ? location.allLocations : []).map(uri => ({uri}));\r\n        if (this._drives) {\r\n            const drives = this._drives.map(uri => ({uri, isDrive: true}));\r\n            // `URI.allLocations` returns with the URI without the trailing slash unlike `FileUri.create(fsPath)`.\r\n            // to be able to compare file:///path/to/resource with file:///path/to/resource/.\r\n            const toUriString = (uri: URI) => {\r\n                const toString = uri.toString();\r\n                return toString.endsWith('/') ? toString.slice(0, -1) : toString;\r\n            };\r\n            drives.forEach(drive => {\r\n                const index = locations.findIndex(loc => toUriString(loc.uri) === toUriString(drive.uri));\r\n                // Ignore drives which are already discovered as a location based on the current model root URI.\r\n                if (index === -1) {\r\n                    // Make sure, it does not have the trailing slash.\r\n                    locations.push({uri: new URI(toUriString(drive.uri)), isDrive: true});\r\n                } else {\r\n                    // This is necessary for Windows to be able to show `/e:/` as a drive and `c:` as \"non-drive\" in the same way.\r\n                    // `URI.path.toString()` Vs. `URI.displayName` behaves a bit differently on Windows.\r\n                    // https://github.com/eclipse-tart/tart/pull/3038#issuecomment-425944189\r\n                    locations[index].isDrive = true;\r\n                }\r\n            });\r\n        }\r\n        this.doLoadDrives();\r\n        return locations;\r\n    }\r\n\r\n    /**\r\n     * Asynchronously loads the drives (if not yet available) and triggers a UI update on success with the new values.\r\n     */\r\n    protected doLoadDrives(): void {\r\n        if (!this._drives) {\r\n            this.service.drives().then(drives => {\r\n                // If the `drives` are empty, something already went wrong.\r\n                if (drives.length > 0) {\r\n                    this._drives = drives;\r\n                    this.render();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected renderLocation(location: LocationListRenderer.Location): React.ReactNode {\r\n        const {uri, isDrive} = location;\r\n        const value = uri.toString();\r\n        return <option value={value} key={uri.toString()}>{isDrive ? uri.path.toString() : uri.displayName}</option>;\r\n    }\r\n\r\n    protected onLocationChanged(e: React.ChangeEvent<HTMLSelectElement>): void {\r\n        const locationList = this.locationList;\r\n        if (locationList) {\r\n            const value = locationList.value;\r\n            const uri = new URI(value);\r\n            this.trySetNewLocation(uri);\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        }\r\n    }\r\n\r\n    protected trySetNewLocation(newLocation: URI): void {\r\n        if (this.lastUniqueTextInputLocation === undefined) {\r\n            this.lastUniqueTextInputLocation = this.service.location;\r\n        }\r\n        // prevent consecutive repeated locations from being added to location history\r\n        if (this.lastUniqueTextInputLocation?.path.toString() !== newLocation.path.toString()) {\r\n            this.lastUniqueTextInputLocation = newLocation;\r\n            this.service.location = newLocation;\r\n        }\r\n    }\r\n\r\n    protected trySuggestDirectory(e: React.ChangeEvent<HTMLInputElement>): void {\r\n        if (this.doAttemptAutocomplete) {\r\n            const inputElement = e.currentTarget;\r\n            const {value} = inputElement;\r\n            if ((value.startsWith('/') || value.startsWith('~/')) && value.slice(-1) !== '/') {\r\n                const expandedPath = Path.untildify(value, this.homeDir);\r\n                const valueAsURI = new URI(expandedPath);\r\n                const autocompleteDirectories = this.directoryCache.tryResolveChildDirectories(valueAsURI);\r\n                if (autocompleteDirectories) {\r\n                    this.tryRenderFirstMatch(inputElement, autocompleteDirectories);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected tryRenderFirstMatch(inputElement: HTMLInputElement, children: string[]): void {\r\n        const {value, selectionStart} = inputElement;\r\n        if (this.locationTextInput) {\r\n            const expandedPath = Path.untildify(value, this.homeDir);\r\n            const firstMatch = children?.find(child => child.includes(expandedPath));\r\n            if (firstMatch) {\r\n                const contractedPath = value.startsWith('~') ? Path.tildify(firstMatch, this.homeDir) : firstMatch;\r\n                this.locationTextInput.value = contractedPath;\r\n                this.locationTextInput.selectionStart = selectionStart;\r\n                this.locationTextInput.selectionEnd = firstMatch.length;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected handleControlKeys(e: React.KeyboardEvent<HTMLInputElement>): void {\r\n        this.doAttemptAutocomplete = e.key !== 'Backspace';\r\n        if (e.key === 'Enter') {\r\n            const locationTextInput = this.locationTextInput;\r\n            if (locationTextInput) {\r\n                // expand '~' if present and remove extra whitespace and any trailing slashes or periods.\r\n                const sanitizedInput = locationTextInput.value.trim().replace(/[\\/\\\\.]*$/, '');\r\n                const untildifiedInput = Path.untildify(sanitizedInput, this.homeDir);\r\n                const uri = new URI(untildifiedInput);\r\n                this.trySetNewLocation(uri);\r\n                this.toggleToSelectInput();\r\n            }\r\n        } else if (e.key === 'Escape') {\r\n            this.toggleToSelectInput();\r\n        } else if (e.key === 'Tab') {\r\n            e.preventDefault();\r\n            const textInput = this.locationTextInput;\r\n            if (textInput) {\r\n                textInput.selectionStart = textInput.value.length;\r\n            }\r\n        }\r\n        e.stopPropagation();\r\n    }\r\n}\r\n\r\nexport namespace LocationListRenderer {\r\n\r\n    export namespace Styles {\r\n        export const LOCATION_LIST_CLASS = 'tart-LocationList';\r\n        export const LOCATION_INPUT_TOGGLE_CLASS = 'tart-LocationInputToggle';\r\n        export const LOCATION_TEXT_INPUT_CLASS = 'tart-LocationTextInput';\r\n    }\r\n\r\n    export namespace Tooltips {\r\n        export const TOGGLE_TEXT_INPUT = 'Switch to text-based input';\r\n        export const TOGGLE_SELECT_INPUT = 'Switch to location list';\r\n    }\r\n\r\n    export interface Location {\r\n        uri: URI;\r\n        isDrive?: boolean;\r\n    }\r\n\r\n}\r\n"]}