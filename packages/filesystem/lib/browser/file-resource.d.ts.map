{"version":3,"sources":["browser/file-resource.ts"],"names":[],"mappings":"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","file":"../../src/browser/file-resource.d.ts","sourcesContent":["import {\r\n    DisposableCollection,\r\n    Emitter,\r\n    Event,\r\n    Resource,\r\n    ResourceError,\r\n    ResourceResolver,\r\n    ResourceSaveOptions,\r\n    ResourceVersion\r\n} from '@tart/core/lib/common';\r\nimport {inject, injectable} from 'inversify';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {FileService, TextFileOperationError, TextFileOperationResult} from './file-service';\r\nimport {\r\n    BinarySize,\r\n    ETAG_DISABLED,\r\n    FileOperation,\r\n    FileOperationError,\r\n    FileOperationResult,\r\n    FileReadStreamOptions,\r\n    FileSystemProviderCapabilities\r\n} from '../common/files';\r\nimport {ConfirmDialog, LabelProvider} from '@tart/core';\r\nimport {GENERAL_MAX_FILE_SIZE_MB} from './filesystem-preferences';\r\nimport {Readable, ReadableStream} from '@tart/core/lib/common/stream';\r\n\r\nexport interface FileResourceVersion extends ResourceVersion {\r\n    readonly encoding: string;\r\n    readonly mtime: number;\r\n    readonly etag: string;\r\n}\r\n\r\nexport namespace FileResourceVersion {\r\n    export function is(version: ResourceVersion | undefined): version is FileResourceVersion {\r\n        return !!version && 'encoding' in version && 'mtime' in version && 'etag' in version;\r\n    }\r\n}\r\n\r\nexport interface FileResourceOptions {\r\n    shouldOverwrite: () => Promise<boolean>\r\n    shouldOpenAsText: (error: string) => Promise<boolean>\r\n}\r\n\r\nexport class FileResource implements Resource {\r\n\r\n    saveContentChanges?: Resource['saveContentChanges'];\r\n    protected acceptTextOnly = true;\r\n    protected limits: FileReadStreamOptions['limits'];\r\n    protected readonly toDispose = new DisposableCollection();\r\n    protected readonly onDidChangeContentsEmitter = new Emitter<void>();\r\n    readonly onDidChangeContents: Event<void> = this.onDidChangeContentsEmitter.event;\r\n\r\n    constructor(\r\n        readonly uri: URI,\r\n        protected readonly fileService: FileService,\r\n        protected readonly options: FileResourceOptions\r\n    ) {\r\n        this.toDispose.push(this.onDidChangeContentsEmitter);\r\n        this.toDispose.push(this.fileService.onDidFilesChange(event => {\r\n            if (event.contains(this.uri)) {\r\n                this.sync();\r\n            }\r\n        }));\r\n        this.toDispose.push(this.fileService.onDidRunOperation(e => {\r\n            if ((e.isOperation(FileOperation.DELETE) || e.isOperation(FileOperation.MOVE)) && e.resource.isEqualOrParent(this.uri)) {\r\n                this.sync();\r\n            }\r\n        }));\r\n        try {\r\n            this.toDispose.push(this.fileService.watch(this.uri));\r\n        } catch (e) {\r\n            console.error(e);\r\n        }\r\n        this.updateSavingContentChanges();\r\n        this.toDispose.push(this.fileService.onDidChangeFileSystemProviderCapabilities(e => {\r\n            if (e.scheme === this.uri.scheme) {\r\n                this.updateSavingContentChanges();\r\n            }\r\n        }));\r\n    }\r\n\r\n    protected _version: FileResourceVersion | undefined;\r\n\r\n    get version(): FileResourceVersion | undefined {\r\n        return this._version;\r\n    }\r\n\r\n    get encoding(): string | undefined {\r\n        return this._version?.encoding;\r\n    }\r\n\r\n    dispose(): void {\r\n        this.toDispose.dispose();\r\n    }\r\n\r\n    async readContents(options?: { encoding?: string }): Promise<string> {\r\n        try {\r\n            const encoding = options?.encoding || this.version?.encoding;\r\n            const stat = await this.fileService.read(this.uri, {\r\n                encoding,\r\n                etag: ETAG_DISABLED,\r\n                acceptTextOnly: this.acceptTextOnly,\r\n                limits: this.limits\r\n            });\r\n            this._version = {\r\n                encoding: stat.encoding,\r\n                etag: stat.etag,\r\n                mtime: stat.mtime\r\n            };\r\n            return stat.value;\r\n        } catch (e) {\r\n            if (e instanceof TextFileOperationError && e.textFileOperationResult === TextFileOperationResult.FILE_IS_BINARY) {\r\n                if (await this.shouldOpenAsText('The file is either binary or uses an unsupported text encoding.')) {\r\n                    this.acceptTextOnly = false;\r\n                    return this.readContents(options);\r\n                }\r\n            } else if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_TOO_LARGE) {\r\n                const stat = await this.fileService.resolve(this.uri, {resolveMetadata: true});\r\n                const maxFileSize = GENERAL_MAX_FILE_SIZE_MB * 1024 * 1024;\r\n                if (this.limits?.size !== maxFileSize && await this.shouldOpenAsText(`The file is too large (${BinarySize.formatSize(stat.size)}).`)) {\r\n                    this.limits = {\r\n                        size: maxFileSize\r\n                    };\r\n                    return this.readContents(options);\r\n                }\r\n            } else if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\r\n                this._version = undefined;\r\n                const {message, stack} = e;\r\n                throw ResourceError.NotFound({\r\n                    message, stack,\r\n                    data: {\r\n                        uri: this.uri\r\n                    }\r\n                });\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    async readStream(options?: { encoding?: string }): Promise<ReadableStream<string>> {\r\n        try {\r\n            const encoding = options?.encoding || this.version?.encoding;\r\n            const stat = await this.fileService.readStream(this.uri, {\r\n                encoding,\r\n                etag: ETAG_DISABLED,\r\n                acceptTextOnly: this.acceptTextOnly,\r\n                limits: this.limits\r\n            });\r\n            this._version = {\r\n                encoding: stat.encoding,\r\n                etag: stat.etag,\r\n                mtime: stat.mtime\r\n            };\r\n            return stat.value;\r\n        } catch (e) {\r\n            if (e instanceof TextFileOperationError && e.textFileOperationResult === TextFileOperationResult.FILE_IS_BINARY) {\r\n                if (await this.shouldOpenAsText('The file is either binary or uses an unsupported text encoding.')) {\r\n                    this.acceptTextOnly = false;\r\n                    return this.readStream(options);\r\n                }\r\n            } else if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_TOO_LARGE) {\r\n                const stat = await this.fileService.resolve(this.uri, {resolveMetadata: true});\r\n                const maxFileSize = GENERAL_MAX_FILE_SIZE_MB * 1024 * 1024;\r\n                if (this.limits?.size !== maxFileSize && await this.shouldOpenAsText(`The file is too large (${BinarySize.formatSize(stat.size)}).`)) {\r\n                    this.limits = {\r\n                        size: maxFileSize\r\n                    };\r\n                    return this.readStream(options);\r\n                }\r\n            } else if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\r\n                this._version = undefined;\r\n                const {message, stack} = e;\r\n                throw ResourceError.NotFound({\r\n                    message, stack,\r\n                    data: {\r\n                        uri: this.uri\r\n                    }\r\n                });\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    saveContents(content: string, options?: ResourceSaveOptions): Promise<void> {\r\n        return this.doWrite(content, options);\r\n    }\r\n\r\n    saveStream(content: Readable<string>, options?: ResourceSaveOptions): Promise<void> {\r\n        return this.doWrite(content, options);\r\n    }\r\n\r\n    protected async doWrite(content: string | Readable<string>, options?: ResourceSaveOptions): Promise<void> {\r\n        const version = options?.version || this._version;\r\n        const current = FileResourceVersion.is(version) ? version : undefined;\r\n        const etag = current?.etag;\r\n        try {\r\n            const stat = await this.fileService.write(this.uri, content, {\r\n                encoding: options?.encoding,\r\n                overwriteEncoding: options?.overwriteEncoding,\r\n                etag,\r\n                mtime: current?.mtime\r\n            });\r\n            this._version = {\r\n                etag: stat.etag,\r\n                mtime: stat.mtime,\r\n                encoding: stat.encoding\r\n            };\r\n        } catch (e) {\r\n            if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\r\n                if (etag !== ETAG_DISABLED && await this.shouldOverwrite()) {\r\n                    return this.doWrite(content, {...options, version: {stat: {...current, etag: ETAG_DISABLED}}});\r\n                }\r\n                const {message, stack} = e;\r\n                throw ResourceError.OutOfSync({message, stack, data: {uri: this.uri}});\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    protected updateSavingContentChanges(): void {\r\n        if (this.fileService.hasCapability(this.uri, FileSystemProviderCapabilities.Update)) {\r\n            this.saveContentChanges = this.doSaveContentChanges;\r\n        } else {\r\n            delete this.saveContentChanges;\r\n        }\r\n    }\r\n\r\n    protected doSaveContentChanges: Resource['saveContentChanges'] = async (changes, options) => {\r\n        const version = options?.version || this._version;\r\n        const current = FileResourceVersion.is(version) ? version : undefined;\r\n        if (!current) {\r\n            throw ResourceError.NotFound({message: 'has not been read yet', data: {uri: this.uri}});\r\n        }\r\n        const etag = current?.etag;\r\n        try {\r\n            const stat = await this.fileService.update(this.uri, changes, {\r\n                readEncoding: current.encoding,\r\n                encoding: options?.encoding,\r\n                overwriteEncoding: options?.overwriteEncoding,\r\n                etag,\r\n                mtime: current?.mtime\r\n            });\r\n            this._version = {\r\n                etag: stat.etag,\r\n                mtime: stat.mtime,\r\n                encoding: stat.encoding\r\n            };\r\n        } catch (e) {\r\n            if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND) {\r\n                const {message, stack} = e;\r\n                throw ResourceError.NotFound({message, stack, data: {uri: this.uri}});\r\n            }\r\n            if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_MODIFIED_SINCE) {\r\n                const {message, stack} = e;\r\n                throw ResourceError.OutOfSync({message, stack, data: {uri: this.uri}});\r\n            }\r\n            throw e;\r\n        }\r\n    };\r\n\r\n    protected async sync(): Promise<void> {\r\n        if (await this.isInSync()) {\r\n            return;\r\n        }\r\n        this.onDidChangeContentsEmitter.fire(undefined);\r\n    }\r\n\r\n    protected async isInSync(): Promise<boolean> {\r\n        try {\r\n            const stat = await this.fileService.resolve(this.uri, {resolveMetadata: true});\r\n            return !!this.version && this.version.mtime >= stat.mtime;\r\n        } catch {\r\n            return !this.version;\r\n        }\r\n    }\r\n\r\n    protected async shouldOverwrite(): Promise<boolean> {\r\n        return this.options.shouldOverwrite();\r\n    }\r\n\r\n    protected async shouldOpenAsText(error: string): Promise<boolean> {\r\n        return this.options.shouldOpenAsText(error);\r\n    }\r\n}\r\n\r\n@injectable()\r\nexport class FileResourceResolver implements ResourceResolver {\r\n\r\n    @inject(FileService)\r\n    protected readonly fileService: FileService;\r\n\r\n    @inject(LabelProvider)\r\n    protected readonly labelProvider: LabelProvider;\r\n\r\n    async resolve(uri: URI): Promise<FileResource> {\r\n        let stat;\r\n        try {\r\n            stat = await this.fileService.resolve(uri);\r\n        } catch (e) {\r\n            if (!(e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_NOT_FOUND)) {\r\n                throw e;\r\n            }\r\n        }\r\n        if (stat && stat.isDirectory) {\r\n            throw new Error('The given uri is a directory: ' + this.labelProvider.getLongName(uri));\r\n        }\r\n        return new FileResource(uri, this.fileService, {\r\n            shouldOverwrite: () => this.shouldOverwrite(uri),\r\n            shouldOpenAsText: error => this.shouldOpenAsText(uri, error)\r\n        });\r\n    }\r\n\r\n    protected async shouldOverwrite(uri: URI): Promise<boolean> {\r\n        const dialog = new ConfirmDialog({\r\n            title: `The file '${this.labelProvider.getName(uri)}' has been changed on the file system.`,\r\n            msg: `Do you want to overwrite the changes made to '${this.labelProvider.getLongName(uri)}' on the file system?`,\r\n            ok: 'Yes',\r\n            cancel: 'No'\r\n        });\r\n        return !!await dialog.open();\r\n    }\r\n\r\n    protected async shouldOpenAsText(uri: URI, error: string): Promise<boolean> {\r\n        const dialog = new ConfirmDialog({\r\n            title: error,\r\n            msg: `Opening it might take some time and might make the IDE unresponsive. Do you want to open '${this.labelProvider.getLongName(uri)}' anyway?`,\r\n            ok: 'Yes',\r\n            cancel: 'No'\r\n        });\r\n        return !!await dialog.open();\r\n    }\r\n}\r\n"]}