{"version":3,"sources":["browser/file-service.ts"],"names":[],"mappings":"AACA,OAAO,EAIH,oBAAoB,EACpB,UAAU,EAGV,KAAK,EAEL,cAAc,EACjB,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EACH,oBAAoB,EACpB,eAAe,EACf,iBAAiB,EAIjB,gBAAgB,EAChB,WAAW,EACX,iBAAiB,EACjB,aAAa,EACb,kBAAkB,EAClB,kBAAkB,EAClB,oBAAoB,EAEpB,QAAQ,EACR,oBAAoB,EACpB,iBAAiB,EACjB,kBAAkB,EAClB,8BAA8B,EAW9B,eAAe,EACf,eAAe,EACf,kBAAkB,EAClB,0BAA0B,EAC1B,IAAI,EAGJ,YAAY,EACZ,gBAAgB,EACnB,MAAM,iBAAiB,CAAC;AACzB,OAAO,GAAG,MAAM,2BAA2B,CAAC;AAG5C,OAAO,KAAK,EAAC,8BAA8B,EAAC,MAAM,gCAAgC,CAAC;AACnF,OAAO,EAAC,aAAa,EAAC,MAAM,YAAY,CAAC;AACzC,OAAO,EAAC,gBAAgB,EAAC,MAAM,0CAA0C,CAAC;AAC1E,OAAO,EAMH,QAAQ,EACR,cAAc,EAEjB,MAAM,8BAA8B,CAAC;AACtC,OAAO,EAAqB,eAAe,EAAE,gBAAgB,EAAC,MAAM,wCAAwC,CAAC;AAE7G,OAAO,EAAC,qBAAqB,EAAC,MAAM,0BAA0B,CAAC;AAC/D,OAAO,EACH,YAAY,EACZ,oBAAoB,EAEpB,0BAA0B,EAE7B,MAAM,8BAA8B,CAAC;AAItC,eAAO,MAAM,uBAAuB,eAAoC,CAAC;AAEzE;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,WAAW,uBAAuB;IACpC;;;OAGG;IACH,2BAA2B,CAAC,OAAO,EAAE,WAAW,GAAG,IAAI,CAAC;CAC3D;AAED;;;;GAIG;AACH,MAAM,WAAW,iCAAkC,SAAQ,cAAc;IACrE,kEAAkE;IAClE,MAAM,EAAE,MAAM,CAAC;CAClB;AAED;;;;GAIG;AACH,MAAM,WAAW,yCAAyC;IACtD,wEAAwE;IACxE,QAAQ,EAAE,kBAAkB,CAAC;IAC7B,4DAA4D;IAC5D,MAAM,EAAE,MAAM,CAAC;CAClB;AAED;;;;GAIG;AACH,MAAM,WAAW,mCAAmC;IAChD,iGAAiG;IACjG,KAAK,EAAE,OAAO,CAAC;IACf,0EAA0E;IAC1E,MAAM,EAAE,MAAM,CAAC;IACf,wEAAwE;IACxE,QAAQ,CAAC,EAAE,kBAAkB,CAAC;CACjC;AAED,MAAM,WAAW,mBAAmB;IAEhC;;;OAGG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC/B;AAED,UAAU,mBAAoB,SAAQ,oBAAoB;IAEtD;;OAEG;IACH,QAAQ,EAAE,MAAM,CAAC;CACpB;AAED,MAAM,WAAW,qBAAsB,SAAQ,mBAAmB;IAE9D;;OAEG;IACH,KAAK,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;CACjC;AAGD,MAAM,WAAW,eAAgB,SAAQ,mBAAmB;IAExD;;OAEG;IACH,KAAK,EAAE,MAAM,CAAC;CACjB;AAGD,MAAM,WAAW,oBAAoB;IAEjC;;OAEG;IACH,QAAQ,CAAC,EAAE,MAAM,CAAC;IAElB;;OAEG;IACH,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC/B;AAED,MAAM,WAAW,mBAAoB,SAAQ,mBAAmB,EAAE,eAAe;IAC7E;;;OAGG;IACH,cAAc,CAAC,EAAE,OAAO,CAAC;CAC5B;AAGD,MAAM,WAAW,qBAAsB,SAAQ,oBAAoB,EAAE,iBAAiB;CACrF;AAED,MAAM,WAAW,oBAAqB,SAAQ,oBAAoB,EAAE,gBAAgB;CACnF;AAED,MAAM,WAAW,qBAAsB,SAAQ,oBAAoB,EAAE,gBAAgB;IACjF,YAAY,EAAE,MAAM,CAAA;CACvB;AAED,MAAM,WAAW,sBAAuB,SAAQ,cAAc;IAE1D;;;OAGG;IACH,QAAQ,CAAC,aAAa,EAAE,MAAM,CAAC;IAE/B;;OAEG;IACH,QAAQ,CAAC,SAAS,EAAE,aAAa,CAAC;IAElC;;OAEG;IACH,QAAQ,CAAC,MAAM,EAAE,GAAG,CAAC;IAErB;;OAEG;IACH,QAAQ,CAAC,MAAM,CAAC,EAAE,GAAG,CAAC;CACzB;AAED,0BAAkB,uBAAuB;IACrC,cAAc,IAAA;CACjB;AAED,qBAAa,sBAAuB,SAAQ,kBAAkB;IAI/C,uBAAuB,EAAE,uBAAuB;IAChD,OAAO,CAAC,EAAE,mBAAmB,GAAG,oBAAoB;gBAF3D,OAAO,EAAE,MAAM,EACR,uBAAuB,EAAE,uBAAuB,EAChD,OAAO,CAAC,EAAE,mBAAmB,GAAG,oBAAoB;CAMlE;AAED;;;;;GAKG;AACH,qBACa,WAAW;IAGpB,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAEhD,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,qBAAqB,CAAC;IAEtD,SAAS,CAAC,QAAQ,CAAC,gBAAgB,EAAE,gBAAgB,CAAC;IAEtD,SAAS,CAAC,QAAQ,CAAC,eAAe,EAAE,eAAe,CAAC;IAEpD,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,oBAAoB,CAAC,uBAAuB,CAAC,CAAC;IAChF,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAa;IACzC,OAAO,CAAC,uCAAuC,CAAoD;IACnG;;OAEG;IACH,QAAQ,CAAC,gCAAgC,2CAAsD;IAC/F,OAAO,CAAC,iDAAiD,CAAsD;IAC/G,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAyC;IACnE,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAkD;IAC9E,OAAO,CAAC,cAAc,CAAK;IAG3B,OAAO,CAAC,QAAQ,CAAC,6BAA6B,CAA8C;IAC5F;;;OAGG;IACH,QAAQ,CAAC,sBAAsB,gCAA4C;IAC3E,OAAO,CAAC,QAAQ,CAAC,6BAA6B,CAA8C;IAC5F;;;OAGG;IACH,QAAQ,CAAC,sBAAsB,gCAA4C;IAC3E,OAAO,CAAC,QAAQ,CAAC,4BAA4B,CAA8C;IAC3F;;;OAGG;IACH,QAAQ,CAAC,qBAAqB,gCAA2C;IACzE,OAAO,CAAC,wBAAwB,CAAqC;IACrE;;;OAGG;IACH,QAAQ,CAAC,iBAAiB,4BAAuC;IACjE,OAAO,CAAC,WAAW,CAAyC;IAC5D,OAAO,CAAC,uBAAuB,CAAmC;IAClE,OAAO,CAAC,cAAc,CAAgE;IACtF,OAAO,CAAC,gDAAgD,CAA4D;IACpH,QAAQ,CAAC,yCAAyC,mDAA+D;IAEjH;;OAEG;IACH,IAAI,gBAAgB,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAE9C;IAED;;;;;;OAMG;IACH,OAAO,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,EAAE,0BAA0B,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAE1F,OAAO,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,kBAAkB,GAAG,SAAS,GAAG,OAAO,CAAC,QAAQ,CAAC;IAiB7E,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,EAAE,oBAAoB,GAAG,OAAO,CAAC,oBAAoB,GAAG;QAAE,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC;IAM5I,4BAA4B,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,GAAG,SAAS,EAAE,SAAS,EAAE,aAAa,GAAG,OAAO,CAAC,IAAI,CAAC;IA2B3G,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAoBxF,MAAM,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,oBAAoB,GAAG,OAAO,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC;IAkBjG,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAoBxF,YAAY,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,GAAE,oBAAyB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IA0B9F,SAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,EAAE,YAAY,GAAG,oBAAoB,GAAG,0BAA0B,EAAE,OAAO,CAAC,EAAE,gBAAgB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAiDrL;;;;;;OAMG;IACG,MAAM,CAAC,QAAQ,EAAE,GAAG,GAAG,OAAO,CAAC,OAAO,CAAC;IAYvC,MAAM,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAsBxH,UAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,wBAAwB,GAAE,YAAY,GAAG,oBAAoB,GAAG,0BAAwD,EAAE,OAAO,CAAC,EAAE,iBAAiB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAgB/M,MAAM,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,EAAE,8BAA8B,EAAE,EAAE,OAAO,EAAE,qBAAqB,GAAG,OAAO,CAAC,oBAAoB,GAAG;QAAE,QAAQ,EAAE,MAAM,CAAA;KAAE,CAAC;IAoB5J;;;;;OAKG;IACG,gBAAgB,CAAC,MAAM,EAAE,MAAM,GAAG,OAAO,CAAC,kBAAkB,CAAC;IAwBnE;;;;;;OAMG;IACH,aAAa,CAAC,QAAQ,EAAE,GAAG,EAAE,UAAU,EAAE,8BAA8B,GAAG,OAAO;IAMjF,KAAK,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,GAAE,YAA+C,GAAG,UAAU;IAuBpF,OAAO,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,EAAE,YAAY,GAAG,OAAO,CAAC,UAAU,CAAC;IA0BxE;;;;;;OAMG;IACH,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,kBAAkB,GAAG,UAAU;IAyBpE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,eAAe,CAAC;IAkB5E,cAAc,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,OAAO,CAAC,iBAAiB,CAAC;IAMpF,UAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,GAAG,OAAO,CAAC,qBAAqB,CAAC;IAUxF,QAAQ,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,OAAO,CAAC,WAAW,CAAC;IAmB9E,SAAS,CAAC,IAAI,IAAI,IAAI;IAMtB;;;;;;;;;;;;;OAaG;IACH,SAAS,CAAC,aAAa,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC,EAAE,gBAAgB,GAAG,OAAO;cASxD,gBAAgB,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,oBAAoB,GAAG,OAAO,CAAC,gBAAgB,CAAC;cAW1F,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC,oBAAoB,CAAC;cAcpF,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC,oBAAoB,CAAC;cAcpF,QAAQ,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC;cA+B5E,QAAQ,CAAC,QAAQ,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,CAAC,EAAE,qBAAqB,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAM1I,SAAS,CAAC,2BAA2B,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,KAAK;IAI5J,SAAS,CAAC,oBAAoB,CAAC,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,CAAC,EAAE,eAAe,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,kBAAkB;IAOlK,SAAS,CAAC,2BAA2B,CAAC,CAAC,SAAS,kBAAkB,EAAE,QAAQ,EAAE,CAAC,EAAE,QAAQ,EAAE,GAAG,GAAG,CAAC;cAQlF,YAAY,CAAC,QAAQ,EAAE,GAAG,GAAG,OAAO,CAAC,kBAAkB,CAAC;cASxD,sBAAsB,CAAC,QAAQ,EAAE,GAAG,EAAE,iBAAiB,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAKlG,SAAS,CAAC,eAAe,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,EAAE,mBAAmB,EAAE,gBAAgB,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAiBnH,SAAS,CAAC,kBAAkB,CAAC,OAAO,CAAC,EAAE,mBAAmB,GAAG,mBAAmB;IAYhF,OAAO,CAAC,gBAAgB;YAIV,aAAa;YAwCb,UAAU;YAsCV,iBAAiB;YAwBjB,UAAU;YAqEV,UAAU;YAuBV,gBAAgB;YAIhB,sBAAsB;YAItB,YAAY;YAoBZ,kBAAkB;YAoClB,eAAe;YAuBf,2BAA2B;YAsD3B,6BAA6B;YAW7B,aAAa;YAQb,iBAAiB;YAIjB,cAAc;YAId,oBAAoB;YA0CpB,uBAAuB;YAevB,0BAA0B;YAI1B,gCAAgC;YAgBhC,0BAA0B;IASxC,OAAO,CAAC,gBAAgB;YAUV,MAAM;YAyDN,iBAAiB;IAS/B,OAAO,CAAC,UAAU;IAQlB,OAAO,CAAC,QAAQ;YAMF,MAAM;IA4BpB,OAAO,CAAC,sBAAsB;YAkBhB,gBAAgB;YAmBhB,gBAAgB;YAWhB,kBAAkB;IAmBhC,OAAO,CAAC,gBAAgB;YAYV,kBAAkB;YAqDlB,gBAAgB;cAWd,kBAAkB,IAAI,OAAO,CAAC,GAAG,CAAC;CAuBrD","file":"../../src/browser/file-service.d.ts","sourcesContent":["import {inject, injectable, named, postConstruct} from 'inversify';\r\nimport {\r\n    AsyncEmitter,\r\n    CancellationToken,\r\n    CancellationTokenSource,\r\n    ContributionProvider,\r\n    Disposable,\r\n    DisposableCollection,\r\n    Emitter,\r\n    Event,\r\n    Mutable,\r\n    WaitUntilEvent\r\n} from '@tart/core/lib/common';\r\nimport {\r\n    BaseStatWithMetadata,\r\n    CopyFileOptions,\r\n    CreateFileOptions,\r\n    ensureFileSystemProviderError,\r\n    etag,\r\n    ETAG_DISABLED,\r\n    FileChangesEvent,\r\n    FileContent,\r\n    FileDeleteOptions,\r\n    FileOperation,\r\n    FileOperationError,\r\n    FileOperationEvent,\r\n    FileOperationOptions,\r\n    FileOperationResult,\r\n    FileStat,\r\n    FileStatWithMetadata,\r\n    FileStreamContent,\r\n    FileSystemProvider,\r\n    FileSystemProviderCapabilities,\r\n    FileSystemProviderErrorCode,\r\n    FileSystemProviderWithFileReadStreamCapability,\r\n    FileSystemProviderWithFileReadWriteCapability,\r\n    FileSystemProviderWithOpenReadWriteCloseCapability,\r\n    FileType,\r\n    hasFileFolderCopyCapability,\r\n    hasFileReadStreamCapability,\r\n    hasOpenReadWriteCloseCapability,\r\n    hasReadWriteCapability,\r\n    hasUpdateCapability,\r\n    MoveFileOptions,\r\n    ReadFileOptions,\r\n    ResolveFileOptions,\r\n    ResolveMetadataFileOptions,\r\n    Stat,\r\n    toFileOperationResult,\r\n    toFileSystemProviderErrorCode,\r\n    WatchOptions,\r\n    WriteFileOptions\r\n} from '../common/files';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {Deferred} from '@tart/core/lib/common/promise-util';\r\nimport {TernarySearchTree} from '@tart/core/lib/common/ternary-search-tree';\r\nimport type {TextDocumentContentChangeEvent} from 'vscode-languageserver-protocol';\r\nimport {LabelProvider} from '@tart/core';\r\nimport {EncodingRegistry} from '@tart/core/lib/browser/encoding-registry';\r\nimport {\r\n    consumeStream,\r\n    isReadableBufferedStream,\r\n    isReadableStream,\r\n    peekReadable,\r\n    peekStream,\r\n    Readable,\r\n    ReadableStream,\r\n    transform\r\n} from '@tart/core/lib/common/stream';\r\nimport {DecodeStreamResult, EncodingService, ResourceEncoding} from '@tart/core/lib/common/encoding-service';\r\nimport {UTF8, UTF8_with_bom} from '@tart/core/lib/common/encodings';\r\nimport {FileSystemPreferences} from './filesystem-preferences';\r\nimport {\r\n    BinaryBuffer,\r\n    BinaryBufferReadable,\r\n    BinaryBufferReadableBufferedStream,\r\n    BinaryBufferReadableStream,\r\n    BinaryBufferWriteableStream\r\n} from '@tart/core/lib/common/buffer';\r\nimport {readFileIntoStream} from '../common/io';\r\nimport {FileSystemUtils} from './file-tree/filesystem-utils';\r\n\r\nexport const FileServiceContribution = Symbol('FileServiceContribution');\r\n\r\n/**\r\n * A {@link FileServiceContribution} can be used to add custom {@link FileSystemProvider}s.\r\n * For this, the contribution has to listen to the {@link FileSystemProviderActivationEvent} and register\r\n * the custom {@link FileSystemProvider}s according to the scheme when this event is fired.\r\n *\r\n * ### Example usage\r\n * ```ts\r\n * export class MyFileServiceContribution implements FileServiceContribution {\r\n *     registerFileSystemProviders(service: FileService): void {\r\n *         service.onWillActivateFileSystemProvider(event => {\r\n *             if (event.scheme === 'mySyncProviderScheme') {\r\n *                 service.registerProvider('mySyncProviderScheme', this.mySyncProvider);\r\n *             }\r\n *             if (event.scheme === 'myAsyncProviderScheme') {\r\n *                 event.waitUntil((async () => {\r\n *                     const myAsyncProvider = await this.createAsyncProvider();\r\n *                     service.registerProvider('myAsyncProviderScheme', myAsyncProvider);\r\n *                 })());\r\n *             }\r\n *         });\r\n *\r\n *     }\r\n *```\r\n */\r\nexport interface FileServiceContribution {\r\n    /**\r\n     * Register custom file system providers for the given {@link FileService}.\r\n     * @param service The file service for which the providers should be registered.\r\n     */\r\n    registerFileSystemProviders(service: FileService): void;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderActivation` event.\r\n * This event is fired by the {@link FileService} if it wants to activate the\r\n * {@link FileSystemProvider} for a specific scheme.\r\n */\r\nexport interface FileSystemProviderActivationEvent extends WaitUntilEvent {\r\n    /** The (uri) scheme for which the provider should be activated */\r\n    scheme: string;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderCapabilitiesChange` event.\r\n * This event is fired by the {@link FileService} if the capabilities of one of its managed\r\n * {@link FileSystemProvider}s have changed.\r\n */\r\nexport interface FileSystemProviderCapabilitiesChangeEvent {\r\n    /** The affected file system provider for which this event was fired. */\r\n    provider: FileSystemProvider;\r\n    /** The (uri) scheme for which the provider is registered */\r\n    scheme: string;\r\n}\r\n\r\n/**\r\n * Represents the `FileSystemProviderRegistration` event.\r\n * This event is fired by the {@link FileService} if a {@link FileSystemProvider} is\r\n * registered to or unregistered from the service.\r\n */\r\nexport interface FileSystemProviderRegistrationEvent {\r\n    /** `True` if a new provider has been registered, `false` if a provider has been unregistered. */\r\n    added: boolean;\r\n    /** The (uri) scheme for which the provider was (previously) registered */\r\n    scheme: string;\r\n    /** The affected file system provider for which this event was fired. */\r\n    provider?: FileSystemProvider;\r\n}\r\n\r\nexport interface ReadEncodingOptions {\r\n\r\n    /**\r\n     * The optional encoding parameter allows to specify the desired encoding when resolving\r\n     * the contents of the file.\r\n     */\r\n    encoding?: string;\r\n\r\n    /**\r\n     * The optional guessEncoding parameter allows to guess encoding from content of the file.\r\n     */\r\n    autoGuessEncoding?: boolean;\r\n}\r\n\r\ninterface BaseTextFileContent extends BaseStatWithMetadata {\r\n\r\n    /**\r\n     * The encoding of the content if known.\r\n     */\r\n    encoding: string;\r\n}\r\n\r\nexport interface TextFileStreamContent extends BaseTextFileContent {\r\n\r\n    /**\r\n     * The line grouped content of a text file.\r\n     */\r\n    value: ReadableStream<string>;\r\n}\r\n\r\n\r\nexport interface TextFileContent extends BaseTextFileContent {\r\n\r\n    /**\r\n     * The content of a text file.\r\n     */\r\n    value: string;\r\n}\r\n\r\n\r\nexport interface WriteEncodingOptions {\r\n\r\n    /**\r\n     * The encoding to use when updating a file.\r\n     */\r\n    encoding?: string;\r\n\r\n    /**\r\n     * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\r\n     */\r\n    overwriteEncoding?: boolean;\r\n}\r\n\r\nexport interface ReadTextFileOptions extends ReadEncodingOptions, ReadFileOptions {\r\n    /**\r\n     * The optional acceptTextOnly parameter allows to fail this request early if the file\r\n     * contents are not textual.\r\n     */\r\n    acceptTextOnly?: boolean;\r\n}\r\n\r\n\r\nexport interface CreateTextFileOptions extends WriteEncodingOptions, CreateFileOptions {\r\n}\r\n\r\nexport interface WriteTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\r\n}\r\n\r\nexport interface UpdateTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\r\n    readEncoding: string\r\n}\r\n\r\nexport interface UserFileOperationEvent extends WaitUntilEvent {\r\n\r\n    /**\r\n     * An identifier to correlate the operation through the\r\n     * different event types (before, after, error).\r\n     */\r\n    readonly correlationId: number;\r\n\r\n    /**\r\n     * The file operation that is taking place.\r\n     */\r\n    readonly operation: FileOperation;\r\n\r\n    /**\r\n     * The resource the event is about.\r\n     */\r\n    readonly target: URI;\r\n\r\n    /**\r\n     * A property that is defined for move operations.\r\n     */\r\n    readonly source?: URI;\r\n}\r\n\r\nexport const enum TextFileOperationResult {\r\n    FILE_IS_BINARY\r\n}\r\n\r\nexport class TextFileOperationError extends FileOperationError {\r\n\r\n    constructor(\r\n        message: string,\r\n        public textFileOperationResult: TextFileOperationResult,\r\n        public options?: ReadTextFileOptions & WriteTextFileOptions\r\n    ) {\r\n        super(message, FileOperationResult.FILE_OTHER_ERROR);\r\n        Object.setPrototypeOf(this, TextFileOperationError.prototype);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * The {@link FileService} is the common facade responsible for all interactions with file systems.\r\n * It manages all registered {@link FileSystemProvider}s and\r\n *  forwards calls to the responsible {@link FileSystemProvider}, determined by the scheme.\r\n * For additional documentation regarding the provided functions see also {@link FileSystemProvider}.\r\n */\r\n@injectable()\r\nexport class FileService {\r\n\r\n    @inject(LabelProvider)\r\n    protected readonly labelProvider: LabelProvider;\r\n    @inject(FileSystemPreferences)\r\n    protected readonly preferences: FileSystemPreferences;\r\n    @inject(EncodingRegistry)\r\n    protected readonly encodingRegistry: EncodingRegistry;\r\n    @inject(EncodingService)\r\n    protected readonly encodingService: EncodingService;\r\n    @inject(ContributionProvider) @named(FileServiceContribution)\r\n    protected readonly contributions: ContributionProvider<FileServiceContribution>;\r\n    private readonly BUFFER_SIZE = 64 * 1024;\r\n    private onWillActivateFileSystemProviderEmitter = new Emitter<FileSystemProviderActivationEvent>();\r\n    /**\r\n     * See `FileServiceContribution.registerProviders`.\r\n     */\r\n    readonly onWillActivateFileSystemProvider = this.onWillActivateFileSystemProviderEmitter.event;\r\n    private onDidChangeFileSystemProviderRegistrationsEmitter = new Emitter<FileSystemProviderRegistrationEvent>();\r\n    private readonly providers = new Map<string, FileSystemProvider>();\r\n    private readonly activations = new Map<string, Promise<FileSystemProvider>>();\r\n    private correlationIds = 0;\r\n\r\n    // #region Events\r\n    private readonly onWillRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is being performed.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onWillRunUserOperation = this.onWillRunUserOperationEmitter.event;\r\n    private readonly onDidFailUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is failed.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onDidFailUserOperation = this.onDidFailUserOperationEmitter.event;\r\n    private readonly onDidRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when file operation is finished.\r\n     * This event is triggered by user gestures.\r\n     */\r\n    readonly onDidRunUserOperation = this.onDidRunUserOperationEmitter.event;\r\n    private onDidRunOperationEmitter = new Emitter<FileOperationEvent>();\r\n    /**\r\n     * An event that is emitted when operation is finished.\r\n     * This event is triggered by user gestures and programmatically.\r\n     */\r\n    readonly onDidRunOperation = this.onDidRunOperationEmitter.event;\r\n    private writeQueues: Map<string, Promise<void>> = new Map();\r\n    private onDidFilesChangeEmitter = new Emitter<FileChangesEvent>();\r\n    private activeWatchers = new Map<string, { disposable: Disposable, count: number }>();\r\n    private onDidChangeFileSystemProviderCapabilitiesEmitter = new Emitter<FileSystemProviderCapabilitiesChangeEvent>();\r\n    readonly onDidChangeFileSystemProviderCapabilities = this.onDidChangeFileSystemProviderCapabilitiesEmitter.event;\r\n\r\n    /**\r\n     * An event that is emitted when files are changed on the disk.\r\n     */\r\n    get onDidFilesChange(): Event<FileChangesEvent> {\r\n        return this.onDidFilesChangeEmitter.event;\r\n    }\r\n\r\n    /**\r\n     * Try to resolve file information and metadata for the given resource.\r\n     * @param resource `URI` of the resource that should be resolved.\r\n     * @param options  Options to customize the resolvement process.\r\n     *\r\n     * @return A promise that resolves if the resource could be successfully resolved.\r\n     */\r\n    resolve(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\r\n\r\n    resolve(resource: URI, options?: ResolveFileOptions | undefined): Promise<FileStat>;\r\n\r\n    async resolve(resource: any, options?: any) {\r\n        try {\r\n            return await this.doResolveFile(resource, options);\r\n        } catch (error) {\r\n\r\n            // Specially handle file not found case as file operation result\r\n            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\r\n                throw new FileOperationError(`Unable to resolve non-existing file ''`, FileOperationResult.FILE_NOT_FOUND);\r\n            }\r\n\r\n            // Bubble up any other error as is\r\n            throw ensureFileSystemProviderError(error);\r\n        }\r\n    }\r\n\r\n    async write(resource: URI, value: string | Readable<string>, options?: WriteTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\r\n        const encoding = await this.getWriteEncoding(resource, options);\r\n        const encoded = await this.encodingService.encodeStream(value, encoding);\r\n        return Object.assign(await this.writeFile(resource, encoded, options), {encoding: encoding.encoding});\r\n    }\r\n\r\n    async runFileOperationParticipants(target: URI, source: URI | undefined, operation: FileOperation): Promise<void> {\r\n        const participantsTimeout = this.preferences['files.participants.timeout'];\r\n        if (participantsTimeout <= 0) {\r\n            return;\r\n        }\r\n\r\n        const cancellationTokenSource = new CancellationTokenSource();\r\n\r\n        // return this.progressService.withProgress(this.progressLabel(operation), 'window', async () => {\r\n        //     for (const participant of this.participants) {\r\n        //         if (cancellationTokenSource.token.isCancellationRequested) {\r\n        //             break;\r\n        //         }\r\n        //\r\n        //         try {\r\n        //             const promise = participant.participate(target, source, operation, participantsTimeout, cancellationTokenSource.token);\r\n        //             await Promise.race([\r\n        //                 promise,\r\n        //                 timeout(participantsTimeout, cancellationTokenSource.token).then(() => cancellationTokenSource.dispose(), () => { /* no-op if cancelled */ })\r\n        //             ]);\r\n        //         } catch (err) {\r\n        //             console.warn(err);\r\n        //         }\r\n        //     }\r\n        // });\r\n    }\r\n\r\n    async copy(source: URI, target: URI, options?: CopyFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doCopy(source, target, options.overwrite);\r\n        }\r\n        await this.runFileOperationParticipants(target, source, FileOperation.COPY);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.COPY, target, source};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doCopy(source, target, options?.overwrite);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n        return stat;\r\n    }\r\n\r\n    async delete(resource: URI, options?: FileOperationOptions & Partial<FileDeleteOptions>): Promise<void> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doDelete(resource, options);\r\n        }\r\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.DELETE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.DELETE, target: resource};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        try {\r\n            await this.doDelete(resource, options);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n    }\r\n\r\n    async move(source: URI, target: URI, options?: MoveFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doMove(source, target, options.overwrite);\r\n        }\r\n        await this.runFileOperationParticipants(target, source, FileOperation.MOVE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.MOVE, target, source};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doMove(source, target, options?.overwrite);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n        return stat;\r\n    }\r\n\r\n    async createFolder(resource: URI, options: FileOperationOptions = {}): Promise<FileStatWithMetadata> {\r\n        const {\r\n            fromUserGesture = true,\r\n        } = options;\r\n\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\r\n\r\n        // mkdir recursively\r\n        await this.mkdirp(provider, resource);\r\n\r\n        // events\r\n        const fileStat = await this.resolve(resource, {resolveMetadata: true});\r\n\r\n        if (fromUserGesture) {\r\n            this.onDidRunUserOperationEmitter.fire({\r\n                correlationId: this.correlationIds++,\r\n                operation: FileOperation.CREATE,\r\n                target: resource\r\n            });\r\n        } else {\r\n            this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\r\n        }\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    async writeFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream, options?: WriteFileOptions): Promise<FileStatWithMetadata> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\r\n\r\n        try {\r\n\r\n            // validate write\r\n            const stat = await this.validateWriteFile(provider, resource, options);\r\n\r\n            // mkdir recursively as needed\r\n            if (!stat) {\r\n                await this.mkdirp(provider, resource.parent);\r\n            }\r\n\r\n            // optimization: if the provider has unbuffered write capability and the data\r\n            // to write is a Readable, we consume up to 3 chunks and try to write the data\r\n            // unbuffered to reduce the overhead. If the Readable has more data to provide\r\n            // we continue to write buffered.\r\n            let bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream;\r\n            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof BinaryBuffer)) {\r\n                if (isReadableStream(bufferOrReadableOrStream)) {\r\n                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\r\n                    if (bufferedStream.ended) {\r\n                        bufferOrReadableOrStreamOrBufferedStream = BinaryBuffer.concat(bufferedStream.buffer);\r\n                    } else {\r\n                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;\r\n                    }\r\n                } else {\r\n                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => BinaryBuffer.concat(data), 3);\r\n                }\r\n            } else {\r\n                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\r\n            }\r\n\r\n            // write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\r\n            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer)) {\r\n                await this.doWriteUnbuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream);\r\n            }\r\n\r\n            // write file: buffered\r\n            else {\r\n                await this.doWriteBuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer ? BinaryBufferReadable.fromBuffer(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\r\n            }\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\r\n        }\r\n\r\n        return this.resolve(resource, {resolveMetadata: true});\r\n    }\r\n\r\n    /**\r\n     * Tests if the given resource exists in the filesystem.\r\n     * @param resource `URI` of the resource which should be tested.\r\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\r\n     *\r\n     * @returns A promise that resolves to `true` if the resource exists.\r\n     */\r\n    async exists(resource: URI): Promise<boolean> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        try {\r\n            const stat = await provider.stat(resource);\r\n\r\n            return !!stat;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async create(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\r\n        if (options?.fromUserGesture === false) {\r\n            return this.doCreate(resource, value, options);\r\n        }\r\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.CREATE);\r\n\r\n        const event = {correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource};\r\n        await this.onWillRunUserOperationEmitter.fire(event);\r\n\r\n        let stat: FileStatWithMetadata;\r\n        try {\r\n            stat = await this.doCreate(resource, value, options);\r\n        } catch (error) {\r\n            await this.onDidFailUserOperationEmitter.fire(event);\r\n            throw error;\r\n        }\r\n\r\n        await this.onDidRunUserOperationEmitter.fire(event);\r\n\r\n        return stat;\r\n    }\r\n\r\n    async createFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream = BinaryBuffer.fromString(''), options?: CreateFileOptions): Promise<FileStatWithMetadata> {\r\n\r\n        // validate overwrite\r\n        if (!options?.overwrite && await this.exists(resource)) {\r\n            throw new FileOperationError(`Unable to create file '${this.resourceForError(resource)}' that already exists when overwrite flag is not set`, FileOperationResult.FILE_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        // do write into file (this will create it too)\r\n        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\r\n\r\n        // events\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    async update(resource: URI, changes: TextDocumentContentChangeEvent[], options: UpdateTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\r\n        try {\r\n            await this.validateWriteFile(provider, resource, options);\r\n            if (hasUpdateCapability(provider)) {\r\n                const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\r\n                const stat = await provider.updateFile(resource, changes, {\r\n                    readEncoding: options.readEncoding,\r\n                    writeEncoding: encoding,\r\n                    overwriteEncoding: options.overwriteEncoding || false\r\n                });\r\n                return Object.assign(FileStat.fromStat(resource, stat), {encoding: stat.encoding});\r\n            } else {\r\n                throw new Error('incremental file update is not supported');\r\n            }\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to activate the registered provider for the given scheme\r\n     * @param scheme  The uri scheme for which the responsible provider should be activated.\r\n     *\r\n     * @returns A promise of the activated file system provider. Only resolves if a provider is available for this scheme, gets rejected otherwise.\r\n     */\r\n    async activateProvider(scheme: string): Promise<FileSystemProvider> {\r\n        let provider = this.providers.get(scheme);\r\n        if (provider) {\r\n            return provider;\r\n        }\r\n        let activation = this.activations.get(scheme);\r\n        if (!activation) {\r\n            const deferredActivation = new Deferred<FileSystemProvider>();\r\n            this.activations.set(scheme, activation = deferredActivation.promise);\r\n            WaitUntilEvent.fire(this.onWillActivateFileSystemProviderEmitter, {scheme}).then(() => {\r\n                provider = this.providers.get(scheme);\r\n                if (!provider) {\r\n                    const error = new Error();\r\n                    error.name = 'ENOPRO';\r\n                    error.message = `No file system provider found for scheme ${scheme}`;\r\n                    throw error;\r\n                } else {\r\n                    deferredActivation.resolve(provider);\r\n                }\r\n            }).catch(e => deferredActivation.reject(e));\r\n        }\r\n        return activation;\r\n    }\r\n\r\n    /**\r\n     * Tests if the service (i.e the {@link FileSystemProvider} registered for the given uri scheme) provides the given capability.\r\n     * @param resource `URI` of the resource to test.\r\n     * @param capability The required capability.\r\n     *\r\n     * @returns `true` if the resource can be handled and the required capability can be provided.\r\n     */\r\n    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\r\n        const provider = this.providers.get(resource.scheme);\r\n\r\n        return !!(provider && (provider.capabilities & capability));\r\n    }\r\n\r\n    watch(resource: URI, options: WatchOptions = {recursive: false, excludes: []}): Disposable {\r\n        const resolvedOptions: WatchOptions = {\r\n            ...options,\r\n            // always ignore temporary upload files\r\n            excludes: options.excludes.concat('**/tart_upload_*')\r\n        };\r\n\r\n        let watchDisposed = false;\r\n        let watchDisposable = Disposable.create(() => watchDisposed = true);\r\n\r\n        // Watch and wire in disposable which is async but\r\n        // check if we got disposed meanwhile and forward4\r\n        this.doWatch(resource, resolvedOptions).then(disposable => {\r\n            if (watchDisposed) {\r\n                disposable.dispose();\r\n            } else {\r\n                watchDisposable = disposable;\r\n            }\r\n        }, error => console.error(error));\r\n\r\n        return Disposable.create(() => watchDisposable.dispose());\r\n    }\r\n\r\n    async doWatch(resource: URI, options: WatchOptions): Promise<Disposable> {\r\n        const provider = await this.withProvider(resource);\r\n        const key = this.toWatchKey(provider, resource, options);\r\n\r\n        // Only start watching if we are the first for the given key\r\n        const watcher = this.activeWatchers.get(key) || {count: 0, disposable: provider.watch(resource, options)};\r\n        if (!this.activeWatchers.has(key)) {\r\n            this.activeWatchers.set(key, watcher);\r\n        }\r\n\r\n        // Increment usage counter\r\n        watcher.count += 1;\r\n\r\n        return Disposable.create(() => {\r\n\r\n            // Unref\r\n            watcher.count--;\r\n\r\n            // Dispose only when last user is reached\r\n            if (watcher.count === 0) {\r\n                watcher.disposable.dispose();\r\n                this.activeWatchers.delete(key);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Registers a new {@link FileSystemProvider} for the given scheme.\r\n     * @param scheme The (uri) scheme for which the provider should be registered.\r\n     * @param provider The file system provider that should be registered.\r\n     *\r\n     * @returns A `Disposable` that can be invoked to unregister the given provider.\r\n     */\r\n    registerProvider(scheme: string, provider: FileSystemProvider): Disposable {\r\n        if (this.providers.has(scheme)) {\r\n            console.log('error');\r\n            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\r\n        }\r\n\r\n        this.providers.set(scheme, provider);\r\n        this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({added: true, scheme, provider});\r\n\r\n        const providerDisposables = new DisposableCollection();\r\n        providerDisposables.push(provider.onDidChangeFile(changes => this.onDidFilesChangeEmitter.fire(new FileChangesEvent(changes))));\r\n        // providerDisposables.push(provider.onFileWatchError(() => this.handleFileWatchError()));\r\n        providerDisposables.push(provider.onDidChangeCapabilities(() => this.onDidChangeFileSystemProviderCapabilitiesEmitter.fire({\r\n            provider,\r\n            scheme\r\n        })));\r\n\r\n        return Disposable.create(() => {\r\n            this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({added: false, scheme, provider});\r\n            this.providers.delete(scheme);\r\n\r\n            providerDisposables.dispose();\r\n        });\r\n    }\r\n\r\n    async read(resource: URI, options?: ReadTextFileOptions): Promise<TextFileContent> {\r\n        const [bufferStream, decoder] = await this.doRead(resource, {\r\n            ...options,\r\n            // optimization: since we know that the caller does not\r\n            // care about buffering, we indicate this to the reader.\r\n            // this reduces all the overhead the buffered reading\r\n            // has (open, read, close) if the provider supports\r\n            // unbuffered reading.\r\n            preferUnbuffered: true\r\n        });\r\n\r\n        return {\r\n            ...bufferStream,\r\n            encoding: decoder.detected.encoding || UTF8,\r\n            value: await consumeStream(decoder.stream, strings => strings.join(''))\r\n        };\r\n    }\r\n\r\n    async readFileStream(resource: URI, options?: ReadFileOptions): Promise<FileStreamContent> {\r\n        const provider = await this.withReadProvider(resource);\r\n\r\n        return this.doReadAsFileStream(provider, resource, options);\r\n    }\r\n\r\n    async readStream(resource: URI, options?: ReadTextFileOptions): Promise<TextFileStreamContent> {\r\n        const [bufferStream, decoder] = await this.doRead(resource, options);\r\n\r\n        return {\r\n            ...bufferStream,\r\n            encoding: decoder.detected.encoding || UTF8,\r\n            value: decoder.stream\r\n        };\r\n    }\r\n\r\n    async readFile(resource: URI, options?: ReadFileOptions): Promise<FileContent> {\r\n        const provider = await this.withReadProvider(resource);\r\n\r\n        const stream = await this.doReadAsFileStream(provider, resource, {\r\n            ...options,\r\n            // optimization: since we know that the caller does not\r\n            // care about buffering, we indicate this to the reader.\r\n            // this reduces all the overhead the buffered reading\r\n            // has (open, read, close) if the provider supports\r\n            // unbuffered reading.\r\n            preferUnbuffered: true\r\n        });\r\n        return {\r\n            ...stream,\r\n            value: await BinaryBufferReadableStream.toBuffer(stream.value)\r\n        };\r\n    }\r\n\r\n    @postConstruct()\r\n    protected init(): void {\r\n        for (const contribution of this.contributions.getContributions()) {\r\n            contribution.registerFileSystemProviders(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dirty write prevention: if the file on disk has been changed and does not match our expected\r\n     * mtime and etag, we bail out to prevent dirty writing.\r\n     *\r\n     * First, we check for a mtime that is in the future before we do more checks. The assumption is\r\n     * that only the mtime is an indicator for a file that has changed on disk.\r\n     *\r\n     * Second, if the mtime has advanced, we compare the size of the file on disk with our previous\r\n     * one using the etag() function. Relying only on the mtime check has proven to produce false\r\n     * positives due to file system weirdness (especially around remote file systems). As such, the\r\n     * check for size is a weaker check because it can return a false negative if the file has changed\r\n     * but to the same length. This is a compromise we take to avoid having to produce checksums of\r\n     * the file content for comparison which would be much slower to compute.\r\n     */\r\n    protected modifiedSince(stat: Stat, options?: WriteFileOptions): boolean {\r\n        return !!options && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\r\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\r\n            options.mtime < stat.mtime && options.etag !== etag({\r\n                mtime: options.mtime /* not using stat.mtime for a reason, see above */,\r\n                size: stat.size\r\n            });\r\n    }\r\n\r\n    protected async getWriteEncoding(resource: URI, options?: WriteEncodingOptions): Promise<ResourceEncoding> {\r\n        const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\r\n        return this.encodingService.toResourceEncoding(encoding, {\r\n            overwriteEncoding: options?.overwriteEncoding,\r\n            read: async length => {\r\n                const buffer = await BinaryBufferReadableStream.toBuffer((await this.readFileStream(resource, {length})).value);\r\n                return buffer.buffer;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected async doCopy(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\r\n        const sourceProvider = await this.withReadProvider(source);\r\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\r\n\r\n        // copy\r\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\r\n\r\n        // resolve and send events\r\n        const fileStat = await this.resolve(target, {resolveMetadata: true});\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    protected async doMove(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\r\n        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\r\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\r\n\r\n        // move\r\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\r\n\r\n        // resolve and send events\r\n        const fileStat = await this.resolve(target, {resolveMetadata: true});\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    protected async doDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\r\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\r\n\r\n        // Validate trash support\r\n        const useTrash = !!options?.useTrash;\r\n        if (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\r\n            throw new Error(`Unable to delete file '${this.resourceForError(resource)}' via trash because provider does not support it.`);\r\n        }\r\n\r\n        // Validate delete\r\n        const exists = await this.exists(resource);\r\n        if (!exists) {\r\n            throw new FileOperationError(`Unable to delete non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\r\n        }\r\n\r\n        // Validate recursive\r\n        const recursive = !!options?.recursive;\r\n        if (!recursive && exists) {\r\n            const stat = await this.resolve(resource);\r\n            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\r\n                throw new Error(`Unable to delete non-empty folder '${this.resourceForError(resource)}'.`);\r\n            }\r\n        }\r\n\r\n        // Delete through provider\r\n        await provider.delete(resource, {recursive, useTrash});\r\n\r\n        // Events\r\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.DELETE));\r\n    }\r\n\r\n    protected async doCreate(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\r\n        const encoding = await this.getWriteEncoding(resource, options);\r\n        const encoded = await this.encodingService.encodeStream(value, encoding);\r\n        return this.createFile(resource, encoded, options);\r\n    }\r\n\r\n    protected rethrowAsFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): never {\r\n        throw this.asFileOperationError(message, resource, error, options);\r\n    }\r\n\r\n    protected asFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): FileOperationError {\r\n        const fileOperationError = new FileOperationError(`${message} '${this.resourceForError(resource)}' (${ensureFileSystemProviderError(error).toString()})`,\r\n            toFileOperationResult(error), options);\r\n        fileOperationError.stack = `${fileOperationError.stack}\\nCaused by: ${error.stack}`;\r\n        return fileOperationError;\r\n    }\r\n\r\n    protected throwIfFileSystemIsReadonly<T extends FileSystemProvider>(provider: T, resource: URI): T {\r\n        if (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\r\n            throw new FileOperationError(`Unable to modify readonly file`, FileOperationResult.FILE_PERMISSION_DENIED);\r\n        }\r\n\r\n        return provider;\r\n    }\r\n\r\n    protected async withProvider(resource: URI): Promise<FileSystemProvider> {\r\n        // Assert path is absolute\r\n        // if (!resource.path.isAbsolute) {\r\n        //     throw new FileOperationError(`Unable to resolve filesystem provider with relative file path`, FileOperationResult.FILE_INVALID_PATH);\r\n        // }\r\n\r\n        return this.activateProvider(resource.scheme);\r\n    }\r\n\r\n    protected async getEncodingForResource(resource: URI, preferredEncoding?: string): Promise<string> {\r\n        // resource = await this.toUnderlyingResource(resource);\r\n        return this.encodingRegistry.getEncodingForResource(resource, preferredEncoding);\r\n    }\r\n\r\n    protected getReadEncoding(resource: URI, options?: ReadEncodingOptions, detectedEncoding?: string): Promise<string> {\r\n        let preferredEncoding: string | undefined;\r\n\r\n        // Encoding passed in as option\r\n        if (options?.encoding) {\r\n            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {\r\n                preferredEncoding = UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\r\n            } else {\r\n                preferredEncoding = options.encoding; // give passed in encoding highest priority\r\n            }\r\n        } else if (detectedEncoding) {\r\n            preferredEncoding = detectedEncoding;\r\n        }\r\n\r\n        return this.getEncodingForResource(resource, preferredEncoding);\r\n    }\r\n\r\n    protected resolveReadOptions(options?: ReadTextFileOptions): ReadTextFileOptions {\r\n        options = {\r\n            ...options,\r\n            autoGuessEncoding: typeof options?.autoGuessEncoding === 'boolean' ? options.autoGuessEncoding : this.preferences['files.autoGuessEncoding']\r\n        };\r\n        const limits: Mutable<ReadTextFileOptions['limits']> = options.limits = options.limits || {};\r\n        if (typeof limits.size !== 'number') {\r\n            limits.size = this.preferences['files.maxFileSizeMB'] * 1024 * 1024;\r\n        }\r\n        return options;\r\n    }\r\n\r\n    private resourceForError(resource: URI): string {\r\n        return this.labelProvider.getLongName(resource);\r\n    }\r\n\r\n    private async doResolveFile(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\r\n\r\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat>;\r\n\r\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        const resolveTo = options?.resolveTo;\r\n        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\r\n        const resolveMetadata = options?.resolveMetadata;\r\n\r\n        const stat = await provider.stat(resource);\r\n\r\n        let trie: TernarySearchTree<URI, boolean> | undefined;\r\n\r\n        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\r\n\r\n            // lazy trie to check for recursive resolving\r\n            if (!trie) {\r\n                trie = TernarySearchTree.forUris<true>(!!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive));\r\n                trie.set(resource, true);\r\n                if (Array.isArray(resolveTo) && resolveTo.length) {\r\n                    resolveTo.forEach(uri => trie!.set(uri, true));\r\n                }\r\n            }\r\n\r\n            // check for recursive resolving\r\n            if (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\r\n                return true;\r\n            }\r\n\r\n            // check for resolving single child folders\r\n            if (stat.isDirectory && resolveSingleChildDescendants) {\r\n                return siblings === 1;\r\n            }\r\n\r\n            return false;\r\n        });\r\n    }\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat>;\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStatWithMetadata>;\r\n\r\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat> {\r\n        const fileStat = FileStat.fromStat(resource, stat);\r\n\r\n        // check to recurse for directories\r\n        if (fileStat.isDirectory && recurse(fileStat, siblings)) {\r\n            try {\r\n                const entries = await provider.readdir(resource);\r\n                const resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\r\n                    try {\r\n                        const childResource = resource.resolve(name);\r\n                        const childStat = resolveMetadata ? await provider.stat(childResource) : {type};\r\n\r\n                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\r\n                    } catch (error) {\r\n                        console.trace(error);\r\n\r\n                        return null; // can happen e.g. due to permission errors\r\n                    }\r\n                }));\r\n\r\n                // make sure to get rid of null values that signal a failure to resolve a particular entry\r\n                fileStat.children = resolvedEntries.filter(e => !!e) as FileStat[];\r\n            } catch (error) {\r\n                console.trace(error);\r\n\r\n                fileStat.children = []; // gracefully handle errors, we may not have permissions to read\r\n            }\r\n\r\n            return fileStat;\r\n        }\r\n\r\n        return fileStat;\r\n    }\r\n\r\n    private async validateWriteFile(provider: FileSystemProvider, resource: URI, options?: WriteFileOptions): Promise<Stat | undefined> {\r\n        let stat: Stat | undefined = undefined;\r\n        try {\r\n            stat = await provider.stat(resource);\r\n        } catch (error) {\r\n            return undefined; // file might not exist\r\n        }\r\n\r\n        if (stat === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        // file cannot be directory\r\n        if ((stat.type & FileType.Directory) !== 0) {\r\n            throw new FileOperationError(`Unable to write file ${this.resourceForError(resource)} that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\r\n        }\r\n\r\n        if (this.modifiedSince(stat, options)) {\r\n            throw new FileOperationError('File Modified Since', FileOperationResult.FILE_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        return stat;\r\n    }\r\n\r\n    private async doMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\r\n        if (source.toString() === target.toString()) {\r\n            return mode; // simulate node.js behaviour here and do a no-op if paths match\r\n        }\r\n\r\n        // validation\r\n        const {\r\n            exists,\r\n            isSameResourceWithDifferentPathCase\r\n        } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\r\n\r\n        // if target exists get valid target\r\n        if (exists && !overwrite) {\r\n            const parent = await this.resolve(target.parent);\r\n            const name = isSameResourceWithDifferentPathCase ? target.path.name : target.path.name + '_copy';\r\n            target = FileSystemUtils.generateUniqueResourceURI(target.parent, parent, name, target.path.ext);\r\n        }\r\n\r\n        // delete as needed (unless target is same resource with different path case)\r\n        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {\r\n            await this.delete(target, {recursive: true});\r\n        }\r\n\r\n        // create parent folders\r\n        await this.mkdirp(targetProvider, target.parent);\r\n\r\n        // copy source => target\r\n        if (mode === 'copy') {\r\n\r\n            // same provider with fast copy: leverage copy() functionality\r\n            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\r\n                await sourceProvider.copy(source, target, {overwrite});\r\n            }\r\n\r\n                // when copying via buffer/unbuffered, we have to manually\r\n            // traverse the source if it is a folder and not a file\r\n            else {\r\n                const sourceFile = await this.resolve(source);\r\n                if (sourceFile.isDirectory) {\r\n                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\r\n                } else {\r\n                    await this.doCopyFile(sourceProvider, source, targetProvider, target);\r\n                }\r\n            }\r\n\r\n            return mode;\r\n        }\r\n\r\n        // move source => target\r\n        else {\r\n\r\n            // same provider: leverage rename() functionality\r\n            if (sourceProvider === targetProvider) {\r\n                await sourceProvider.rename(source, target, {overwrite});\r\n\r\n                return mode;\r\n            }\r\n\r\n            // across providers: copy to target & delete at source\r\n            else {\r\n                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\r\n\r\n                await this.delete(source, {recursive: true});\r\n\r\n                return 'copy';\r\n            }\r\n        }\r\n    }\r\n\r\n    private async doCopyFile(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI): Promise<void> {\r\n\r\n        // copy: source (buffered) => target (buffered)\r\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\r\n            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (buffered) => target (unbuffered)\r\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\r\n            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (unbuffered) => target (buffered)\r\n        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\r\n            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n\r\n        // copy: source (unbuffered) => target (unbuffered)\r\n        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\r\n            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\r\n        }\r\n    }\r\n\r\n    private async doPipeUnbuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeUnbufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n        return targetProvider.writeFile(target, await sourceProvider.readFile(source), {create: true, overwrite: true});\r\n    }\r\n\r\n    private async doCopyFolder(sourceProvider: FileSystemProvider, sourceFolder: FileStat, targetProvider: FileSystemProvider, targetFolder: URI): Promise<void> {\r\n\r\n        // create folder in target\r\n        await targetProvider.mkdir(targetFolder);\r\n\r\n        // create children in target\r\n        if (Array.isArray(sourceFolder.children)) {\r\n            await Promise.all(sourceFolder.children.map(async sourceChild => {\r\n                const targetChild = targetFolder.resolve(sourceChild.name);\r\n                if (sourceChild.isDirectory) {\r\n                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\r\n                } else {\r\n                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\r\n                }\r\n            }));\r\n        }\r\n    }\r\n\r\n    // #region File Watching\r\n\r\n    private async doValidateMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean }> {\r\n        let isSameResourceWithDifferentPathCase = false;\r\n\r\n        // Check if source is equal or parent to target (requires providers to be the same)\r\n        if (sourceProvider === targetProvider) {\r\n            const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n            if (!isPathCaseSensitive) {\r\n                isSameResourceWithDifferentPathCase = source.toString().toLowerCase() === target.toString().toLowerCase();\r\n            }\r\n\r\n            if (isSameResourceWithDifferentPathCase && mode === 'copy') {\r\n                throw new Error(`Unable to copy when source '${this.resourceForError(source)}' is same as target '${this.resourceForError(target)}' with different path case on a case insensitive file system`);\r\n            }\r\n\r\n            if (!isSameResourceWithDifferentPathCase && target.isEqualOrParent(source, isPathCaseSensitive)) {\r\n                throw new Error(`Unable to move/copy when source '${this.resourceForError(source)}' is parent of target '${this.resourceForError(target)}'.`);\r\n            }\r\n        }\r\n\r\n        // Extra checks if target exists and this is not a rename\r\n        const exists = await this.exists(target);\r\n        if (exists && !isSameResourceWithDifferentPathCase) {\r\n\r\n            // Special case: if the target is a parent of the source, we cannot delete\r\n            // it as it would delete the source as well. In this case we have to throw\r\n            if (sourceProvider === targetProvider) {\r\n                const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n                if (source.isEqualOrParent(target, isPathCaseSensitive)) {\r\n                    throw new Error(`Unable to move/copy '${this.resourceForError(source)}' into '${this.resourceForError(target)}' since a file would replace the folder it is contained in.`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {exists, isSameResourceWithDifferentPathCase};\r\n    }\r\n\r\n    private async doWriteBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, readableOrStreamOrBufferedStream: BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        return this.ensureWriteQueue(provider, resource, async () => {\r\n\r\n            // open handle\r\n            const handle = await provider.open(resource, {create: true});\r\n\r\n            // write into handle until all bytes from buffer have been written\r\n            try {\r\n                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\r\n                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\r\n                } else {\r\n                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\r\n                }\r\n            } catch (error) {\r\n                throw ensureFileSystemProviderError(error);\r\n            } finally {\r\n\r\n                // close handle always\r\n                await provider.close(handle);\r\n            }\r\n        });\r\n    }\r\n\r\n    private async doWriteStreamBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        let posInFile = 0;\r\n        let stream: BinaryBufferReadableStream;\r\n\r\n        // Buffered stream: consume the buffer first by writing\r\n        // it to the target before reading from the stream.\r\n        if (isReadableBufferedStream(streamOrBufferedStream)) {\r\n            if (streamOrBufferedStream.buffer.length > 0) {\r\n                const chunk = BinaryBuffer.concat(streamOrBufferedStream.buffer);\r\n                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n\r\n                posInFile += chunk.byteLength;\r\n            }\r\n\r\n            // If the stream has been consumed, return early\r\n            if (streamOrBufferedStream.ended) {\r\n                return;\r\n            }\r\n\r\n            stream = streamOrBufferedStream.stream;\r\n        }\r\n\r\n        // Unbuffered stream - just take as is\r\n        else {\r\n            stream = streamOrBufferedStream;\r\n        }\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n\r\n            stream.on('data', async chunk => {\r\n\r\n                // pause stream to perform async write operation\r\n                stream.pause();\r\n\r\n                try {\r\n                    await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n                } catch (error) {\r\n                    return reject(error);\r\n                }\r\n\r\n                posInFile += chunk.byteLength;\r\n\r\n                // resume stream now that we have successfully written\r\n                // run this on the next tick to prevent increasing the\r\n                // execution stack because resume() may call the event\r\n                // handler again before finishing.\r\n                setTimeout(() => stream.resume());\r\n            });\r\n\r\n            stream.on('error', error => reject(error));\r\n            stream.on('end', () => resolve());\r\n        });\r\n    }\r\n\r\n    private async doWriteReadableBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: BinaryBufferReadable): Promise<void> {\r\n        let posInFile = 0;\r\n\r\n        let chunk: BinaryBuffer | null;\r\n        while ((chunk = readable.read()) !== null) {\r\n            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\r\n\r\n            posInFile += chunk.byteLength;\r\n        }\r\n    }\r\n\r\n    private async doWriteBuffer(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: BinaryBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\r\n        let totalBytesWritten = 0;\r\n        while (totalBytesWritten < length) {\r\n            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\r\n            totalBytesWritten += bytesWritten;\r\n        }\r\n    }\r\n\r\n    private async doWriteUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        return this.ensureWriteQueue(provider, resource, () => this.doWriteUnbufferedQueued(provider, resource, bufferOrReadableOrStreamOrBufferedStream));\r\n    }\r\n\r\n    private async doPipeBuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeBufferedQueued(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        let sourceHandle: number | undefined = undefined;\r\n        let targetHandle: number | undefined = undefined;\r\n\r\n        try {\r\n\r\n            // Open handles\r\n            sourceHandle = await sourceProvider.open(source, {create: false});\r\n            targetHandle = await targetProvider.open(target, {create: true});\r\n\r\n            const buffer = BinaryBuffer.alloc(this.BUFFER_SIZE);\r\n\r\n            let posInFile = 0;\r\n            let posInBuffer = 0;\r\n            let bytesRead = 0;\r\n            do {\r\n                // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\r\n                // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\r\n                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\r\n\r\n                // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\r\n                // buffer position (posInBuffer) all bytes we read (bytesRead).\r\n                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\r\n\r\n                posInFile += bytesRead;\r\n                posInBuffer += bytesRead;\r\n\r\n                // when buffer full, fill it again from the beginning\r\n                if (posInBuffer === buffer.byteLength) {\r\n                    posInBuffer = 0;\r\n                }\r\n            } while (bytesRead > 0);\r\n        } catch (error) {\r\n            throw ensureFileSystemProviderError(error);\r\n        } finally {\r\n            await Promise.all([\r\n                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\r\n                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\r\n            ]);\r\n        }\r\n    }\r\n\r\n    private async doWriteUnbufferedQueued(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\r\n        let buffer: BinaryBuffer;\r\n        if (bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer) {\r\n            buffer = bufferOrReadableOrStreamOrBufferedStream;\r\n        } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\r\n            buffer = await BinaryBufferReadableStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\r\n            buffer = await BinaryBufferReadableBufferedStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        } else {\r\n            buffer = BinaryBufferReadable.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\r\n        }\r\n\r\n        return provider.writeFile(resource, buffer.buffer, {create: true, overwrite: true});\r\n    }\r\n\r\n    private async doPipeUnbufferedToBuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\r\n    }\r\n\r\n    private async doPipeUnbufferedToBufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\r\n\r\n        // Open handle\r\n        const targetHandle = await targetProvider.open(target, {create: true});\r\n\r\n        // Read entire buffer from source and write buffered\r\n        try {\r\n            const buffer = await sourceProvider.readFile(source);\r\n            await this.doWriteBuffer(targetProvider, targetHandle, BinaryBuffer.wrap(buffer), buffer.byteLength, 0, 0);\r\n        } catch (error) {\r\n            throw ensureFileSystemProviderError(error);\r\n        } finally {\r\n            await targetProvider.close(targetHandle);\r\n        }\r\n    }\r\n\r\n    private async doPipeBufferedToUnbuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\r\n\r\n        // Read buffer via stream buffered\r\n        const buffer = await BinaryBufferReadableStream.toBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\r\n\r\n        // Write buffer into target at once\r\n        await this.doWriteUnbuffered(targetProvider, target, buffer);\r\n    }\r\n\r\n    private ensureWriteQueue(provider: FileSystemProvider, resource: URI, task: () => Promise<void>): Promise<void> {\r\n        // ensure to never write to the same resource without finishing\r\n        // the one write. this ensures a write finishes consistently\r\n        // (even with error) before another write is done.\r\n        const queueKey = this.toMapKey(provider, resource);\r\n        const writeQueue = (this.writeQueues.get(queueKey) || Promise.resolve()).then(task, task);\r\n        this.writeQueues.set(queueKey, writeQueue);\r\n        return writeQueue;\r\n    }\r\n\r\n    private async mkdirp(provider: FileSystemProvider, directory: URI): Promise<void> {\r\n        const directoriesToCreate: string[] = [];\r\n\r\n        // mkdir until we reach root\r\n        while (!directory.path.isRoot) {\r\n            try {\r\n                const stat = await provider.stat(directory);\r\n                if (stat === undefined) {\r\n                    // Upon error, remember directories that need to be created\r\n                    directoriesToCreate.push(directory.path.base);\r\n\r\n                    // Continue up\r\n                    directory = directory.parent;\r\n                    break;\r\n                }\r\n                if ((stat.type & FileType.Directory) === 0) {\r\n                    throw new Error(`Unable to create folder ${this.resourceForError(directory)} that already exists but is not a directory`);\r\n                }\r\n\r\n                break; // we have hit a directory that exists -> good\r\n            } catch (error) {\r\n\r\n                // Bubble up any other error that is not file not found\r\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\r\n                    throw error;\r\n                }\r\n\r\n                // Upon error, remember directories that need to be created\r\n                directoriesToCreate.push(directory.path.base);\r\n\r\n                // Continue up\r\n                directory = directory.parent;\r\n            }\r\n        }\r\n\r\n        // Create directories as needed\r\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\r\n            directory = directory.resolve(directoriesToCreate[i]);\r\n\r\n            try {\r\n                await provider.mkdir(directory);\r\n            } catch (error) {\r\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\r\n                    // For mkdirp() we tolerate that the mkdir() call fails\r\n                    // in case the folder already exists. This follows node.js\r\n                    // own implementation of fs.mkdir({ recursive: true }) and\r\n                    // reduces the chances of race conditions leading to errors\r\n                    // if multiple calls try to create the same folders\r\n                    // As such, we only throw an error here if it is other than\r\n                    // the fact that the file already exists.\r\n                    // (see also https://github.com/microsoft/vscode/issues/89834)\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async withWriteProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\r\n        const provider = await this.withProvider(resource);\r\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\r\n            return provider;\r\n        }\r\n\r\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\r\n    }\r\n\r\n    private toWatchKey(provider: FileSystemProvider, resource: URI, options: WatchOptions): string {\r\n        return [\r\n            this.toMapKey(provider, resource),  // lowercase path if the provider is case insensitive\r\n            String(options.recursive),          // use recursive: true | false as part of the key\r\n            options.excludes.join()             // use excludes as part of the key\r\n        ].join();\r\n    }\r\n\r\n    private toMapKey(provider: FileSystemProvider, resource: URI): string {\r\n        const isPathCaseSensitive = !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\r\n\r\n        return isPathCaseSensitive ? resource.toString() : resource.toString().toLowerCase();\r\n    }\r\n\r\n    private async doRead(resource: URI, options?: ReadTextFileOptions & { preferUnbuffered?: boolean }): Promise<[FileStreamContent, DecodeStreamResult]> {\r\n        options = this.resolveReadOptions(options);\r\n\r\n        // read stream raw (either buffered or unbuffered)\r\n        let bufferStream: FileStreamContent;\r\n        if (options?.preferUnbuffered) {\r\n            const content = await this.readFile(resource, options);\r\n            bufferStream = {\r\n                ...content,\r\n                value: BinaryBufferReadableStream.fromBuffer(content.value)\r\n            };\r\n        } else {\r\n            bufferStream = await this.readFileStream(resource, options);\r\n        }\r\n\r\n        const decoder = await this.encodingService.decodeStream(bufferStream.value, {\r\n            guessEncoding: options.autoGuessEncoding,\r\n            overwriteEncoding: detectedEncoding => this.getReadEncoding(resource, options, detectedEncoding)\r\n        });\r\n\r\n        // validate binary\r\n        if (options?.acceptTextOnly && decoder.detected.seemsBinary) {\r\n            throw new TextFileOperationError('File seems to be binary and cannot be opened as text', TextFileOperationResult.FILE_IS_BINARY, options);\r\n        }\r\n\r\n        return [bufferStream, decoder];\r\n    }\r\n\r\n    private validateReadFileLimits(resource: URI, size: number, options?: ReadFileOptions): void {\r\n        if (options?.limits) {\r\n            let tooLargeErrorResult: FileOperationResult | undefined = undefined;\r\n\r\n            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {\r\n                tooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\r\n            }\r\n\r\n            if (typeof options.limits.size === 'number' && size > options.limits.size) {\r\n                tooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\r\n            }\r\n\r\n            if (typeof tooLargeErrorResult === 'number') {\r\n                throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is too large to open`, tooLargeErrorResult);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async validateReadFile(resource: URI, options?: ReadFileOptions): Promise<FileStatWithMetadata> {\r\n        const stat = await this.resolve(resource, {resolveMetadata: true});\r\n\r\n        // Throw if resource is a directory\r\n        if (stat.isDirectory) {\r\n            throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\r\n        }\r\n\r\n        // Throw if file not modified since (unless disabled)\r\n        if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\r\n            throw new FileOperationError('File not modified since', FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\r\n        }\r\n\r\n        // Throw if file is too large to load\r\n        this.validateReadFileLimits(resource, stat.size, options);\r\n\r\n        return stat;\r\n    }\r\n\r\n    private async readFileStreamed(provider: FileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): Promise<BinaryBufferReadableStream> {\r\n        const fileStream = await provider.readFileStream(resource, options, token);\r\n\r\n        return Promise.resolve(\r\n            transform(fileStream, {\r\n                data: data => data instanceof BinaryBuffer ? data : BinaryBuffer.wrap(data),\r\n                error: error => this.asFileOperationError('Unable to read file', resource, error, options)\r\n            }, data => BinaryBuffer.concat(data))\r\n        );\r\n    }\r\n\r\n    private async readFileUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, options?: ReadFileOptions): Promise<BinaryBufferReadableStream> {\r\n        let buffer = await provider.readFile(resource);\r\n\r\n        // respect position option\r\n        if (options && typeof options.position === 'number') {\r\n            buffer = buffer.slice(options.position);\r\n        }\r\n\r\n        // respect length option\r\n        if (options && typeof options.length === 'number') {\r\n            buffer = buffer.slice(0, options.length);\r\n        }\r\n\r\n        // Throw if file is too large to load\r\n        this.validateReadFileLimits(resource, buffer.byteLength, options);\r\n\r\n        return BinaryBufferReadableStream.fromBuffer(BinaryBuffer.wrap(buffer));\r\n    }\r\n\r\n    private readFileBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\r\n        const stream = BinaryBufferWriteableStream.create();\r\n\r\n        readFileIntoStream(provider, resource, stream, data => data, {\r\n            ...options,\r\n            bufferSize: this.BUFFER_SIZE,\r\n            errorTransformer: error => this.asFileOperationError('Unable to read file', resource, error, options)\r\n        }, token);\r\n\r\n        return stream;\r\n    }\r\n\r\n    private async doReadAsFileStream(provider: FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options?: ReadFileOptions & { preferUnbuffered?: boolean }): Promise<FileStreamContent> {\r\n\r\n        // install a cancellation token that gets cancelled\r\n        // when any error occurs. this allows us to resolve\r\n        // the content of the file while resolving metadata\r\n        // but still cancel the operation in certain cases.\r\n        const cancellableSource = new CancellationTokenSource();\r\n\r\n        // validate read operation\r\n        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\r\n            cancellableSource.cancel();\r\n\r\n            throw error;\r\n        });\r\n\r\n        try {\r\n\r\n            // if the etag is provided, we await the result of the validation\r\n            // due to the likelyhood of hitting a NOT_MODIFIED_SINCE result.\r\n            // otherwise, we let it run in parallel to the file reading for\r\n            // optimal startup performance.\r\n            if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\r\n                await statPromise;\r\n            }\r\n\r\n            let fileStreamPromise: Promise<BinaryBufferReadableStream>;\r\n\r\n            // read unbuffered (only if either preferred, or the provider has no buffered read capability)\r\n            if (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\r\n                fileStreamPromise = this.readFileUnbuffered(provider, resource, options);\r\n            }\r\n\r\n            // read streamed (always prefer over primitive buffered read)\r\n            else if (hasFileReadStreamCapability(provider)) {\r\n                fileStreamPromise = Promise.resolve(this.readFileStreamed(provider, resource, cancellableSource.token, options));\r\n            }\r\n\r\n            // read buffered\r\n            else {\r\n                fileStreamPromise = Promise.resolve(this.readFileBuffered(provider, resource, cancellableSource.token, options));\r\n            }\r\n\r\n            const [fileStat, fileStream] = await Promise.all([statPromise, fileStreamPromise]);\r\n\r\n            return {\r\n                ...fileStat,\r\n                value: fileStream\r\n            };\r\n        } catch (error) {\r\n            this.rethrowAsFileOperationError('Unable to read file', resource, error, options);\r\n        }\r\n    }\r\n\r\n    private async withReadProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\r\n        const provider = await this.withProvider(resource);\r\n\r\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\r\n            return provider;\r\n        }\r\n\r\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\r\n    }\r\n\r\n\r\n    protected async useLocalFileSystem(): Promise<any> {\r\n        const provider = await this.activateProvider('file');\r\n        // @ts-ignore\r\n        provider.useLocal();\r\n    }\r\n    /**\r\n     * Converts to an underlying fs provider resource format.\r\n     *\r\n     * For example converting `user-storage` resources to `file` resources under a user home:\r\n     * user-storage:/user/settings.json => file://home/.tart/settings.json\r\n     */\r\n    // async toUnderlyingResource(resource: URI): Promise<URI> {\r\n    //     let provider = await this.withProvider(resource);\r\n    //     while (provider instanceof DelegatingFileSystemProvider) {\r\n    //         resource = provider.toUnderlyingResource(resource);\r\n    //         provider = await this.withProvider(resource);\r\n    //     }\r\n    //     return resource;\r\n    // }\r\n\r\n    // protected handleFileWatchError(): void {\r\n    //     this.watcherErrorHandler.handleError();\r\n    // }\r\n}\r\n"]}