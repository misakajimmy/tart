{"version":3,"sources":["browser/file-tree/file-tree-model.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgB,aAAa,EAAE,aAAa,EAAE,QAAQ,EAAC,MAAM,YAAY,CAAC;AAEjF,OAAO,EAAC,WAAW,EAAC,MAAM,iBAAiB,CAAC;AAC5C,OAAO,EAAoB,YAAY,EAAC,MAAM,aAAa,CAAC;AAC5D,OAAO,GAAG,MAAM,2BAA2B,CAAC;AAC5C,OAAO,EAAC,cAAc,EAAC,MAAM,uBAAuB,CAAC;AAErD,OAAO,EACH,UAAU,EACV,gBAAgB,EAIhB,kBAAkB,EAErB,MAAM,oBAAoB,CAAC;AAC5B,OAAO,EAAC,eAAe,EAAC,MAAM,aAAa,CAAC;AAC5C,OAAO,EAAC,iBAAiB,EAAC,MAAM,wBAAwB,CAAC;AAEzD,qBACa,aAAc,SAAQ,aAAc,YAAW,eAAe;IAEhD,SAAS,CAAC,QAAQ,CAAC,aAAa,EAAE,aAAa,CAAC;IAGvE,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,WAAW,CAAC;IAG5C,SAAS,CAAC,QAAQ,CAAC,cAAc,EAAE,cAAc,CAAC;IAElD,IAAI,QAAQ,IAAI,GAAG,GAAG,SAAS,CAM9B;IAED,IAAI,QAAQ,CAAC,GAAG,EAAE,GAAG,GAAG,SAAS,EAahC;IAED,IAAI,qBAAqB,IAAI,QAAQ,CAAC,YAAY,CAAC,EAAE,CAEpD;IAEK,MAAM,IAAI,OAAO,CAAC,GAAG,EAAE,CAAC;IAU5B,aAAa,CAAC,GAAG,EAAE,GAAG,GAAG,gBAAgB,CAAC,QAAQ,CAAC;IAO/C,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,QAAQ,CAAC,YAAY,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC;IAerE;;OAEG;IACG,IAAI,CAAC,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,GAAG,OAAO,CAAC,GAAG,GAAG,SAAS,CAAC;IA4BxE,SAAS,CAAC,IAAI,IAAI,IAAI;IAMtB;;OAEG;IACH,SAAS,CAAC,SAAS,CAAC,KAAK,EAAE,kBAAkB,GAAG,IAAI;IAcpD,SAAS,CAAC,cAAc,CAAC,OAAO,EAAE,gBAAgB,GAAG,IAAI;IAMzD,SAAS,CAAC,cAAc,CAAC,OAAO,EAAE,gBAAgB,GAAG,OAAO;IAQ5D,SAAS,CAAC,eAAe,CAAC,OAAO,EAAE,gBAAgB,GAAG,GAAG,EAAE;IAI3D,SAAS,CAAC,oBAAoB,CAAC,MAAM,EAAE,UAAU,GAAG,OAAO;IAI3D,SAAS,CAAC,oBAAoB,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,OAAO;IAQpD,SAAS,CAAC,gBAAgB,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,GAAG,CAAC,MAAM,EAAE,iBAAiB,CAAC;cAYvD,aAAa,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;CAUpE","file":"../../../src/browser/file-tree/file-tree-model.d.ts","sourcesContent":["import {ConfirmDialog, LabelProvider, TreeModelImpl, TreeNode} from '@tart/core';\r\nimport {inject, injectable, postConstruct} from 'inversify';\r\nimport {FileService} from '../file-service';\r\nimport {DirNode, FileNode, FileStatNode} from './file-tree';\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {MessageService} from '@tart/core/lib/common';\r\nimport {FileSystemUtils} from './filesystem-utils';\r\nimport {\r\n    FileChange,\r\n    FileChangesEvent,\r\n    FileChangeType,\r\n    FileOperation,\r\n    FileOperationError,\r\n    FileOperationEvent,\r\n    FileOperationResult\r\n} from '../../common/files';\r\nimport {LocationService} from '../location';\r\nimport {CompositeTreeNode} from '@tart/core/lib/browser';\r\n\r\n@injectable()\r\nexport class FileTreeModel extends TreeModelImpl implements LocationService {\r\n\r\n    @inject(LabelProvider) protected readonly labelProvider: LabelProvider;\r\n\r\n    @inject(FileService)\r\n    protected readonly fileService: FileService;\r\n\r\n    @inject(MessageService)\r\n    protected readonly messageService: MessageService;\r\n\r\n    get location(): URI | undefined {\r\n        const root = this.root;\r\n        if (FileStatNode.is(root)) {\r\n            return root.uri;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    set location(uri: URI | undefined) {\r\n        if (uri) {\r\n            this.fileService.resolve(uri).then(fileStat => {\r\n                if (fileStat) {\r\n                    const node = DirNode.createRoot(fileStat);\r\n                    this.navigateTo(node);\r\n                }\r\n            }).catch(() => {\r\n                // no-op, allow failures for file dialog text input\r\n            });\r\n        } else {\r\n            this.navigateTo(undefined);\r\n        }\r\n    }\r\n\r\n    get selectedFileStatNodes(): Readonly<FileStatNode>[] {\r\n        return this.selectedNodes.filter(FileStatNode.is);\r\n    }\r\n\r\n    async drives(): Promise<URI[]> {\r\n        try {\r\n            // const drives = await this.environments.getDrives();\r\n            // return drives.map(uri => new URI(uri));\r\n            return [];\r\n        } catch (e) {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    * getNodesByUri(uri: URI): IterableIterator<TreeNode> {\r\n        const node = this.getNode(uri.toString());\r\n        if (node) {\r\n            yield node;\r\n        }\r\n    }\r\n\r\n    async copy(source: URI, target: Readonly<FileStatNode>): Promise<URI> {\r\n        let targetUri = target.uri.resolve(source.path.base);\r\n        try {\r\n            if (source.path.toString() === target.uri.path.toString()) {\r\n                const parent = await this.fileService.resolve(source.parent);\r\n                const name = source.path.name + '_copy';\r\n                targetUri = FileSystemUtils.generateUniqueResourceURI(source.parent, parent, name, source.path.ext);\r\n            }\r\n            await this.fileService.copy(source, targetUri);\r\n        } catch (e) {\r\n            this.messageService.error(e.message);\r\n        }\r\n        return targetUri;\r\n    }\r\n\r\n    /**\r\n     * Move the given source file or directory to the given target directory.\r\n     */\r\n    async move(source: TreeNode, target: TreeNode): Promise<URI | undefined> {\r\n        if (DirNode.is(target) && FileStatNode.is(source)) {\r\n            const name = source.fileStat.name;\r\n            const targetUri = target.uri.resolve(name);\r\n            try {\r\n                await this.fileService.move(source.uri, targetUri);\r\n                return targetUri;\r\n            } catch (e) {\r\n                console.log(e);\r\n                if (e instanceof FileOperationError && e.fileOperationResult === FileOperationResult.FILE_MOVE_CONFLICT) {\r\n                    const fileName = this.labelProvider.getName(source);\r\n                    if (await this.shouldReplace(fileName)) {\r\n                        try {\r\n                            await this.fileService.move(source.uri, targetUri, {overwrite: true});\r\n                            return targetUri;\r\n                        } catch (e2) {\r\n                            this.messageService.error(e2.message);\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.messageService.error(e.message);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    @postConstruct()\r\n    protected init(): void {\r\n        super.init();\r\n        this.toDispose.push(this.fileService.onDidFilesChange(changes => this.onFilesChanged(changes)));\r\n        this.toDispose.push(this.fileService.onDidRunOperation(event => this.onDidMove(event)));\r\n    }\r\n\r\n    /**\r\n     * to workaround https://github.com/Axosoft/nsfw/issues/42\r\n     */\r\n    protected onDidMove(event: FileOperationEvent): void {\r\n        if (!event.isOperation(FileOperation.MOVE)) {\r\n            return;\r\n        }\r\n        if (event.resource.parent.toString() === event.target.resource.parent.toString()) {\r\n            // file rename\r\n            return;\r\n        }\r\n        this.refreshAffectedNodes([\r\n            event.resource,\r\n            event.target.resource\r\n        ]);\r\n    }\r\n\r\n    protected onFilesChanged(changes: FileChangesEvent): void {\r\n        if (!this.refreshAffectedNodes(this.getAffectedUris(changes))) {\r\n            this.refresh();\r\n        }\r\n    }\r\n\r\n    protected isRootAffected(changes: FileChangesEvent): boolean {\r\n        const root = this.root;\r\n        if (FileStatNode.is(root)) {\r\n            return changes.contains(root.uri, FileChangeType.ADDED) || changes.contains(root.uri, FileChangeType.UPDATED);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected getAffectedUris(changes: FileChangesEvent): URI[] {\r\n        return changes.changes.filter(change => !this.isFileContentChanged(change)).map(change => change.resource);\r\n    }\r\n\r\n    protected isFileContentChanged(change: FileChange): boolean {\r\n        return change.type === FileChangeType.UPDATED && FileNode.is(this.getNodesByUri(change.resource).next().value);\r\n    }\r\n\r\n    protected refreshAffectedNodes(uris: URI[]): boolean {\r\n        const nodes = this.getAffectedNodes(uris);\r\n        for (const node of nodes.values()) {\r\n            this.refresh(node);\r\n        }\r\n        return nodes.size !== 0;\r\n    }\r\n\r\n    protected getAffectedNodes(uris: URI[]): Map<string, CompositeTreeNode> {\r\n        const nodes = new Map<string, CompositeTreeNode>();\r\n        for (const uri of uris) {\r\n            for (const node of this.getNodesByUri(uri.parent)) {\r\n                if (DirNode.is(node) && node.expanded) {\r\n                    nodes.set(node.id, node);\r\n                }\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    protected async shouldReplace(fileName: string): Promise<boolean> {\r\n        const dialog = new ConfirmDialog({\r\n            title: 'Replace file',\r\n            msg: `File '${fileName}' already exists in the destination folder. Do you want to replace it?`,\r\n            ok: 'Yes',\r\n            cancel: 'No'\r\n        });\r\n        return !!await dialog.open();\r\n    }\r\n\r\n}\r\n"]}