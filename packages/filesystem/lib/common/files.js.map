{"version":3,"sources":["common/files.ts"],"names":[],"mappings":"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","file":"../../src/common/files.js","sourcesContent":["/********************************************************************************\r\n * Copyright (C) 2020 TypeFox and others.\r\n *\r\n * This program and the accompanying materials are made available under the\r\n * terms of the Eclipse Public License v. 2.0 which is available at\r\n * http://www.eclipse.org/legal/epl-2.0.\r\n *\r\n * This Source Code may also be made available under the following Secondary\r\n * Licenses when the conditions for such availability set forth in the Eclipse\r\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\r\n * with the GNU Classpath Exception which is available at\r\n * https://www.gnu.org/software/classpath/license.html.\r\n *\r\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\r\n ********************************************************************************/\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/files.ts\r\n\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {Event} from '@tart/core/lib/common/event';\r\nimport {Disposable as IDisposable} from '@tart/core/lib/common/disposable';\r\n// import { BinaryBuffer, BinaryBufferReadableStream } from '@tart/core/lib/common/buffer';\r\nimport type {TextDocumentContentChangeEvent} from 'vscode-languageserver-protocol';\r\nimport {ReadableStreamEvents} from '@tart/core/lib/common/stream';\r\nimport {CancellationToken} from '@tart/core/lib/common/cancellation';\r\nimport {BinaryBuffer, BinaryBufferReadableStream} from '@tart/core/lib/common/buffer';\r\n\r\nexport const enum FileOperation {\r\n    CREATE,\r\n    DELETE,\r\n    MOVE,\r\n    COPY\r\n}\r\n\r\nexport class FileOperationEvent {\r\n\r\n    constructor(resource: URI, operation: FileOperation.DELETE);\r\n    constructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: FileStatWithMetadata);\r\n    constructor(public readonly resource: URI, public readonly operation: FileOperation, public readonly target?: FileStatWithMetadata) {\r\n    }\r\n\r\n    isOperation(operation: FileOperation.DELETE): boolean;\r\n    isOperation(operation: FileOperation.MOVE | FileOperation.COPY | FileOperation.CREATE): this is { readonly target: FileStatWithMetadata };\r\n    isOperation(operation: FileOperation): boolean {\r\n        return this.operation === operation;\r\n    }\r\n}\r\n\r\n/**\r\n * Possible changes that can occur to a file.\r\n */\r\nexport const enum FileChangeType {\r\n    UPDATED = 0,\r\n    ADDED = 1,\r\n    DELETED = 2\r\n}\r\n\r\n/**\r\n * Identifies a single change in a file.\r\n */\r\nexport interface FileChange {\r\n\r\n    /**\r\n     * The type of change that occurred to the file.\r\n     */\r\n    readonly type: FileChangeType;\r\n\r\n    /**\r\n     * The unified resource identifier of the file that changed.\r\n     */\r\n    readonly resource: URI;\r\n}\r\n\r\nexport class FileChangesEvent {\r\n\r\n    constructor(public readonly changes: readonly FileChange[]) {\r\n    }\r\n\r\n    /**\r\n     * Returns true if this change event contains the provided file with the given change type (if provided). In case of\r\n     * type DELETED, this method will also return true if a folder got deleted that is the parent of the\r\n     * provided file path.\r\n     */\r\n    contains(resource: URI, type?: FileChangeType): boolean {\r\n        if (!resource) {\r\n            return false;\r\n        }\r\n\r\n        const checkForChangeType = typeof type === 'number';\r\n\r\n        return this.changes.some(change => {\r\n            if (checkForChangeType && change.type !== type) {\r\n                return false;\r\n            }\r\n\r\n            // For deleted also return true when deleted folder is parent of target path\r\n            if (change.type === FileChangeType.DELETED) {\r\n                return resource.isEqualOrParent(change.resource);\r\n            }\r\n\r\n            return resource.toString() === change.resource.toString();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the changes that describe added files.\r\n     */\r\n    getAdded(): FileChange[] {\r\n        return this.getOfType(FileChangeType.ADDED);\r\n    }\r\n\r\n    /**\r\n     * Returns if this event contains added files.\r\n     */\r\n    gotAdded(): boolean {\r\n        return this.hasType(FileChangeType.ADDED);\r\n    }\r\n\r\n    /**\r\n     * Returns the changes that describe deleted files.\r\n     */\r\n    getDeleted(): FileChange[] {\r\n        return this.getOfType(FileChangeType.DELETED);\r\n    }\r\n\r\n    /**\r\n     * Returns if this event contains deleted files.\r\n     */\r\n    gotDeleted(): boolean {\r\n        return this.hasType(FileChangeType.DELETED);\r\n    }\r\n\r\n    /**\r\n     * Returns the changes that describe updated files.\r\n     */\r\n    getUpdated(): FileChange[] {\r\n        return this.getOfType(FileChangeType.UPDATED);\r\n    }\r\n\r\n    /**\r\n     * Returns if this event contains updated files.\r\n     */\r\n    gotUpdated(): boolean {\r\n        return this.hasType(FileChangeType.UPDATED);\r\n    }\r\n\r\n    private getOfType(type: FileChangeType): FileChange[] {\r\n        return this.changes.filter(change => change.type === type);\r\n    }\r\n\r\n    private hasType(type: FileChangeType): boolean {\r\n        return this.changes.some(change => change.type === type);\r\n    }\r\n}\r\n\r\nexport interface BaseStat {\r\n\r\n    /**\r\n     * The unified resource identifier of this file or folder.\r\n     */\r\n    resource: URI;\r\n\r\n    /**\r\n     * The name which is the last segment\r\n     * of the {{path}}.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The size of the file.\r\n     *\r\n     * The value may or may not be resolved as\r\n     * it is optional.\r\n     */\r\n    size?: number;\r\n\r\n    /**\r\n     * The last modification date represented as millis from unix epoch.\r\n     *\r\n     * The value may or may not be resolved as\r\n     * it is optional.\r\n     */\r\n    mtime?: number;\r\n\r\n    /**\r\n     * The creation date represented as millis from unix epoch.\r\n     *\r\n     * The value may or may not be resolved as\r\n     * it is optional.\r\n     */\r\n    ctime?: number;\r\n\r\n    /**\r\n     * A unique identifier that represents the\r\n     * current state of the file or directory.\r\n     *\r\n     * The value may or may not be resolved as\r\n     * it is optional.\r\n     */\r\n    etag?: string;\r\n}\r\n\r\nexport namespace BaseStat {\r\n    export function is(arg: Object | undefined): arg is BaseStat {\r\n        return !!arg && typeof arg === 'object'\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            && ('resource' in arg && <any>arg['resource'] instanceof URI)\r\n            && ('name' in arg && typeof arg['name'] === 'string');\r\n    }\r\n}\r\n\r\nexport interface BaseStatWithMetadata extends BaseStat {\r\n    mtime: number;\r\n    ctime: number;\r\n    etag: string;\r\n    size: number;\r\n}\r\n\r\n/**\r\n * A file resource with meta information.\r\n */\r\nexport interface FileStat extends BaseStat {\r\n\r\n    /**\r\n     * The resource is a file.\r\n     */\r\n    isFile: boolean;\r\n\r\n    /**\r\n     * The resource is a directory.\r\n     */\r\n    isDirectory: boolean;\r\n\r\n    /**\r\n     * The resource is a symbolic link.\r\n     */\r\n    isSymbolicLink: boolean;\r\n\r\n    /**\r\n     * The children of the file stat or undefined if none.\r\n     */\r\n    children?: FileStat[];\r\n}\r\n\r\nexport namespace FileStat {\r\n    export function is(arg: Object | undefined): arg is FileStat {\r\n        return BaseStat.is(arg) &&\r\n            ('isFile' in arg && typeof arg['isFile'] === 'boolean') &&\r\n            ('isDirectory' in arg && typeof arg['isDirectory'] === 'boolean') &&\r\n            ('isSymbolicLink' in arg && typeof arg['isSymbolicLink'] === 'boolean');\r\n    }\r\n\r\n    export function asFileType(stat: FileStat): FileType {\r\n        let res = 0;\r\n        if (stat.isFile) {\r\n            res += FileType.File;\r\n\r\n        } else if (stat.isDirectory) {\r\n            res += FileType.Directory;\r\n        }\r\n        if (stat.isSymbolicLink) {\r\n            res += FileType.SymbolicLink;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    export function toStat(stat: FileStat): Stat | { type: FileType } & Partial<Stat> {\r\n        return {\r\n            type: asFileType(stat),\r\n            ctime: stat.ctime,\r\n            mtime: stat.mtime,\r\n            size: stat.size\r\n        };\r\n    }\r\n\r\n    export function fromStat(resource: URI, stat: Stat): FileStatWithMetadata;\r\n    export function fromStat(resource: URI, stat: { type: FileType } & Partial<Stat>): FileStat;\r\n    export function fromStat(resource: URI, stat: Stat | { type: FileType } & Partial<Stat>): FileStat {\r\n        return {\r\n            resource,\r\n            name: resource.path.base || resource.path.toString(),\r\n            isFile: (stat.type & FileType.File) !== 0,\r\n            isDirectory: (stat.type & FileType.Directory) !== 0,\r\n            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\r\n            mtime: stat.mtime,\r\n            ctime: stat.ctime,\r\n            size: stat.size,\r\n            etag: etag({mtime: stat.mtime, size: stat.size})\r\n        };\r\n    }\r\n\r\n    export function dir(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\r\n        return fromStat(resource instanceof URI ? resource : new URI(resource), {type: FileType.Directory, ...stat});\r\n    }\r\n\r\n    export function file(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\r\n        return fromStat(resource instanceof URI ? resource : new URI(resource), {type: FileType.File, ...stat});\r\n    }\r\n}\r\n\r\nexport interface FileStatWithMetadata extends FileStat, BaseStatWithMetadata {\r\n    mtime: number;\r\n    ctime: number;\r\n    etag: string;\r\n    size: number;\r\n    children?: FileStatWithMetadata[];\r\n}\r\n\r\nexport interface ResolveFileResult {\r\n    stat?: FileStat;\r\n    success: boolean;\r\n}\r\n\r\nexport interface ResolveFileResultWithMetadata extends ResolveFileResult {\r\n    stat?: FileStatWithMetadata;\r\n}\r\n\r\nexport interface FileContent extends BaseStatWithMetadata {\r\n\r\n    /**\r\n     * The content of a file as buffer.\r\n     */\r\n    value: BinaryBuffer;\r\n}\r\n\r\nexport interface FileStreamContent extends BaseStatWithMetadata {\r\n\r\n    /**\r\n     * The content of a file as stream.\r\n     */\r\n    value: BinaryBufferReadableStream;\r\n}\r\n\r\nexport interface WriteFileOptions {\r\n\r\n    /**\r\n     * The last known modification time of the file. This can be used to prevent dirty writes.\r\n     */\r\n    readonly mtime?: number;\r\n\r\n    /**\r\n     * The etag of the file. This can be used to prevent dirty writes.\r\n     */\r\n    readonly etag?: string;\r\n}\r\n\r\nexport interface ReadFileOptions extends FileReadStreamOptions {\r\n\r\n    /**\r\n     * The optional etag parameter allows to return early from resolving the resource if\r\n     * the contents on disk match the etag. This prevents accumulated reading of resources\r\n     * that have been read already with the same etag.\r\n     * It is the task of the caller to makes sure to handle this error case from the promise.\r\n     */\r\n    readonly etag?: string;\r\n}\r\n\r\nexport interface WriteFileOptions {\r\n\r\n    /**\r\n     * The last known modification time of the file. This can be used to prevent dirty writes.\r\n     */\r\n    readonly mtime?: number;\r\n\r\n    /**\r\n     * The etag of the file. This can be used to prevent dirty writes.\r\n     */\r\n    readonly etag?: string;\r\n}\r\n\r\nexport interface ResolveFileOptions {\r\n\r\n    /**\r\n     * Automatically continue resolving children of a directory until the provided resources\r\n     * are found.\r\n     */\r\n    readonly resolveTo?: readonly URI[];\r\n\r\n    /**\r\n     * Automatically continue resolving children of a directory if the number of children is 1.\r\n     */\r\n    readonly resolveSingleChildDescendants?: boolean;\r\n\r\n    /**\r\n     * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\r\n     * on performance and thus should only be used when these values are required.\r\n     */\r\n    readonly resolveMetadata?: boolean;\r\n}\r\n\r\nexport interface ResolveMetadataFileOptions extends ResolveFileOptions {\r\n    readonly resolveMetadata: true;\r\n}\r\n\r\nexport interface FileOperationOptions {\r\n    /**\r\n     * Indicates that a user action triggered the opening, e.g.\r\n     * via mouse or keyboard use. Default is true.\r\n     */\r\n    fromUserGesture?: boolean\r\n}\r\n\r\nexport interface MoveFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\r\n}\r\n\r\nexport interface CopyFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\r\n}\r\n\r\nexport interface CreateFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\r\n}\r\n\r\nexport class FileOperationError extends Error {\r\n    constructor(message: string, public fileOperationResult: FileOperationResult, public options?: ReadFileOptions & WriteFileOptions & CreateFileOptions) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, FileOperationError.prototype);\r\n    }\r\n}\r\n\r\nexport const enum FileOperationResult {\r\n    FILE_IS_DIRECTORY,\r\n    FILE_NOT_FOUND,\r\n    FILE_NOT_MODIFIED_SINCE,\r\n    FILE_MODIFIED_SINCE,\r\n    FILE_MOVE_CONFLICT,\r\n    FILE_READ_ONLY,\r\n    FILE_PERMISSION_DENIED,\r\n    FILE_TOO_LARGE,\r\n    FILE_INVALID_PATH,\r\n    FILE_EXCEEDS_MEMORY_LIMIT,\r\n    FILE_NOT_DIRECTORY,\r\n    FILE_OTHER_ERROR\r\n}\r\n\r\nexport interface FileOverwriteOptions {\r\n    /**\r\n     * Overwrite the file to create if it already exists on disk. Otherwise\r\n     * an error will be thrown (FILE_MODIFIED_SINCE).\r\n     */\r\n    overwrite: boolean;\r\n}\r\n\r\nexport interface FileReadStreamOptions {\r\n\r\n    /**\r\n     * Is an integer specifying where to begin reading from in the file. If position is undefined,\r\n     * data will be read from the current file position.\r\n     */\r\n    readonly position?: number;\r\n\r\n    /**\r\n     * Is an integer specifying how many bytes to read from the file. By default, all bytes\r\n     * will be read.\r\n     */\r\n    readonly length?: number;\r\n\r\n    /**\r\n     * If provided, the size of the file will be checked against the limits.\r\n     */\r\n    limits?: {\r\n        readonly size?: number;\r\n        readonly memory?: number;\r\n    };\r\n}\r\n\r\nexport interface FileUpdateOptions {\r\n    readEncoding: string;\r\n    writeEncoding: string;\r\n    overwriteEncoding: boolean;\r\n}\r\n\r\nexport interface FileUpdateResult extends Stat {\r\n    encoding: string;\r\n}\r\n\r\nexport interface FileWriteOptions {\r\n    overwrite: boolean;\r\n    create: boolean;\r\n}\r\n\r\nexport interface FileOpenOptions {\r\n    create: boolean;\r\n}\r\n\r\nexport interface FileDeleteOptions {\r\n    recursive: boolean;\r\n    useTrash: boolean;\r\n}\r\n\r\nexport enum FileType {\r\n    Unknown = 0,\r\n    File = 1,\r\n    Directory = 2,\r\n    SymbolicLink = 64\r\n}\r\n\r\nexport interface Stat {\r\n    type: FileType;\r\n\r\n    /**\r\n     * The last modification date represented as millis from unix epoch.\r\n     */\r\n    mtime: number;\r\n\r\n    /**\r\n     * The creation date represented as millis from unix epoch.\r\n     */\r\n    ctime: number;\r\n\r\n    size: number;\r\n}\r\n\r\nexport interface WatchOptions {\r\n    recursive: boolean;\r\n    excludes: string[];\r\n}\r\n\r\nexport const enum FileSystemProviderCapabilities {\r\n    FileReadWrite = 1 << 1,\r\n    FileOpenReadWriteClose = 1 << 2,\r\n    FileReadStream = 1 << 4,\r\n\r\n    FileFolderCopy = 1 << 3,\r\n\r\n    PathCaseSensitive = 1 << 10,\r\n    Readonly = 1 << 11,\r\n\r\n    Trash = 1 << 12,\r\n\r\n    Access = 1 << 24,\r\n    Update = 1 << 25\r\n}\r\n\r\nexport enum FileSystemProviderErrorCode {\r\n    FileExists = 'EntryExists',\r\n    FileNotFound = 'EntryNotFound',\r\n    FileNotADirectory = 'EntryNotADirectory',\r\n    FileIsADirectory = 'EntryIsADirectory',\r\n    FileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\r\n    FileTooLarge = 'EntryTooLarge',\r\n    NoPermissions = 'NoPermissions',\r\n    Unavailable = 'Unavailable',\r\n    Unknown = 'Unknown'\r\n}\r\n\r\nexport class FileSystemProviderError extends Error {\r\n\r\n    constructor(message: string, public readonly code: FileSystemProviderErrorCode) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, FileSystemProviderError.prototype);\r\n    }\r\n}\r\n\r\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\r\n    const providerError = new FileSystemProviderError(error.toString(), code);\r\n    markAsFileSystemProviderError(providerError, code);\r\n\r\n    return providerError;\r\n}\r\n\r\nexport function ensureFileSystemProviderError(error?: Error): Error {\r\n    if (!error) {\r\n        return createFileSystemProviderError('Unknown Error', FileSystemProviderErrorCode.Unknown); // https://github.com/Microsoft/vscode/issues/72798\r\n    }\r\n\r\n    return error;\r\n}\r\n\r\nexport const FileSystemProvider = Symbol('FileSystemProvider');\r\n\r\n/**\r\n * A {@link FileSystemProvider} provides the capabilities to read, write, discover, and to manage files and folders\r\n * of the underlying (potentially virtual) file system. {@link FileSystemProvider}s can be used to serve files from both the\r\n * local disk as well as remote locations like ftp-servers, REST-services etc. A {@link FileSystemProvider} is registered for a certain\r\n * scheme and can handle all resources whose uri does conform to that scheme.\r\n */\r\nexport interface FileSystemProvider {\r\n\r\n    /** The {@link FileSystemProviderCapabilities} for this provider. */\r\n    readonly capabilities: FileSystemProviderCapabilities;\r\n\r\n    /** * Event that is fired if the capabilities of this provider have changed. */\r\n    readonly onDidChangeCapabilities: Event<void>;\r\n\r\n    /** Event that is fired if a (watched) file in the filesystem of this provider has changed. */\r\n    readonly onDidChangeFile: Event<readonly FileChange[]>;\r\n\r\n    /** Event that is fired if an error occurred when watching files in the filesystem of this provider. */\r\n    readonly onFileWatchError: Event<void>;\r\n\r\n    /**\r\n     * Watch the given resource and react to changes by firing the {@link FileSystemProvider#onDidChangeFile} event.\r\n     * @param resource `URI` of the resource to be watched.\r\n     * @param opts Options to define if the resource should be watched recursively and to\r\n     *  provide a set of resources that should be excluded from watching.\r\n     *\r\n     * @returns A `Disposable` that can be invoked to stop watching the resource.\r\n     */\r\n    watch(resource: URI, opts: WatchOptions): IDisposable;\r\n\r\n    /**\r\n     * Retrieve metadata about a given file.\r\n     *\r\n     * @param uri The `URI` of the file to retrieve meta data about.\r\n     * @returns A promise of the metadata about the resource.\r\n     */\r\n    stat(resource: URI): Promise<Stat>;\r\n\r\n    /**\r\n     * Create a new directory using the given resource uri.\r\n     * @param resource The `URI` of the new folder.\r\n     */\r\n    mkdir(resource: URI): Promise<void>;\r\n\r\n    /**\r\n     * Retrieve the content of a given directory.\r\n     * @param resource The `URI` of the directory.\r\n     *\r\n     * @returns A map containing the {@link FileType} for each child resource, identified by name.\r\n     */\r\n    readdir(resource: URI): Promise<[string, FileType][]>;\r\n\r\n    /**\r\n     * Delete the given resource.\r\n     * @param resource The `URI` of the resource to delete.\r\n     * @param opts Options to define if files should be deleted recursively and if the trash should be used.\r\n     */\r\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void>;\r\n\r\n    /**\r\n     * Rename a file or folder.\r\n     * @param from `URI` of the existing file or folder.\r\n     * @param to `URI` of the target location.\r\n     * @param opts Options to define if existing files should be overwritten.\r\n     */\r\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileFolderCopyCapability}.\r\n     * See {@link FileSystemProviderWithFileFolderCopyCapability#copy}} for additional documentation.\r\n     */\r\n    copy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\r\n     * See {@link FileSystemProviderWithFileReadWriteCapability#readFile} for additional documentation.\r\n     */\r\n    readFile?(resource: URI): Promise<Uint8Array>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\r\n     * See {@link FileSystemProviderWithFileReadWriteCapability#writeFile} for additional documentation.\r\n     */\r\n    writeFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadStreamCapability}.\r\n     * See {@link FileSystemProviderWithFileReadStreamCapability#readFileStream} for additional documentation.\r\n     */\r\n    readFileStream?(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): Promise<ReadableStreamEvents<Uint8Array>>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\r\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#open} for additional documentation.\r\n     */\r\n    open?(resource: URI, opts: FileOpenOptions): Promise<number>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\r\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#close} for additional documentation.\r\n     */\r\n    close?(fd: number): Promise<void>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\r\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#read} for additional documentation.\r\n     */\r\n    read?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\r\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#write} for additional documentation.\r\n     */\r\n    write?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\r\n     * See {@link FileSystemProviderWithAccessCapability#access} for additional documentation.\r\n     */\r\n    access?(resource: URI, mode?: number): Promise<void>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\r\n     * See {@link FileSystemProviderWithAccessCapability#fsPath} for additional documentation.\r\n     */\r\n    fsPath?(resource: URI): Promise<string>;\r\n\r\n    /**\r\n     * Optional function that has to be implemented by {@link FileSystemProviderWithUpdateCapability}.\r\n     * See {@link FileSystemProviderWithUpdateCapability#updateFile} for additional documentation.\r\n     */\r\n    updateFile?(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed for providers, that should be\r\n * able access files, are implemented.\r\n */\r\nexport interface FileSystemProviderWithAccessCapability extends FileSystemProvider {\r\n    /**\r\n     * Test if the user has the permission to access the given file in the specified mode.\r\n     * @param resource The `URI` of the file that should be tested.\r\n     * @param mode The access mode that should be tested.\r\n     *\r\n     * @returns A promise that resolves if the user has the required permissions, should be rejected otherwise.\r\n     */\r\n    access(resource: URI, mode?: number): Promise<void>;\r\n\r\n    /**\r\n     * Derive the platform specific file system path that is represented by the resource.\r\n     * @param resource `URI` of the resource to derive the path from.\r\n     *\r\n     * @returns A promise of the corresponding file system path.\r\n     */\r\n    fsPath(resource: URI): Promise<string>;\r\n}\r\n\r\nexport function hasAccessCapability(provider: FileSystemProvider): provider is FileSystemProviderWithAccessCapability {\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Access);\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed, for providers that should be\r\n * able to update (text) files, are implemented.\r\n */\r\nexport interface FileSystemProviderWithUpdateCapability extends FileSystemProvider {\r\n    /**\r\n     * Update the content of the given (text) file according to the given text document changes.\r\n     * @param resource `URI` of the resource to update.\r\n     * @param changes Array of events describing the changes to the file.\r\n     * @param opts The encoding options.\r\n     *\r\n     * @returns A promise of the file metadata that resolves after the update process has completed.\r\n     */\r\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\r\n}\r\n\r\nexport function hasUpdateCapability(provider: FileSystemProvider): provider is FileSystemProviderWithUpdateCapability {\r\n    console.log(provider.capabilities & FileSystemProviderCapabilities.Update);\r\n    console.log(provider);\r\n    console.log(FileSystemProviderCapabilities.Update);\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Update);\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers\r\n * that should be able to read & write files, are implemented.\r\n */\r\nexport interface FileSystemProviderWithFileReadWriteCapability extends FileSystemProvider {\r\n    /**\r\n     * Read the contents of the given file as stream.\r\n     * @param resource The `URI` of the file.\r\n     *\r\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\r\n     */\r\n    readFile(resource: URI): Promise<Uint8Array>;\r\n\r\n    /**\r\n     *  Write data to a file, replacing its entire contents.\r\n     * @param resource The uri of the file.\r\n     * @param content The new content of the file.\r\n     * @param opts Options to define if the file should be created if missing and if an existing file should be overwritten.\r\n     */\r\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\r\n}\r\n\r\nexport function hasReadWriteCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadWriteCapability {\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to copy\r\n * file folders, are implemented.\r\n */\r\nexport interface FileSystemProviderWithFileFolderCopyCapability extends FileSystemProvider {\r\n    /**\r\n     * Copy files or folders.\r\n     * @param from `URI` of the existing file or folder.\r\n     * @param to `URI` of the destination location.\r\n     * @param opts Options to define if existing files should be overwritten.\r\n     */\r\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\r\n}\r\n\r\nexport function hasFileFolderCopyCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileFolderCopyCapability {\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to open,read, write\r\n * or close files, are implemented.\r\n */\r\nexport interface FileSystemProviderWithOpenReadWriteCloseCapability extends FileSystemProvider {\r\n    /**\r\n     * Open the give file.\r\n     * @param resource The `URI` of the file to open.\r\n     * @param opts Options to define if the file should be created if it does not exist yet.\r\n     *\r\n     * @returns A promise of the file descriptor that resolves after the file is open.\r\n     */\r\n    open(resource: URI, opts: FileOpenOptions): Promise<number>;\r\n\r\n    /**\r\n     * Close the file with the given file descriptor.\r\n     * @param fd the file descriptor to close.\r\n     */\r\n    close(fd: number): Promise<void>;\r\n\r\n    /**\r\n     * Read specified content from a given file descriptor into a data buffer.\r\n     * @param fd The file descriptor referencing the file to read from.\r\n     * @param pos The offset from the beginning of the file from which data should be read.\r\n     * @param data The buffer that the data will be written to.\r\n     * @param offset The offset in the buffer at which to start writing.\r\n     * @param length The number of bytes to read.\r\n     *\r\n     * @returns A promise of the number of bytes read.\r\n     */\r\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\r\n\r\n    /**\r\n     * Write specified content from the data buffer to the file referenced by the given file descriptor.\r\n     * @param fd The file descriptor referencing the file to write to.\r\n     * @param pos The offset from the beginning of the file where this data should be written.\r\n     * @param offset The part of the buffer to be read from.\r\n     * @param length The number of bytes to write.\r\n     *\r\n     * @returns A promise of the number of bytes written.\r\n     */\r\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\r\n}\r\n\r\nexport function hasOpenReadWriteCloseCapability(provider: FileSystemProvider): provider is FileSystemProviderWithOpenReadWriteCloseCapability {\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\r\n}\r\n\r\n/**\r\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to read\r\n * files as streams, are implemented.\r\n */\r\nexport interface FileSystemProviderWithFileReadStreamCapability extends FileSystemProvider {\r\n    /**\r\n     * Read the  contents of the given file as stream.\r\n     * @param resource The `URI` of the file.\r\n     *\r\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\r\n     */\r\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): Promise<ReadableStreamEvents<Uint8Array>>;\r\n}\r\n\r\nexport function hasFileReadStreamCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadStreamCapability {\r\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\r\n}\r\n\r\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\r\n    error.name = code ? `${code} (FileSystemError)` : 'FileSystemError';\r\n\r\n    return error;\r\n}\r\n\r\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\r\n\r\n    // Guard against abuse\r\n    if (!error) {\r\n        return FileSystemProviderErrorCode.Unknown;\r\n    }\r\n\r\n    // FileSystemProviderError comes with the code\r\n    if (error instanceof FileSystemProviderError) {\r\n        return error.code;\r\n    }\r\n\r\n    // Any other error, check for name match by assuming that the error\r\n    // went through the markAsFileSystemProviderError() method\r\n    const match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\r\n    if (!match) {\r\n        return FileSystemProviderErrorCode.Unknown;\r\n    }\r\n\r\n    switch (match[1]) {\r\n        case FileSystemProviderErrorCode.FileExists:\r\n            return FileSystemProviderErrorCode.FileExists;\r\n        case FileSystemProviderErrorCode.FileIsADirectory:\r\n            return FileSystemProviderErrorCode.FileIsADirectory;\r\n        case FileSystemProviderErrorCode.FileNotADirectory:\r\n            return FileSystemProviderErrorCode.FileNotADirectory;\r\n        case FileSystemProviderErrorCode.FileNotFound:\r\n            return FileSystemProviderErrorCode.FileNotFound;\r\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:\r\n            return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\r\n        case FileSystemProviderErrorCode.FileTooLarge:\r\n            return FileSystemProviderErrorCode.FileTooLarge;\r\n        case FileSystemProviderErrorCode.NoPermissions:\r\n            return FileSystemProviderErrorCode.NoPermissions;\r\n        case FileSystemProviderErrorCode.Unavailable:\r\n            return FileSystemProviderErrorCode.Unavailable;\r\n    }\r\n\r\n    return FileSystemProviderErrorCode.Unknown;\r\n}\r\n\r\nexport function toFileOperationResult(error: Error): FileOperationResult {\r\n\r\n    // FileSystemProviderError comes with the result already\r\n    if (error instanceof FileOperationError) {\r\n        return error.fileOperationResult;\r\n    }\r\n\r\n    // Otherwise try to find from code\r\n    switch (toFileSystemProviderErrorCode(error)) {\r\n        case FileSystemProviderErrorCode.FileNotFound:\r\n            return FileOperationResult.FILE_NOT_FOUND;\r\n        case FileSystemProviderErrorCode.FileIsADirectory:\r\n            return FileOperationResult.FILE_IS_DIRECTORY;\r\n        case FileSystemProviderErrorCode.FileNotADirectory:\r\n            return FileOperationResult.FILE_NOT_DIRECTORY;\r\n        case FileSystemProviderErrorCode.NoPermissions:\r\n            return FileOperationResult.FILE_PERMISSION_DENIED;\r\n        case FileSystemProviderErrorCode.FileExists:\r\n            return FileOperationResult.FILE_MOVE_CONFLICT;\r\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:\r\n            return FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\r\n        case FileSystemProviderErrorCode.FileTooLarge:\r\n            return FileOperationResult.FILE_TOO_LARGE;\r\n        default:\r\n            return FileOperationResult.FILE_OTHER_ERROR;\r\n    }\r\n}\r\n\r\n/**\r\n * A hint to disable etag checking for reading/writing.\r\n */\r\nexport const ETAG_DISABLED = '';\r\n\r\nexport function etag(stat: { mtime: number, size: number }): string;\r\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined;\r\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined {\r\n    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\r\n        return undefined;\r\n    }\r\n\r\n    return stat.mtime.toString(29) + stat.size.toString(31);\r\n}\r\n\r\n/**\r\n * Helper to format a raw byte size into a human readable label.\r\n */\r\nexport class BinarySize {\r\n    static readonly KB = 1024;\r\n    static readonly MB = BinarySize.KB * BinarySize.KB;\r\n    static readonly GB = BinarySize.MB * BinarySize.KB;\r\n    static readonly TB = BinarySize.GB * BinarySize.KB;\r\n\r\n    static formatSize(size: number): string {\r\n        if (size < BinarySize.KB) {\r\n            return size + 'B';\r\n        }\r\n        if (size < BinarySize.MB) {\r\n            return (size / BinarySize.KB).toFixed(2) + 'KB';\r\n        }\r\n        if (size < BinarySize.GB) {\r\n            return (size / BinarySize.MB).toFixed(2) + 'MB';\r\n        }\r\n        if (size < BinarySize.TB) {\r\n            return (size / BinarySize.GB).toFixed(2) + 'GB';\r\n        }\r\n        return (size / BinarySize.TB).toFixed(2) + 'TB';\r\n    }\r\n}\r\n"]}