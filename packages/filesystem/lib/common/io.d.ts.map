{"version":3,"sources":["common/io.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;kFAckF;AASlF,OAAO,GAAG,MAAM,2BAA2B,CAAC;AAC5C,OAAO,EAAC,YAAY,EAAC,MAAM,+BAA+B,CAAC;AAC3D,OAAO,EAAC,iBAAiB,EAAwB,MAAM,oCAAoC,CAAC;AAC5F,OAAO,EAGH,qBAAqB,EAErB,kDAAkD,EACrD,MAAM,SAAS,CAAC;AACjB,OAAO,EAAC,eAAe,EAAE,gBAAgB,EAAE,eAAe,EAAC,MAAM,8BAA8B,CAAC;AAEhG,MAAM,WAAW,uBAAwB,SAAQ,qBAAqB;IAElE;;OAEG;IACH,UAAU,EAAE,MAAM,CAAC;IAEnB;;OAEG;IACH,gBAAgB,CAAC,EAAE,gBAAgB,CAAC;CACvC;AAED;;GAEG;AACH,wBAAsB,kBAAkB,CAAC,CAAC,EACtC,QAAQ,EAAE,kDAAkD,EAC5D,QAAQ,EAAE,GAAG,EACb,MAAM,EAAE,eAAe,CAAC,CAAC,CAAC,EAC1B,WAAW,EAAE,eAAe,CAAC,YAAY,EAAE,CAAC,CAAC,EAC7C,OAAO,EAAE,uBAAuB,EAChC,KAAK,EAAE,iBAAiB,GACzB,OAAO,CAAC,IAAI,CAAC,CAcf","file":"../../src/common/io.d.ts","sourcesContent":["/********************************************************************************\r\n * Copyright (C) 2020 TypeFox and others.\r\n *\r\n * This program and the accompanying materials are made available under the\r\n * terms of the Eclipse Public License v. 2.0 which is available at\r\n * http://www.eclipse.org/legal/epl-2.0.\r\n *\r\n * This Source Code may also be made available under the following Secondary\r\n * Licenses when the conditions for such availability set forth in the Eclipse\r\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\r\n * with the GNU Classpath Exception which is available at\r\n * https://www.gnu.org/software/classpath/license.html.\r\n *\r\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\r\n ********************************************************************************/\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/io.ts\r\n\r\n/* eslint-disable max-len */\r\n\r\nimport URI from '@tart/core/lib/common/uri';\r\nimport {BinaryBuffer} from '@tart/core/lib/common//buffer';\r\nimport {CancellationToken, cancelled as canceled} from '@tart/core/lib/common/cancellation';\r\nimport {\r\n    createFileSystemProviderError,\r\n    ensureFileSystemProviderError,\r\n    FileReadStreamOptions,\r\n    FileSystemProviderErrorCode,\r\n    FileSystemProviderWithOpenReadWriteCloseCapability\r\n} from './files';\r\nimport {DataTransformer, ErrorTransformer, WriteableStream} from '@tart/core/lib/common/stream';\r\n\r\nexport interface CreateReadStreamOptions extends FileReadStreamOptions {\r\n\r\n    /**\r\n     * The size of the buffer to use before sending to the stream.\r\n     */\r\n    bufferSize: number;\r\n\r\n    /**\r\n     * Allows to massage any possibly error that happens during reading.\r\n     */\r\n    errorTransformer?: ErrorTransformer;\r\n}\r\n\r\n/**\r\n * A helper to read a file from a provider with open/read/close capability into a stream.\r\n */\r\nexport async function readFileIntoStream<T>(\r\n    provider: FileSystemProviderWithOpenReadWriteCloseCapability,\r\n    resource: URI,\r\n    target: WriteableStream<T>,\r\n    transformer: DataTransformer<BinaryBuffer, T>,\r\n    options: CreateReadStreamOptions,\r\n    token: CancellationToken\r\n): Promise<void> {\r\n    let error: Error | undefined = undefined;\r\n\r\n    try {\r\n        await doReadFileIntoStream(provider, resource, target, transformer, options, token);\r\n    } catch (err) {\r\n        error = err;\r\n    } finally {\r\n        if (error && options.errorTransformer) {\r\n            error = options.errorTransformer(error);\r\n        }\r\n\r\n        target.end(error);\r\n    }\r\n}\r\n\r\nasync function doReadFileIntoStream<T>(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: DataTransformer<BinaryBuffer, T>, options: CreateReadStreamOptions, token: CancellationToken): Promise<void> {\r\n\r\n    // Check for cancellation\r\n    throwIfCancelled(token);\r\n\r\n    // open handle through provider\r\n    const handle = await provider.open(resource, {create: false});\r\n\r\n    // Check for cancellation\r\n    throwIfCancelled(token);\r\n\r\n    try {\r\n        let totalBytesRead = 0;\r\n        let bytesRead = 0;\r\n        let allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\r\n\r\n        let buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\r\n\r\n        let posInFile = options && typeof options.position === 'number' ? options.position : 0;\r\n        let posInBuffer = 0;\r\n        do {\r\n            // read from source (handle) at current position (pos) into buffer (buffer) at\r\n            // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\r\n            bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\r\n\r\n            posInFile += bytesRead;\r\n            posInBuffer += bytesRead;\r\n            totalBytesRead += bytesRead;\r\n\r\n            if (typeof allowedRemainingBytes === 'number') {\r\n                allowedRemainingBytes -= bytesRead;\r\n            }\r\n\r\n            // when buffer full, create a new one and emit it through stream\r\n            if (posInBuffer === buffer.byteLength) {\r\n                await target.write(transformer(buffer));\r\n\r\n                buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\r\n\r\n                posInBuffer = 0;\r\n            }\r\n        } while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\r\n\r\n        // wrap up with last buffer (also respect maxBytes if provided)\r\n        if (posInBuffer > 0) {\r\n            let lastChunkLength = posInBuffer;\r\n            if (typeof allowedRemainingBytes === 'number') {\r\n                lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\r\n            }\r\n\r\n            target.write(transformer(buffer.slice(0, lastChunkLength)));\r\n        }\r\n    } catch (error) {\r\n        throw ensureFileSystemProviderError(error);\r\n    } finally {\r\n        await provider.close(handle);\r\n    }\r\n}\r\n\r\nfunction throwIfCancelled(token: CancellationToken): boolean {\r\n    if (token.isCancellationRequested) {\r\n        throw canceled();\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction throwIfTooLarge(totalBytesRead: number, options: CreateReadStreamOptions): boolean {\r\n\r\n    // Return early if file is too large to load and we have configured limits\r\n    if (options?.limits) {\r\n        if (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\r\n            throw createFileSystemProviderError('To open a file of this size, you need to restart and allow it to use more memory', FileSystemProviderErrorCode.FileExceedsMemoryLimit);\r\n        }\r\n\r\n        if (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\r\n            throw createFileSystemProviderError('File is too large to open', FileSystemProviderErrorCode.FileTooLarge);\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n"]}