{"version":3,"sources":["common/localstorage/localstorage-fs.ts"],"names":[],"mappings":"AAmBA,eAAO,MAAM,OAAO,YAUnB,CAAC;AASF,eAAO,MAAM,OAAO,QAAO,GAE1B,CAAC;AAUF,eAAO,MAAM,UAAU,QAAO,aAAa,EAS1C,CAAC;AAQF,eAAO,MAAM,QAAQ,SACX,MAAM,UACJ,aAAa,MAAM,QACrB,aAAa,IAAI,KACxB,iBAOF,CAAC;AAKF,eAAO,MAAM,aAAa,SAChB,MAAM,UACJ,aAAa,MAAM,QACrB,aAAa,IAAI,KACxB,aAAa,SAQf,CAAC;AAgBF,eAAO,MAAM,WAAW,OAChB,aAAa,EAAE,KACpB,aAAa,IAAI,GAAG,kBAItB,CAAC;AAGF,eAAO,MAAM,SAAS,OACd,aAAa,EAAE,KACpB,iBAAiB,GAAG,SAOtB,CAAC;AAGF,eAAO,MAAM,cAAc,OACnB,aAAa,EAAE,KACpB,aAAa,SAAS,GAAG,SAO3B,CAAC;AAGF,eAAO,MAAM,UAAU,OACf,aAAa,EAAE,QACb,iBAAiB,SAQ1B,CAAC;AAGF,eAAO,MAAM,eAAe,OACpB,aAAa,EAAE,QACb,aAAa,IAAI,SAS1B,CAAC;AAGF,eAAO,MAAM,eAAe,OACpB,aAAa,EAAE,aACR,aAAa,SAAS,SAQpC,CAAC;AASF,eAAO,MAAM,eAAe,OACpB,aAAa,EAAE,YACT,iBAAiB,KAC5B,aAAa,EAYf,CAAC;AAKF,eAAO,MAAM,cAAc,OACnB,aAAa,EAAE,WACV,aAAa,SAAS,KAChC,aAAa,EAWf,CAAC;AAMF,eAAO,MAAM,WAAW,OAChB,aAAa,EAAE,sDAoBtB,CAAC;AAEF,eAAO,MAAM,UAAU,OACf,aAAa,EAAE,WACV,MAAM,KAChB,aAAa,EAKf,CAAC;AAEF,eAAO,MAAM,QAAQ,OACb,aAAa,EAAE,UACX,aAAa,EAAE,KACxB,aAAa,EAWf,CAAA;AAGD,eAAO,MAAM,gBAAgB,OACrB,aAAa,EAAE,sDA6BtB,CAAC;AAEF,yBAAiB,YAAY,CAAC;IAC1B,KAAY,EAAE,GAAG,MAAM,CAAC;IAExB,KAAY,IAAI;QACZ,IAAI,IAAA;QACJ,SAAS,IAAA;QACT,KAAK,IAAA;KACR;IAED,KAAY,MAAM,GAAG,MAAM,CAAC;IAC5B,KAAY,QAAQ,GAAG,SAAS,GAAG,IAAI,CAAC;IACxC,KAAY,IAAI,GAAG,MAAM,GAAG,MAAM,CAAC;IAEnC,KAAY,MAAM,GAAG,QAAQ,EAAE,CAAC;IAEhC,KAAY,IAAI,GAAG;QACf,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC;QAChB,IAAI,EAAE,MAAM,CAAC;QACb,MAAM,EAAE,MAAM,CAAC;QACf,IAAI,EAAE,IAAI,CAAC;KACd,CAAA;IAED,KAAY,SAAS,GAAG;QACpB,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC;QACrB,IAAI,EAAE,MAAM,CAAC;QACb,MAAM,EAAE,MAAM,CAAC;QACf,QAAQ,EAAE,EAAE,EAAE,CAAA;QACd,IAAI,EAAE,IAAI,CAAC;KACd,CAAA;IAED,UAAiB,KAAK;QAClB,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC;KACpB;CACJ","file":"../../../src/common/localstorage/localstorage-fs.d.ts","sourcesContent":["// key used to access the localStorage\r\n\r\nconst fs_key = \"local-fs\";\r\n\r\n// check if localStorage entry exists\r\n// and correctly initialized with root directory\r\nconst check_fs = (): boolean => {\r\n    if (localStorage.getItem(fs_key) === null) return false;\r\n    let root = read_directory(0);\r\n    if (root === undefined) {\r\n        return false;\r\n    }\r\n    if (!(root.type == LocalStorage.Type.directory && (root as LocalStorage.Directory).name == \"/\")) return false;\r\n\r\n    return true;\r\n};\r\n\r\n// initialize the fs\r\n// if fs does not exist, add localStorage entry and add root directory.\r\nexport const init_fs = () => {\r\n    if (!check_fs()) {\r\n        let rootDir = new_directory(\"/\", 0, {\r\n            // parent of root = root\r\n            type: LocalStorage.Type.directory,\r\n            name: \"/\",\r\n            createAt: new Date(),\r\n        });\r\n        write_directory(0, rootDir);\r\n    }\r\n};\r\n\r\n// clear out the fs\r\nconst clear_fs = () => {\r\n    localStorage.removeItem(fs_key);\r\n    init_fs();\r\n};\r\n\r\n// load the file array from localStorage\r\nexport const load_fs = (): any => {\r\n    return JSON.parse(localStorage.getItem(fs_key)) || [];\r\n};\r\n\r\n// store the given file arrya to localStorage\r\nconst store_fs = (fsList: LocalStorage.FsList) => {\r\n    return localStorage.setItem(fs_key, JSON.stringify(fsList));\r\n};\r\n\r\n// get_new_id: finding new array index for allocation\r\n// tries to find first empty cell,\r\n// if such cell does not exist, the array is extended\r\nexport const get_new_id = (): LocalStorage.Id => {\r\n    const fsList = load_fs();\r\n    for (let i = 0; i < fsList.length; i++) {\r\n        if (fsList[i] == undefined) {\r\n            // empty element is undefined\r\n            return i;\r\n        }\r\n    }\r\n    return fsList.length; // else, return the length\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// Default object constructors of file / directory\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// default constructor for file object\r\n// name: string, parent: id of parent dir, data: object\r\nexport const new_file = (\r\n    name: string,\r\n    parent: LocalStorage.Parent,\r\n    data: LocalStorage.Data,\r\n): LocalStorage.File => {\r\n    return {\r\n        type: LocalStorage.Type.file,\r\n        name: name,\r\n        parent: parent,\r\n        data: data,\r\n    };\r\n};\r\n\r\n// default constructor for directory\r\n// name: string, parent: id of parent dir,\r\n// children: array of id of children file / directory\r\nexport const new_directory = (\r\n    name: string,\r\n    parent: LocalStorage.Parent,\r\n    data: LocalStorage.Data,\r\n): LocalStorage.Directory => {\r\n    return {\r\n        type: LocalStorage.Type.directory,\r\n        name: name,\r\n        parent: parent,\r\n        children: [],\r\n        data: data,\r\n    };\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// atomic fs access functions\r\n////////////////////////////////////////////////////////////////////////////////\r\nconst NotFileError = new Error(\"Not a file\");\r\nconst NotDirectoryError = new Error(\"Not a directory\");\r\nconst NotExistError = new Error(\"Not exist\");\r\nconst AlreadyExistError = new Error(\"Already exist\");\r\n\r\n// Implementation Detail\r\n// each funciton start with load_fs, end with store_fs, each exactly once\r\n// (except read functions)\r\n// think fsList as \"cache\" of the actual fs inside the localStorage\r\n\r\n// return file type at id\r\nexport const get_fs_type = (\r\n    id: LocalStorage.Id\r\n): LocalStorage.Type | LocalStorage.Error => {\r\n    let fsList = load_fs();\r\n    let loaded = fsList[id] || {type: LocalStorage.Type.error};\r\n    return loaded.type;\r\n};\r\n\r\n// return file at id\r\nexport const read_file = (\r\n    id: LocalStorage.Id\r\n): LocalStorage.File | undefined => {\r\n    let fsList = load_fs();\r\n    let loaded = fsList[id] || {type: LocalStorage.Type.error};\r\n    if (loaded.type != LocalStorage.Type.file) {\r\n        return undefined;\r\n    }\r\n    return loaded;\r\n};\r\n\r\n// return directory at id\r\nexport const read_directory = (\r\n    id: LocalStorage.Id\r\n): LocalStorage.Directory | undefined => {\r\n    let fsList = load_fs();\r\n    let loaded = fsList[id] || {type: LocalStorage.Type.error};\r\n    if (loaded.type != LocalStorage.Type.directory) {\r\n        return undefined;\r\n    }\r\n    return loaded as LocalStorage.Directory;\r\n};\r\n\r\n// write a file at id\r\nexport const write_file = (\r\n    id: LocalStorage.Id,\r\n    file: LocalStorage.File\r\n) => {\r\n    if (file.type != LocalStorage.Type.file) {\r\n        throw NotFileError;\r\n    }\r\n    let fsList = load_fs();\r\n    fsList[id] = file;\r\n    store_fs(fsList);\r\n};\r\n\r\n// write file, but only changing data\r\nexport const write_file_data = (\r\n    id: LocalStorage.Id,\r\n    data: LocalStorage.Data,\r\n) => {\r\n    let fsList = load_fs();\r\n    let file = fsList[id] || {type: LocalStorage.Type.error};\r\n    if (file.type != LocalStorage.Type.file) {\r\n        throw NotFileError;\r\n    }\r\n    file.data = data;\r\n    store_fs(fsList);\r\n};\r\n\r\n// write directory at id\r\nexport const write_directory = (\r\n    id: LocalStorage.Id,\r\n    directory: LocalStorage.Directory\r\n) => {\r\n    if (directory.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    let fsList = load_fs();\r\n    fsList[id] = directory;\r\n    store_fs(fsList);\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// adding new files / directories under directory\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// add file to directory at id\r\n// also assigns new id to file\r\n// return id of new file\r\nexport const add_file_to_dir = (\r\n    id: LocalStorage.Id,\r\n    new_file: LocalStorage.File\r\n): LocalStorage.Id => {\r\n    let fsList = load_fs();\r\n    // check directory\r\n    let dir = fsList[id] || {type: LocalStorage.Type.error};\r\n    if (dir.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    let new_id = get_new_id();\r\n    fsList[new_id] = new_file;\r\n    (dir as LocalStorage.Directory).children.push(new_id);\r\n    store_fs(fsList);\r\n    return new_id;\r\n};\r\n\r\n// add directory to directory at id\r\n// also assigns new id to file\r\n// return id of new dir\r\nexport const add_dir_to_dir = (\r\n    id: LocalStorage.Id,\r\n    new_dir: LocalStorage.Directory\r\n): LocalStorage.Id => {\r\n    let fsList = load_fs();\r\n    let dir = fsList[id] || {type: LocalStorage.Type.error};\r\n    if (dir.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    let new_id = get_new_id();\r\n    fsList[new_id] = new_dir;\r\n    (dir as LocalStorage.Directory).children.push(new_id);\r\n    store_fs(fsList);\r\n    return new_id;\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n// remove file at id\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport const remove_file = (\r\n    id: LocalStorage.Id,\r\n    temp_ls: LocalStorage.FsList\r\n): LocalStorage.FsList => {\r\n\r\n    let deleted_temp_ls = temp_ls\r\n\r\n    let file = temp_ls[id] || {type: LocalStorage.Type.error};\r\n    if (file.type != LocalStorage.Type.file) {\r\n        throw NotFileError;\r\n    }\r\n    // 1) delete link to this child from parent\r\n    let parent = temp_ls[file.parent] || {type: LocalStorage.Type.error};\r\n    if (parent.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    parent.children = parent.children.filter((child) => child != id);\r\n    // 2) actually delete\r\n    delete deleted_temp_ls[id];\r\n    store_fs(deleted_temp_ls);\r\n    return deleted_temp_ls\r\n};\r\n\r\nexport const rename_dir = (\r\n    id: LocalStorage.Id,\r\n    newName: string\r\n): LocalStorage.Id => {\r\n    let fsList = load_fs();\r\n    fsList[id].name = newName;\r\n    store_fs(fsList);\r\n    return id;\r\n};\r\n\r\nexport const move_dir = (\r\n    id: LocalStorage.Id,\r\n    parent: LocalStorage.Id,\r\n): LocalStorage.Id => {\r\n    let fsList = load_fs();\r\n    if (fsList[fsList[id].parent].children !== undefined) {\r\n        fsList[fsList[id].parent].children = fsList[fsList[id].parent].children.filter(child => child !== id);\r\n    }\r\n    fsList[id].parent = parent;\r\n    if (fsList[parent].children !== undefined) {\r\n        fsList[parent].children.push(id);\r\n    }\r\n    store_fs(fsList);\r\n    return id;\r\n}\r\n\r\n// remove directory at id\r\nexport const remove_directory = (\r\n    id: LocalStorage.Id,\r\n    temp_ls: LocalStorage.FsList\r\n): LocalStorage.FsList => {\r\n\r\n    let deleted_temp_ls = temp_ls\r\n    let directory = temp_ls[id] || {type: LocalStorage.Type.error};\r\n    if (directory.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    let parent = temp_ls[directory.parent] || {type: LocalStorage.Type.error};\r\n    if (parent.type != LocalStorage.Type.directory) {\r\n        throw NotDirectoryError;\r\n    }\r\n    parent.children = parent.children.filter((child) => child != id);\r\n    // recursively delete all children\r\n\r\n    (directory as LocalStorage.Directory).children.forEach((child) => {\r\n        if (temp_ls[child].type == LocalStorage.Type.file) {\r\n            deleted_temp_ls = remove_file(child, temp_ls);\r\n        } else if (temp_ls[child].type == LocalStorage.Type.directory) {\r\n            deleted_temp_ls = remove_directory(child, temp_ls);\r\n        }\r\n    });\r\n    // finally delete the directory\r\n\r\n    delete deleted_temp_ls[id];\r\n\r\n    store_fs(deleted_temp_ls);\r\n    return deleted_temp_ls\r\n};\r\n\r\nexport namespace LocalStorage {\r\n    export type Id = number;\r\n\r\n    export enum Type {\r\n        file,\r\n        directory,\r\n        error,\r\n    }\r\n\r\n    export type Parent = number;\r\n    export type Children = Directory | File;\r\n    export type Data = string | object;\r\n\r\n    export type FsList = Children[];\r\n\r\n    export type File = {\r\n        type: Type.file,\r\n        name: string,\r\n        parent: Parent,\r\n        data: Data,\r\n    }\r\n\r\n    export type Directory = {\r\n        type: Type.directory,\r\n        name: string,\r\n        parent: Parent,\r\n        children: Id[]\r\n        data: Data,\r\n    }\r\n\r\n    export interface Error {\r\n        type: Type.error,\r\n    }\r\n}\r\n"]}